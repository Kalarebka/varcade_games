{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Code Over Time What is Code Over Time? Code Over Time is all about software engineering. It\u2019s about building production ready software that can be maintained and extended over time. Software Engineering is a skill and it is more than just coding. It involves managing a system as it evolves over time. That system will have many different components, all interconnected. It will behave differently when many people are using it and it will break from time to time. There are a lot of variables at play here \u2013 a lot of tech to learn and understand. Over the course of two decades in the software industry I\u2019ve seen and heard of countless junior engineers experiencing explosive growth during their first six months working in the real world. I\u2019ve also heard from many experienced engineers that they experience most growth when changing job or project. Code Over Time aims to simulate that experience. To give you something real to work on \u2013 and to get you off the rails of coding tutorials. Here you will have your own project to manage, features to build and bugs to fix. There is a quote that I love, that I think sums this up nicely: 1 2 3 \u201cEducation is experience, and the essence of experience is self-reliance.\u201d -Merlyn, \u2018The Sword in the Stone\u2019 In order to be an effective Software Engineer you need to face the challenges that building and releasing real software brings. You can think of Code Over Time as your own personal Internship. A way for you to get real hands on experience, on a real product. Varcade Games Varcade Games is that real world product. It is an online gaming portal that allows game developers build and share their games while also taking advantage of built in functionality, such as a matchmaker and leaderboards. In order to build such a product you need to build and front end and a back end. You need databases and realtime networking. You need build tools and you need to write tests. You also need to get creative. Where there are games there are graphics, music and system design. The Tech In order to work on this project we\u2019ll primarily use Python and Javascript. You\u2019ll also be working with popular tech like Vue.js, Node.js, Django and Flask along with DevOps tech like Docker and Kubernetes Everything you need to be a well rounded engineer. Open Source This project is 100% free and open source. All of the code is available on Github . There are detailed READMEs there that explain how everything works. And of course there is this website that aims to guide you through the process of become confident enough to work on such a project. Who is Code Over Time for? Beginner - Intermediate Coders Have you learned how to write a bit of code? Maybe done a couple of small projects and followed some courses online or completed a year or two of college? Code Over Time is primarily for you. The goal is to give you some hands on experience with the type of project you might actually see when you get your first engineering job. Hopefully it also helps you uncover what you\u2019re actually interested in. Is it server programming? Automation? DevOps? Graphics? On this project you will get to dip your toe in a number of different specialties to see which one fits you best. Engineers changing field Have you been working primarily in Java, but looking to get a Python job? Or maybe doing a lot of front end web stuff but now want to understand exactly what is going on in the backend? Or maybe you want to make the jumps to DevOps and need some hands on experience with Kubernetes. With Code Over Time and Varcade Games you can build the skills you will need to do exactly that. Experienced engineers Are you and experienced engineer that wants to try your hand at Python? Maybe you\u2019ve never done web development and want to try out some of that tech. With Code Over Time you\u2019ve got a real project to jump into and experience those things first hand. Maybe you're interested in learning GoLang? You can try rewriting one of the Varcade Games services in Go to experience the language with real world use cases. Maybe you want to understand Docker a bit better \u2013 there\u2019s plenty of opportunity for that too. Maybe you like making games and would like to plug into and existing framework for hosting it and running multi-player games. Basically what you\u2019ve got is a sandbox, and sitting there on Github waiting for you. The Curious Interested in tech? Patient and willing to put in hours of work? You might find exploring Varcade Games fun. Get in and change things, see what happens. Hack at it and have fun. Who am I? At this point you may be wondering who I am and why you should care about what I have to say. My name is Kev and I\u2019m a Software Engineer from Dublin, Ireland. Well actually that might not be true anymore. At the time of writing I am VP of Engineering at Scopely (we build and publish games), and have been for some time. I still consider myself a software engineer, though it\u2019s been a few years since I\u2019ve been in the weeds, actively contributing code to the projects I\u2019ve been working on. In spite of that, \u2018I\u2019m a Software Engineer\u2019 is still the answer I always give to the question \u2018What do you do?\u2019 Earlier in my career I spent a few years working at IBM, doing some interesting stuff with developer tools and a social search engine. Then I took a pretty big leap from multi-national behemoth down to start-up land, working on mobile apps and websites in the early days of Android and IOS. While I was doing that I also built and ran my own location based Zombie game (think Pokemon Go, but with Zombies). It was called \u2018Outbreak: Zombie Apocalypse\u2019 and it turned out to be a stepping stone into the games industry. Shortly after I released \u2018Outbreak!\u2019 DIGIT Games opened in Dublin. A brand new start up that had ambitious plans to build cross platform strategy games. I joined their team as a game server engineer, working on their first title \u2018Kings of the Realm\u2019, which was a strategy MMO for mobile and browser. After that I became lead server engineer on their next title, and global hit mobile game, Star Trek Fleet Command. Eventually I ended up as VP of Engineering and have had the pleasure of working with many game teams, all across the world, on a number of exciting titles. Throughout that journey I\u2019ve done a little bit of everything. Client and server side development. Build, deployment and operations. Product and game design. Built teams, planned work and coached engineers. I\u2019ve also accidentally nuked live databases and done some horribly hacky things during crisis moments running live services. Over the years I\u2019ve become increasingly interested in training. More specifically: effective training. This project is a manifestation of that. I like to build things and had an itch to write some code so I spent the 2020 Covid-19 lockdown working on this in my spare time. Mostly early mornings before work and weekends. I genuinely believe that the most effective way to get good at software engineering is to do it. And not on small sample projects, like a to-do list, but on the real thing. Most new engineers I\u2019ve spoken to tend to see explosive growth in their first six months in the real world. That\u2019s what I wanted to simulate here \u2013 and I think Varcade Games is a great project to do it with. I also like music (particularly Metal) and Kettlebells. You won\u2019t find me on social media or anything like that \u2013 it seems like they\u2019re bad for you\u2026 but you can find me over on the Code Over Time Discord server . Thanks, -Kev","title":"Welcome"},{"location":"#code-over-time","text":"","title":"Code Over Time"},{"location":"#what-is-code-over-time","text":"Code Over Time is all about software engineering. It\u2019s about building production ready software that can be maintained and extended over time. Software Engineering is a skill and it is more than just coding. It involves managing a system as it evolves over time. That system will have many different components, all interconnected. It will behave differently when many people are using it and it will break from time to time. There are a lot of variables at play here \u2013 a lot of tech to learn and understand. Over the course of two decades in the software industry I\u2019ve seen and heard of countless junior engineers experiencing explosive growth during their first six months working in the real world. I\u2019ve also heard from many experienced engineers that they experience most growth when changing job or project. Code Over Time aims to simulate that experience. To give you something real to work on \u2013 and to get you off the rails of coding tutorials. Here you will have your own project to manage, features to build and bugs to fix. There is a quote that I love, that I think sums this up nicely: 1 2 3 \u201cEducation is experience, and the essence of experience is self-reliance.\u201d -Merlyn, \u2018The Sword in the Stone\u2019 In order to be an effective Software Engineer you need to face the challenges that building and releasing real software brings. You can think of Code Over Time as your own personal Internship. A way for you to get real hands on experience, on a real product.","title":"What is Code Over Time?"},{"location":"#varcade-games","text":"Varcade Games is that real world product. It is an online gaming portal that allows game developers build and share their games while also taking advantage of built in functionality, such as a matchmaker and leaderboards. In order to build such a product you need to build and front end and a back end. You need databases and realtime networking. You need build tools and you need to write tests. You also need to get creative. Where there are games there are graphics, music and system design.","title":"Varcade Games"},{"location":"#the-tech","text":"In order to work on this project we\u2019ll primarily use Python and Javascript. You\u2019ll also be working with popular tech like Vue.js, Node.js, Django and Flask along with DevOps tech like Docker and Kubernetes Everything you need to be a well rounded engineer.","title":"The Tech"},{"location":"#open-source","text":"This project is 100% free and open source. All of the code is available on Github . There are detailed READMEs there that explain how everything works. And of course there is this website that aims to guide you through the process of become confident enough to work on such a project.","title":"Open Source"},{"location":"#who-is-code-over-time-for","text":"","title":"Who is Code Over Time for?"},{"location":"#beginner-intermediate-coders","text":"Have you learned how to write a bit of code? Maybe done a couple of small projects and followed some courses online or completed a year or two of college? Code Over Time is primarily for you. The goal is to give you some hands on experience with the type of project you might actually see when you get your first engineering job. Hopefully it also helps you uncover what you\u2019re actually interested in. Is it server programming? Automation? DevOps? Graphics? On this project you will get to dip your toe in a number of different specialties to see which one fits you best.","title":"Beginner - Intermediate Coders"},{"location":"#engineers-changing-field","text":"Have you been working primarily in Java, but looking to get a Python job? Or maybe doing a lot of front end web stuff but now want to understand exactly what is going on in the backend? Or maybe you want to make the jumps to DevOps and need some hands on experience with Kubernetes. With Code Over Time and Varcade Games you can build the skills you will need to do exactly that.","title":"Engineers changing field"},{"location":"#experienced-engineers","text":"Are you and experienced engineer that wants to try your hand at Python? Maybe you\u2019ve never done web development and want to try out some of that tech. With Code Over Time you\u2019ve got a real project to jump into and experience those things first hand. Maybe you're interested in learning GoLang? You can try rewriting one of the Varcade Games services in Go to experience the language with real world use cases. Maybe you want to understand Docker a bit better \u2013 there\u2019s plenty of opportunity for that too. Maybe you like making games and would like to plug into and existing framework for hosting it and running multi-player games. Basically what you\u2019ve got is a sandbox, and sitting there on Github waiting for you.","title":"Experienced engineers"},{"location":"#the-curious","text":"Interested in tech? Patient and willing to put in hours of work? You might find exploring Varcade Games fun. Get in and change things, see what happens. Hack at it and have fun.","title":"The Curious"},{"location":"#who-am-i","text":"At this point you may be wondering who I am and why you should care about what I have to say. My name is Kev and I\u2019m a Software Engineer from Dublin, Ireland. Well actually that might not be true anymore. At the time of writing I am VP of Engineering at Scopely (we build and publish games), and have been for some time. I still consider myself a software engineer, though it\u2019s been a few years since I\u2019ve been in the weeds, actively contributing code to the projects I\u2019ve been working on. In spite of that, \u2018I\u2019m a Software Engineer\u2019 is still the answer I always give to the question \u2018What do you do?\u2019 Earlier in my career I spent a few years working at IBM, doing some interesting stuff with developer tools and a social search engine. Then I took a pretty big leap from multi-national behemoth down to start-up land, working on mobile apps and websites in the early days of Android and IOS. While I was doing that I also built and ran my own location based Zombie game (think Pokemon Go, but with Zombies). It was called \u2018Outbreak: Zombie Apocalypse\u2019 and it turned out to be a stepping stone into the games industry. Shortly after I released \u2018Outbreak!\u2019 DIGIT Games opened in Dublin. A brand new start up that had ambitious plans to build cross platform strategy games. I joined their team as a game server engineer, working on their first title \u2018Kings of the Realm\u2019, which was a strategy MMO for mobile and browser. After that I became lead server engineer on their next title, and global hit mobile game, Star Trek Fleet Command. Eventually I ended up as VP of Engineering and have had the pleasure of working with many game teams, all across the world, on a number of exciting titles. Throughout that journey I\u2019ve done a little bit of everything. Client and server side development. Build, deployment and operations. Product and game design. Built teams, planned work and coached engineers. I\u2019ve also accidentally nuked live databases and done some horribly hacky things during crisis moments running live services. Over the years I\u2019ve become increasingly interested in training. More specifically: effective training. This project is a manifestation of that. I like to build things and had an itch to write some code so I spent the 2020 Covid-19 lockdown working on this in my spare time. Mostly early mornings before work and weekends. I genuinely believe that the most effective way to get good at software engineering is to do it. And not on small sample projects, like a to-do list, but on the real thing. Most new engineers I\u2019ve spoken to tend to see explosive growth in their first six months in the real world. That\u2019s what I wanted to simulate here \u2013 and I think Varcade Games is a great project to do it with. I also like music (particularly Metal) and Kettlebells. You won\u2019t find me on social media or anything like that \u2013 it seems like they\u2019re bad for you\u2026 but you can find me over on the Code Over Time Discord server . Thanks, -Kev","title":"Who am I?"},{"location":"curriculum/","text":"In the pages that follow we will explore a range of different topics related to software engineering. Hardware, software, coding and of course work on a real world project. A combination of reading and doing. The menu on your left will provide you with reading material that covers various different software engineering related topics as well as detailed guides on how to work with Varcade Games, along with some tasks for you to do yourself. Reading Material This section covers many different but important topics related to computers and software engineering. Some of it technical, some of it more philosophical. The goal here is to help you really understand what is actually going on inside your computer and to get you thinking like a software engineer. Your Internship This section is all about Varcade Games. How to set up your development environment, how to configure the product and how to make changes. This is where you will experience what it is like to be a software engineer out there in the real world. An important Note This will be an ever-evolving curriculum. The project will grow and shift over time and new reading material will be added. You will find this is exactly what happens in the software industry. Nothing is static - and you will need to get used to that fact pretty quickly. What's next? I recommend jumping straight in to your internship. The 'Getting Set Up' and 'Onboarding' documentation will guide you through the process of downloading the project code and running it on your machine. As soon as you start that process you will be learning. If you get frustrated or want a break from the hands on side of things then jump over to the reading material. If you want some human support you can join me over on our dedicated Discord Server . Most importantly - have fun!","title":"Curriculum"},{"location":"curriculum/#reading-material","text":"This section covers many different but important topics related to computers and software engineering. Some of it technical, some of it more philosophical. The goal here is to help you really understand what is actually going on inside your computer and to get you thinking like a software engineer.","title":"Reading Material"},{"location":"curriculum/#your-internship","text":"This section is all about Varcade Games. How to set up your development environment, how to configure the product and how to make changes. This is where you will experience what it is like to be a software engineer out there in the real world.","title":"Your Internship"},{"location":"curriculum/#an-important-note","text":"This will be an ever-evolving curriculum. The project will grow and shift over time and new reading material will be added. You will find this is exactly what happens in the software industry. Nothing is static - and you will need to get used to that fact pretty quickly.","title":"An important Note"},{"location":"curriculum/#whats-next","text":"I recommend jumping straight in to your internship. The 'Getting Set Up' and 'Onboarding' documentation will guide you through the process of downloading the project code and running it on your machine. As soon as you start that process you will be learning. If you get frustrated or want a break from the hands on side of things then jump over to the reading material. If you want some human support you can join me over on our dedicated Discord Server . Most importantly - have fun!","title":"What's next?"},{"location":"internship/","text":"Welcome to your own personal internship. In this section you will go through a rite of passage that all engineers must go through when they find their first job. First you must set up your Development Environment . This is the process of taking a computer and installing all of the software that you will need in order to actually working on the project you've been hired to work on. I won't lie - this can be tedious and annoying. Often times the process is poorly documented and engineers tend to do it once and forget the steps, so when someone new comes along things will be broken and people won't have answers as to why. Furthermore, software ages - new versions of programs and operating systems are released all of the time and the combination of software versions on your computer might combine in just the right way to may sure that nothing works as expected on your machine. The reason I'm telling you all of this is that you know it's not just you . You are not an idiot. Sometimes things and just hard and annoying. But we persevere, learn and eventually get through it. Once your development environment is setup we will move on to Onboarding . Onboarding is the process of learning how to work on a project. The idea is to 'get on board'. In our case you are free to focus on the areas that are of most interest to you. If you are interested in frontend development, web tech or graphics then you can spend most of your time working on those aspects of Varcade Games. If you want to experience the dark art of server side development you can focus on that. Onboarding is general - it will give you a broad exposure to everything. It will give you enough information to actually start making changes to the code and seeing what happens. Once you get there you are ready to actually start working on the project. This means: Fixing bugs Cleaning up code Building new features Writing tests At this point you can call yourself a software engineer!","title":"Overview"},{"location":"resources/","text":"Below are some useful links to documentation and source code related to Code Over Time and Varcade Games. Code Over Time Varcade Games in Github Code Over Time Discord Server Documentation Vue.js Phaser 3 Docker Python Django Flask","title":"Resources"},{"location":"resources/#code-over-time","text":"Varcade Games in Github Code Over Time Discord Server","title":"Code Over Time"},{"location":"resources/#documentation","text":"Vue.js Phaser 3 Docker Python Django Flask","title":"Documentation"},{"location":"coding/","text":"In this section we will talk about code. This will include: Basics Programming languages Syntax Design patterns Refactoring Debugging Data structures Algorithms Data modelling And much more... Stay tuned for more!","title":"Introduction"},{"location":"hardware/","text":"In this section we will be looking at computer hardware. CPUs RAM Monitors Keyboards Mice Transistors Logic Gates Modems And much more... Without hardware, software could not exist - so it's worth scratching beneath the surface of this complex and often intimidating subject. Stay tuned for more!","title":"Introduction"},{"location":"hardware/keyboards_and_mice/","text":"Mouse and Keyboard I'm going to go ahead and assume you know what a mouse and keyboard are and what they do. So you might be wondering why I'd bother writing a whole post about them. Well, what I actually want to do is get you excited about your keyboard... and learn to despise your mouse. Maybe despise is too strong a word... mice are great and absolutely have a place. But if you're going to be spending a lot of time with your computer, it's worth really getting to know your keyboard. But why? You might ask. Let's think about it for a second. When you are sitting at your computer and writing some code or typing up a document, you will have both of your hands on the keyboard. If you then want to use your mouse to do something, like change to a different window or select a menu option, you need to lift your hand off the keyboard and move it over to the mouse. Then you need to move that mouse so that your pointer moves to the desired location. Finally, you can click the thing. This is slow. More often than not you can avoid that hand relocation entirely using keyboard shortcuts. More on that below. But that's not the only reason it is slow. When using a keyboard you can use all ten of your fingers together to produce a serious amount of inputs to your computer. The average mouse has two buttons and a scroll wheel. That's three inputs. So you are wasting two whole fingers! On your key board you can learn to use all of your fingers in a sort of ten finger ballet. The amount of information you can send to your computer through your keyboard vastly outweighs the information you can send via a mouse. You just need to learn how to do it. Touch Typing First of all - touch typing. The ability to type without looking at the keyboard. This is an invaluable skill and worth spending some time on. I won't lie, it can be painful, but there are plenty of tools online to help you improve your typing. My personal favourite is a version of the arcade shooter 'House of the Dead' called 'The Typing of the Dead', where you type words to fend off an incoming horde of zombies. Shifting Shortcuts","title":"Mouse and Keyboard"},{"location":"hardware/keyboards_and_mice/#mouse-and-keyboard","text":"I'm going to go ahead and assume you know what a mouse and keyboard are and what they do. So you might be wondering why I'd bother writing a whole post about them. Well, what I actually want to do is get you excited about your keyboard... and learn to despise your mouse. Maybe despise is too strong a word... mice are great and absolutely have a place. But if you're going to be spending a lot of time with your computer, it's worth really getting to know your keyboard. But why? You might ask. Let's think about it for a second. When you are sitting at your computer and writing some code or typing up a document, you will have both of your hands on the keyboard. If you then want to use your mouse to do something, like change to a different window or select a menu option, you need to lift your hand off the keyboard and move it over to the mouse. Then you need to move that mouse so that your pointer moves to the desired location. Finally, you can click the thing. This is slow. More often than not you can avoid that hand relocation entirely using keyboard shortcuts. More on that below. But that's not the only reason it is slow. When using a keyboard you can use all ten of your fingers together to produce a serious amount of inputs to your computer. The average mouse has two buttons and a scroll wheel. That's three inputs. So you are wasting two whole fingers! On your key board you can learn to use all of your fingers in a sort of ten finger ballet. The amount of information you can send to your computer through your keyboard vastly outweighs the information you can send via a mouse. You just need to learn how to do it.","title":"Mouse and Keyboard"},{"location":"hardware/keyboards_and_mice/#touch-typing","text":"First of all - touch typing. The ability to type without looking at the keyboard. This is an invaluable skill and worth spending some time on. I won't lie, it can be painful, but there are plenty of tools online to help you improve your typing. My personal favourite is a version of the arcade shooter 'House of the Dead' called 'The Typing of the Dead', where you type words to fend off an incoming horde of zombies.","title":"Touch Typing"},{"location":"hardware/keyboards_and_mice/#shifting","text":"","title":"Shifting"},{"location":"hardware/keyboards_and_mice/#shortcuts","text":"","title":"Shortcuts"},{"location":"onboarding/","text":"Code Over Time Welcome to the Code Over Time Onboarding course! Course content Onboarding is a process that you will likely go through many times throughout your career. It's usually the first thing you'll do when you start a new job and throughout your career you will likely 'onboard' on to many different projects. Each experience will be different. Not every team does onboarding the same way and some won't even have a formal process for onboarding. Throughout your career you'll also likely find yourself 'onboarding' others onto various different projects too. So this is an ongoing and constant process for software engineering teams and one that is crucial for any team that wants to be able to grow and adapt to the dynamic environment around them - which is most high performing teams. Considering all of the above, I figured an onboarding focused course was worth doing. The process can itself be challenging because understanding another person's code can be like trying to understand the inner workings of their mind. There are potentially years worth of design and product decisions implicit in the project you'll be working on. You weren't there when those decisions were made, but that doesn't mean they won't have a significant impact on your day to day work. I call this historical context , and it's an important part of onboarding. The more you understand about the product you're working on and its history, the more effective you will be as an engineer working on that project. Over the years I've found that the most effective way to onboard new team members is with a combination of documentation and hands-on tasks, and that is exactly what you will be doing in this course. The Tech Throughout this course you will work with code, markup and scripts using: Javascript Python HTML CSS Bash script And you will use industry standard and modern technologies, such as: Vue.js Django Node.js Flask Docker Linux Phaser 3 These lists may look intimidating now, but don't worry, you will have a lot of support in your journey. Learning outcomes By the time you're finished this course you'll understand how to: Run a set of micro services using Docker Set up an efficient developer workflow using Linux Run a web application with Vue.js Run application servers with Django & Flask Run a multi-player game with websockets How to approach this course There are a few things I want you to keep in mind as you go through this course - some guiding principles. Runners run, throwers throw and engineers engineer When asked how he trains track and field athletes, renowned strength coach Dan John answers: 1 2 3 4 5 Throwers throw. Jumpers jump. Sprinters sprint. Runners run. Hurdlers hurdle. I would like to add Software Engineers engineer to this list. The premise here is simple. If you want to get better at running you need to run. If you want to get better at jumping, you need to jump. Similarly, if you want to become a better Software Engineer then you need to engineer. The progress you make as a software engineer is directly related to amount of time you spend doing actual engineering work. Reading books and blogs, following online courses and watching videos are all useful resources to have and they will help (especially good engineering books that focus on patterns and ideas). But that's all theory. The bulk of your time should be spent on practical. I often say that engineering is surprisingly similar to sport in that you can watch others play a game and read all of the books in the world about that game, but that won't make you an athlete. You have to go play the game. And every game will be different. The opposition, the playing surface, the weather etc... You need to get out there and experience it. This is exactly why I have created Code Over Time - it is an environment in which you can get this real hands on experience. Little and often over the long haul Practicing something for 30 minutes every day over many weeks is far better than practicing something for 4 hours once a week. Consistent exposure is key, so try and build a habit of sitting down for a few minutes as often as possible and getting your hands dirty. Ideally you'd make at least 30 minutes a day available to work on becoming a software engineer. A lot more if possible. Give yourself time This point leads on from the last. This is a marathon, not a sprint - you can't know everything so don't try to cram it all in there. Taking short cuts as a beginner is a sure fire way to hinder your future progress. Take the time to really understand what you are doing. The secret to becoming a really good software engineer? Read code, write code, test code, design systems, release products and repeat for about 8 years. RTFM RTFM is a less than polite way of telling someone to see if the official documentation can answer their question. Understanding how to extract the information you need from documentation is vital. You will depend on documentation written by other people at every turn throughout your career. Some of it will be great (like Redis and Vue.js) and some will be awful (not going to call anyone out here). But that doesn't matter - you still need to figure it out, so get some practice in - read the official docs first whenever you get stuck. Code Over Time courses all include several documentation tasks, where you will need to go read some docs and try to understand the tech you are using. Set some goals What would you like to be able to do? Maybe you like to build your own game and add it to your own Varcade Games? Or perhaps you are interested in server tech and want to be able to optimize and push server systems to their limits. What ever it is, keep it in mind - but in the back of your mind. Focus day to day on getting through this course - your goals will shift and become more defined as you learn more. Head, meet wall There will be many points throughout this course where you will feel as if you are just banging your head against a wall and not making any progress. Embrace this feeling - it's all part of the journey. Perhaps more importantly, it will never go away. It doesn't matter how experienced you are or how good an engineer you are - there will be days where it feels as if computers are conspiring against you. Also remember that there will be moments of joy, accomplishment and satisfaction. Those moments never go away either - embrace them too! And finally Please try to have fun - it's only code. - Kev","title":"Introduction"},{"location":"onboarding/#code-over-time","text":"Welcome to the Code Over Time Onboarding course!","title":"Code Over Time"},{"location":"onboarding/#course-content","text":"Onboarding is a process that you will likely go through many times throughout your career. It's usually the first thing you'll do when you start a new job and throughout your career you will likely 'onboard' on to many different projects. Each experience will be different. Not every team does onboarding the same way and some won't even have a formal process for onboarding. Throughout your career you'll also likely find yourself 'onboarding' others onto various different projects too. So this is an ongoing and constant process for software engineering teams and one that is crucial for any team that wants to be able to grow and adapt to the dynamic environment around them - which is most high performing teams. Considering all of the above, I figured an onboarding focused course was worth doing. The process can itself be challenging because understanding another person's code can be like trying to understand the inner workings of their mind. There are potentially years worth of design and product decisions implicit in the project you'll be working on. You weren't there when those decisions were made, but that doesn't mean they won't have a significant impact on your day to day work. I call this historical context , and it's an important part of onboarding. The more you understand about the product you're working on and its history, the more effective you will be as an engineer working on that project. Over the years I've found that the most effective way to onboard new team members is with a combination of documentation and hands-on tasks, and that is exactly what you will be doing in this course.","title":"Course content"},{"location":"onboarding/#the-tech","text":"Throughout this course you will work with code, markup and scripts using: Javascript Python HTML CSS Bash script And you will use industry standard and modern technologies, such as: Vue.js Django Node.js Flask Docker Linux Phaser 3 These lists may look intimidating now, but don't worry, you will have a lot of support in your journey.","title":"The Tech"},{"location":"onboarding/#learning-outcomes","text":"By the time you're finished this course you'll understand how to: Run a set of micro services using Docker Set up an efficient developer workflow using Linux Run a web application with Vue.js Run application servers with Django & Flask Run a multi-player game with websockets","title":"Learning outcomes"},{"location":"onboarding/#how-to-approach-this-course","text":"There are a few things I want you to keep in mind as you go through this course - some guiding principles.","title":"How to approach this course"},{"location":"onboarding/#runners-run-throwers-throw-and-engineers-engineer","text":"When asked how he trains track and field athletes, renowned strength coach Dan John answers: 1 2 3 4 5 Throwers throw. Jumpers jump. Sprinters sprint. Runners run. Hurdlers hurdle. I would like to add Software Engineers engineer to this list. The premise here is simple. If you want to get better at running you need to run. If you want to get better at jumping, you need to jump. Similarly, if you want to become a better Software Engineer then you need to engineer. The progress you make as a software engineer is directly related to amount of time you spend doing actual engineering work. Reading books and blogs, following online courses and watching videos are all useful resources to have and they will help (especially good engineering books that focus on patterns and ideas). But that's all theory. The bulk of your time should be spent on practical. I often say that engineering is surprisingly similar to sport in that you can watch others play a game and read all of the books in the world about that game, but that won't make you an athlete. You have to go play the game. And every game will be different. The opposition, the playing surface, the weather etc... You need to get out there and experience it. This is exactly why I have created Code Over Time - it is an environment in which you can get this real hands on experience.","title":"Runners run, throwers throw and engineers engineer"},{"location":"onboarding/#little-and-often-over-the-long-haul","text":"Practicing something for 30 minutes every day over many weeks is far better than practicing something for 4 hours once a week. Consistent exposure is key, so try and build a habit of sitting down for a few minutes as often as possible and getting your hands dirty. Ideally you'd make at least 30 minutes a day available to work on becoming a software engineer. A lot more if possible.","title":"Little and often over the long haul"},{"location":"onboarding/#give-yourself-time","text":"This point leads on from the last. This is a marathon, not a sprint - you can't know everything so don't try to cram it all in there. Taking short cuts as a beginner is a sure fire way to hinder your future progress. Take the time to really understand what you are doing. The secret to becoming a really good software engineer? Read code, write code, test code, design systems, release products and repeat for about 8 years.","title":"Give yourself time"},{"location":"onboarding/#rtfm","text":"RTFM is a less than polite way of telling someone to see if the official documentation can answer their question. Understanding how to extract the information you need from documentation is vital. You will depend on documentation written by other people at every turn throughout your career. Some of it will be great (like Redis and Vue.js) and some will be awful (not going to call anyone out here). But that doesn't matter - you still need to figure it out, so get some practice in - read the official docs first whenever you get stuck. Code Over Time courses all include several documentation tasks, where you will need to go read some docs and try to understand the tech you are using.","title":"RTFM"},{"location":"onboarding/#set-some-goals","text":"What would you like to be able to do? Maybe you like to build your own game and add it to your own Varcade Games? Or perhaps you are interested in server tech and want to be able to optimize and push server systems to their limits. What ever it is, keep it in mind - but in the back of your mind. Focus day to day on getting through this course - your goals will shift and become more defined as you learn more.","title":"Set some goals"},{"location":"onboarding/#head-meet-wall","text":"There will be many points throughout this course where you will feel as if you are just banging your head against a wall and not making any progress. Embrace this feeling - it's all part of the journey. Perhaps more importantly, it will never go away. It doesn't matter how experienced you are or how good an engineer you are - there will be days where it feels as if computers are conspiring against you. Also remember that there will be moments of joy, accomplishment and satisfaction. Those moments never go away either - embrace them too!","title":"Head, meet wall"},{"location":"onboarding/#and-finally","text":"Please try to have fun - it's only code. - Kev","title":"And finally"},{"location":"onboarding/closing_words/","text":"Well that's it - you are onboarded. Hopefully the process has been at least a little fun and educational. From here you can start exploring any part of Varcade Games you want. You can try building your own game to hook into it. Maybe you want to extend Varcade Games? What about adding an auto queue to the Matchmaker? Or adding player avatars? Remember that this is just the start - now you have the information you need to go further. So just keep going further.","title":"Next Steps"},{"location":"onboarding/backend/intro/","text":"Now we're entering the depths of the server side. It's dark and full of terrors and our only guiding light is the logging and metrics we have in place. We're back in Python land and it's time to have a look at the Matchmaker and the Stats Tracker. These services are pure backend, meaning there have no visual interface at all. No client to speak of. Changes to this code aren't always immediately visible in our product. So when we're working with our backend services we need to be sure we have good logging in place as well as metrics to help us understand exactly what is going on. We won't dive too deep into these services just yet as this is an onboarding course and the goal is to get a high level view of everything. But we will look at key sections and concerns, such as transactional data management for our matchmaker and Redis streams for passing data around between our services. But first, a quick overview of both of our backend services. Matchmaker The Matchmaker is a service that allows players to connect with each other and player games over the internet. Our implementation of a Matchmaker is very basic, it simply manages a central store of games that players have created. When a player creates a game the matchmaker will make it public so that other players can see and join it. Once all players have joined a game the matchmaker will remove it from public view as no new players can join. Our matchmaker is also responsible for handling error scenarios. For example, what happens if a player creates a game but never joins it? Or what happens if two players try to join the same game at the same time but there is only one slot available? Or worse still, what happens if multiple players join a game, start playing, but then one of them leaves? These are the sorts of things we need to be thinking about when it comes to matchmaking. Stats Tracker The stats tracker is a very simply service. All it does is listen out for game events and then record some of them. It supports leaderboard tracking and player stat tracking. This means that any game hosted on Varcade Games can hook into the service and have its own leaderboard and player stats. In our case we track interesting stats like 'how many times does a player select Rock'. Redis Streams Both of these services are built on top of an in-memory database system called Redis. More specifically, we're using Redis Streams . It's worth having a look at the Redis docs and getting a sense of what it is before continuing with this section as both of our backend services rely heavily on Redis.","title":"Introduction"},{"location":"onboarding/backend/intro/#matchmaker","text":"The Matchmaker is a service that allows players to connect with each other and player games over the internet. Our implementation of a Matchmaker is very basic, it simply manages a central store of games that players have created. When a player creates a game the matchmaker will make it public so that other players can see and join it. Once all players have joined a game the matchmaker will remove it from public view as no new players can join. Our matchmaker is also responsible for handling error scenarios. For example, what happens if a player creates a game but never joins it? Or what happens if two players try to join the same game at the same time but there is only one slot available? Or worse still, what happens if multiple players join a game, start playing, but then one of them leaves? These are the sorts of things we need to be thinking about when it comes to matchmaking.","title":"Matchmaker"},{"location":"onboarding/backend/intro/#stats-tracker","text":"The stats tracker is a very simply service. All it does is listen out for game events and then record some of them. It supports leaderboard tracking and player stat tracking. This means that any game hosted on Varcade Games can hook into the service and have its own leaderboard and player stats. In our case we track interesting stats like 'how many times does a player select Rock'.","title":"Stats Tracker"},{"location":"onboarding/backend/intro/#redis-streams","text":"Both of these services are built on top of an in-memory database system called Redis. More specifically, we're using Redis Streams . It's worth having a look at the Redis docs and getting a sense of what it is before continuing with this section as both of our backend services rely heavily on Redis.","title":"Redis Streams"},{"location":"onboarding/backend/matchmaker/","text":"Key Concepts Creating a Game Understanding how the Matchmaker works is a lot easier with pictures, but even then it can look complicated - but don't worry it's actually quite simple. The following diagram shows what happens when a game is created and then the creator of the game joins the game (by join I mean actually connects to the game server). Take a moment to study this image before proceeding to the explanation of each step: Ok there's quite a lot going on there so let's break it down and look at it step by step. Immediately you should notice that we've not got multiple different services involved here. The is the first time we're seeing all of the various different components of Varcade Games all working together. 1. [Game Portal] Create Game via Matchmaker The first step in this process is opening up Varcade Games. Then we select a game and select multi-player mode. This should open the Matchmaker UI, which is our gateway to the Matchmaker. When a player chooses to create a new multi-player game a request is sent to the Matchmaker server. 2. [Matchmaker] Create Game on Game Server The Matchmaker server then needs to connect to the game server for the selected game and ask it to create a game. 3. [Game Server] Get Token The game server will create the game for the matchmaker and then return a token that can be used to connect to that game. 4. [Matchmaker] Add Game to pending set Once the remote game has been created the Matchmaker them adds the game to something called the 'Pending set'. We do this because we don't consider a game actually active until the player that created it actually joins. We're trying to avoid the scenario where players can join a game but the person who created it in the first place is not there and ready to play. 5. [Matchmaker] Return game token and server URL Once the game is created and in the set of pending games the Matchmaker returns the token for the game and the URL for the server that the game is running on. This will allow a game client to actually connect to the game on the game server. 6. [Game Portal] Pass token and server URL to Game Client The game portal is what receives the token and server URL from the Matchmaker, then it passes them on to the game client (Rock Paper Scissors Apocalypse in our case). 7. [Game Client] Connect to game server with the token Now the game client can actually connect to the game server. It does so by taking the server URL and attaching the token to it before opening a websocket connection. 8. [Game Server] Send 'creator joined' event from game server Once the server verifies the token and actually attaches that players connection to the newly created game it fires an event . This event is a message that gets added to a Redis Stream. At this point the player that created the game can select their character and then must sit and wait for another player to join their game. 9. [Matchmaker] Consume 'creator joined' event in Matchmaker On the other side of the Redis Stream our Matchmaker will receive the 'creator joined' event and handle it. 10. [Matchmaker] Remove the game from the pending set The Matchmaker will remove the game from the pending set as it is no longer pending - the creator has joined, so we are happy to now make that game available for other players to join. 11. [Matchmaker] Add the game to the lobby set The Lobby Set is the set of all games that are ready to be joined. Any games in this set will be displayed in the matchmaker UI as available to join. Hosts Inside our matchmaker we call any player that creates a game the host of that game. This is to differentiate between players that start a game and players that join a game. This allows us to make some simple decisions about game state. As we've already seen, a game cannot move from pending to lobby until the host joins the game. This is because we don't want to advertise a game for others to join if the person that created that game hasn't joined. This distinction between creator/host and joiner also matters when it comes to disconnects. If a player disconnects from a game we can put it back in the lobby set. If a host disconnects the game is destroyed. We don't have to do it like this, but a few simple constraints like this can greatly simplify our concepts and our code. That's it for game creation. Next let's look at what happens when a player joins a game. Joining a Game Having been through the 'create game' flow, hopefully this one is a lot easier to understand. Let's break this one down too and think about some of the details. 1. [Game Portal] Get open games request Before joining a game you need to know if there are games available to join in the first place. When you open the Matchmaker UI in the game portal it will automatically send a request to the Matchmaker server to get a list of currently open games. 2. [Matchmaker] Fetch open games These games come from the Lobby set we discussed in the previous section. 3. [Matchmaker] Return open game list to the client The Matchmaker server then returns all of the games that are open to join to the game portal. 4. [Game Portal] Send join game request to matchmaker The game portal can now send a join request and does so by sending the ID of the game it wants to join to the Matchmaker server. 5. [Matchmaker] Send join game request to game server The Matchmaker then needs to verify that this player can join the game (the game is not at capacity already). 6. [Matchmaker] Return token and server URL to Game Portal If the player can join the Matchmaker server will return the token for the game and the URL of the game server back to the game portal. 7. [Game Portal] Pass token and server URL to Game Client The game portal hands the token and game server URL off to the game client so it game join the game. 8. [Game Client] Connect to game server with the token The game client connects to the game server and the player is presented with the character selection scene. 9. [Game Server] Send 'all players joined' event from game server The game server will now send an another event out on the event stream. This time it is 'all player joined', signifying that the game server now has everything it needs to progress with the game. 10. [Matchmaker] Consume 'all players joined' event in Matchmaker The Matchmaker server is listening out for the 'all players joined' event. 11. [Matchmaker] Move game to the active set Once received it will remove the game from the Lobby set and add it to the Active set . This means the game will no longer show up in the Matchmaker UI. Note The Matchmaker also listens out for 'disconnect' and 'game over' events. If a non-host disconnects the game will be placed back into the 'Lobby set', where a new player can join. Once a 'game over' event is received the game will be removed from the Matchmaker database. Summary Hopefully this all makes sense at this point. The Matchmaker is just a middleman. It creates multi-player games on game servers on behalf of the players and monitors the state of those games via messages coming from the Redis Stream. The goal of the Matchmaker is to offload the burden of managing a multi-player lobby from the games. Any games that want to make use of the Varcade Games Matchmaker just need to register with the Matchmaker and conform to some API requirements. With that in mind, let's take a look at how to actually work with it.","title":"The Matchmaker"},{"location":"onboarding/backend/matchmaker/#key-concepts","text":"","title":"Key Concepts"},{"location":"onboarding/backend/matchmaker/#creating-a-game","text":"Understanding how the Matchmaker works is a lot easier with pictures, but even then it can look complicated - but don't worry it's actually quite simple. The following diagram shows what happens when a game is created and then the creator of the game joins the game (by join I mean actually connects to the game server). Take a moment to study this image before proceeding to the explanation of each step: Ok there's quite a lot going on there so let's break it down and look at it step by step. Immediately you should notice that we've not got multiple different services involved here. The is the first time we're seeing all of the various different components of Varcade Games all working together. 1. [Game Portal] Create Game via Matchmaker The first step in this process is opening up Varcade Games. Then we select a game and select multi-player mode. This should open the Matchmaker UI, which is our gateway to the Matchmaker. When a player chooses to create a new multi-player game a request is sent to the Matchmaker server. 2. [Matchmaker] Create Game on Game Server The Matchmaker server then needs to connect to the game server for the selected game and ask it to create a game. 3. [Game Server] Get Token The game server will create the game for the matchmaker and then return a token that can be used to connect to that game. 4. [Matchmaker] Add Game to pending set Once the remote game has been created the Matchmaker them adds the game to something called the 'Pending set'. We do this because we don't consider a game actually active until the player that created it actually joins. We're trying to avoid the scenario where players can join a game but the person who created it in the first place is not there and ready to play. 5. [Matchmaker] Return game token and server URL Once the game is created and in the set of pending games the Matchmaker returns the token for the game and the URL for the server that the game is running on. This will allow a game client to actually connect to the game on the game server. 6. [Game Portal] Pass token and server URL to Game Client The game portal is what receives the token and server URL from the Matchmaker, then it passes them on to the game client (Rock Paper Scissors Apocalypse in our case). 7. [Game Client] Connect to game server with the token Now the game client can actually connect to the game server. It does so by taking the server URL and attaching the token to it before opening a websocket connection. 8. [Game Server] Send 'creator joined' event from game server Once the server verifies the token and actually attaches that players connection to the newly created game it fires an event . This event is a message that gets added to a Redis Stream. At this point the player that created the game can select their character and then must sit and wait for another player to join their game. 9. [Matchmaker] Consume 'creator joined' event in Matchmaker On the other side of the Redis Stream our Matchmaker will receive the 'creator joined' event and handle it. 10. [Matchmaker] Remove the game from the pending set The Matchmaker will remove the game from the pending set as it is no longer pending - the creator has joined, so we are happy to now make that game available for other players to join. 11. [Matchmaker] Add the game to the lobby set The Lobby Set is the set of all games that are ready to be joined. Any games in this set will be displayed in the matchmaker UI as available to join. Hosts Inside our matchmaker we call any player that creates a game the host of that game. This is to differentiate between players that start a game and players that join a game. This allows us to make some simple decisions about game state. As we've already seen, a game cannot move from pending to lobby until the host joins the game. This is because we don't want to advertise a game for others to join if the person that created that game hasn't joined. This distinction between creator/host and joiner also matters when it comes to disconnects. If a player disconnects from a game we can put it back in the lobby set. If a host disconnects the game is destroyed. We don't have to do it like this, but a few simple constraints like this can greatly simplify our concepts and our code. That's it for game creation. Next let's look at what happens when a player joins a game.","title":"Creating a Game"},{"location":"onboarding/backend/matchmaker/#joining-a-game","text":"Having been through the 'create game' flow, hopefully this one is a lot easier to understand. Let's break this one down too and think about some of the details. 1. [Game Portal] Get open games request Before joining a game you need to know if there are games available to join in the first place. When you open the Matchmaker UI in the game portal it will automatically send a request to the Matchmaker server to get a list of currently open games. 2. [Matchmaker] Fetch open games These games come from the Lobby set we discussed in the previous section. 3. [Matchmaker] Return open game list to the client The Matchmaker server then returns all of the games that are open to join to the game portal. 4. [Game Portal] Send join game request to matchmaker The game portal can now send a join request and does so by sending the ID of the game it wants to join to the Matchmaker server. 5. [Matchmaker] Send join game request to game server The Matchmaker then needs to verify that this player can join the game (the game is not at capacity already). 6. [Matchmaker] Return token and server URL to Game Portal If the player can join the Matchmaker server will return the token for the game and the URL of the game server back to the game portal. 7. [Game Portal] Pass token and server URL to Game Client The game portal hands the token and game server URL off to the game client so it game join the game. 8. [Game Client] Connect to game server with the token The game client connects to the game server and the player is presented with the character selection scene. 9. [Game Server] Send 'all players joined' event from game server The game server will now send an another event out on the event stream. This time it is 'all player joined', signifying that the game server now has everything it needs to progress with the game. 10. [Matchmaker] Consume 'all players joined' event in Matchmaker The Matchmaker server is listening out for the 'all players joined' event. 11. [Matchmaker] Move game to the active set Once received it will remove the game from the Lobby set and add it to the Active set . This means the game will no longer show up in the Matchmaker UI. Note The Matchmaker also listens out for 'disconnect' and 'game over' events. If a non-host disconnects the game will be placed back into the 'Lobby set', where a new player can join. Once a 'game over' event is received the game will be removed from the Matchmaker database.","title":"Joining a Game"},{"location":"onboarding/backend/matchmaker/#summary","text":"Hopefully this all makes sense at this point. The Matchmaker is just a middleman. It creates multi-player games on game servers on behalf of the players and monitors the state of those games via messages coming from the Redis Stream. The goal of the Matchmaker is to offload the burden of managing a multi-player lobby from the games. Any games that want to make use of the Varcade Games Matchmaker just need to register with the Matchmaker and conform to some API requirements. With that in mind, let's take a look at how to actually work with it.","title":"Summary"},{"location":"onboarding/backend/stats_tracker/","text":"We have reached the final service on our whirlwind tour of Varcade Games. The Stats Tracker . This service uses all of the same tech as the Matchmaker so we won't need to spend to long here. Its job is to listen our for game events and use that data to build leaderboards and player statistics for any games registered on Varcade Games. The code for this project is located in the stats_tracker directory of your project root. The project structure should be immediately familiar after looking at the Matchmaker project. In this section we'll check out a interesting aspects of the Stats Tracker and at the end you will run the project tests and checks yourself, just as you've done before on other projects. High Level View This hopefully all makes sense given the fact that the Stats Tracker works much the same way as the Matchmaker. It has a public API for the game portal to connect to. It uses this API to fetch leaderboards and player stats for different games. It also have a worker that runs in the background consuming events from the event stream and updating leaderboards and stats based on those events. Key Concepts There's an api.py in both the stats_tracker/leaderboards and stats_tracker/player_stats . The Game Portal calls the leaderboard API to check the current leaderboard for a registered game. The Player Stats API is where the Game Portal gets per player, per game player statistics. To manage all of this we use a pluggable system for calculating scores based on game events. A game can provide its own scoring logic or us the default system logic. Let's look at leaderboards first. Leaderboards Open up leaderboards/leaderboards.py . You will find two important functions here. register_leaderboard_handler record_result The first function allows you to register a leaderboard 'handler' for a game. The second allows you to record the result of a multiplayer game so that the game's leaderboard gets updated. The registration process is very similar to the WorkerManager -> Worker relationship we saw earlier. In this case we create an instance of a Leaderboard handler and register it against the ID for any game we want to register. Then when we get a game event, we read the product ID from the event and look up the appropriate handler. Once we have a leaderboard handler we can record a result. The record result function signature looks like this: 1 def record_result ( product_id : str , winner_id : str , loser_id : str ) -> bool : What the system will do is get both player's current scores and then update them based on who won. The default system leaderboard handler simple adds 1 point for every win. You could change this behavior for other games by adding new handlers that run ELO calculations or other more advanced leaderboard scoring. If you open leaderboards/handler.py you will find the default handler: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class LeaderboardHandler : \"\"\"This class can be overridden and registered as a leaderboard handler. This gives individual games the ability to handle more complex scoring, such as ELO \"\"\" def get_updated_scores ( self , winner_id , winner_current_score , loser_id , loser_current_score ): \"\"\" Default implementation with return current score + 1 for the winner and current score for the loser returns: tuple containing the new score for the winner and the new scores for the loser \"\"\" if winner_current_score is None : winner_current_score = 0 if loser_current_score is None : loser_current_score = 0 return ( winner_current_score + 1 , loser_current_score ) A valid Leaderboard handler class must include the get_updated_scores method. As you can see the default logic is pretty simple. To register leaderboard handlers you can add them in stats_tracker/app.py : 1 2 3 4 5 6 7 def init_stats_tracker ( db_url_str : str ): initialise_db ( db_url_str ) # Add stats handlers for all products here. logging . info ( \"Registering player stats handlers.\" ) register_player_stats_handler ( \"default\" , PlayerStatsHandler ()) register_leaderboard_handler ( \"default\" , LeaderboardHandler ()) register_player_stats_handler ( \"exrps\" , EXRPSStatsHandler ()) We register a single Leaderboard handler there, but we register two 'Player Stats Handlers', so lets have a look at why that is. Player Stats Open up player_stats/player_stats.py . You'll notice that it is more or less the same setup as for our Leaderboards. For Player Stats however, we have a track_event function instead of a record_result function. It does however do more or less the same thing. It looks up a handler for the given product ID and uses it to process the given event. If you open up player_stats/handlers.py you will see exactly what the handlers do. The first handler you will find is the PlayerStatsHandler . This is a generic handler that can read 'game_over' events coming from the game servers. It has some simple logic that will update redis with a win/loss value for each player referenced in the event. Any two player multi-player game that just wants to track wins and losses could just use this simple handler. Rock Paper Scissors Apocalypse wanted more though, so it gets a dedicated handler: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class EXRPSStatsHandler ( PlayerStatsHandler ): \"\"\"Event handler for exRPS specific multiplayer stats.\"\"\" def process_event ( self , event ): try : if event . get ( \"event_name\" ) == \"select_weapon\" : logging . info ( f \"EXRPSStatsHandler: Handling event: { event } \" ) user_id = event [ \"user_id\" ] selection = { \"null\" : \"botch\" , \"0\" : \"rock\" , \"1\" : \"paper\" , \"2\" : \"scissors\" , }[ event [ \"event_data\" ]] get_stats_tracker_db () . hincrby ( f \"_pstats: { event [ 'user_id' ] } : { event [ 'product_id' ] } \" , f \" { selection } _selection_count\" , 1 , ) else : super () . process_event ( event ) except KeyError : logging . warning ( f \"Invalid exRPS event received: { event } \" ) We don't need to go through this code in details, but you should notice that this logic all references concepts that are specific to the game. This handler is not useful at all outside of Rock Paper Scissors. But for that one game it's great, because we get to track people's weapon selections across every multi-player game they play. This is why we registered this specific handler against the product ID for Rock Paper Scissors Apocalypse, as discussed earlier. Workers Workers are back! The stats tracker only has a single worker type - an event worker. The implementation of Workers is the exact same as the Matchmaker. In fact it is the same code, just duplicated across both locations. Note You might be thinking 'but that's a terrible idea - why have the same code in two places?' and you would be right to think that. This will be the focus of a future refactoring task for you. The stats tracker does add some specialization though. It needs to listen for some different events. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 if event_data . get ( b \"type\" , None ) == b \"game_over\" : logging . info ( f \"Processing Stream Event: { event_data } \" ) product_id = event_data [ b \"product_id\" ] . decode ( \"utf-8\" ) winner_id = event_data [ b \"winner_id\" ] . decode ( \"utf-8\" ) loser_id = event_data [ b \"loser_id\" ] . decode ( \"utf-8\" ) record_result ( product_id , winner_id , loser_id ) processed_event_count += 1 if event_data . get ( b \"product_id\" , None ) is not None : product_id = event_data [ b \"product_id\" ] . decode ( \"utf-8\" ) track_event ( product_id , { a . decode ( \"utf-8\" ): b . decode ( \"utf-8\" ) for a , b in event_data . items () }, ) The above code sample comes from stats_tracker/workers/event_stream_workers.py . This is where the worker decides if it needs to call record_result to update a leaderboard, which it does by checking if the event is a game_over type event. It also decides whether to call track_event in our player_stats package. If there is a product_id field specified we will attempt to track the events. In both cases it's up to the handlers we discussed earlier how to handle the data coming from the event. They might decide to do nothing with it or they might decide to save information to the database. That's all implementation specific. Running the tests At this point I think it's a good idea you to figure out this part on your own. The commands are all the same as for the Matchmaker, and the Game Portal server before that. You need to build and run a test image then run the tests, coverage and type checking.","title":"The Stats Tracker"},{"location":"onboarding/backend/stats_tracker/#high-level-view","text":"This hopefully all makes sense given the fact that the Stats Tracker works much the same way as the Matchmaker. It has a public API for the game portal to connect to. It uses this API to fetch leaderboards and player stats for different games. It also have a worker that runs in the background consuming events from the event stream and updating leaderboards and stats based on those events.","title":"High Level View"},{"location":"onboarding/backend/stats_tracker/#key-concepts","text":"There's an api.py in both the stats_tracker/leaderboards and stats_tracker/player_stats . The Game Portal calls the leaderboard API to check the current leaderboard for a registered game. The Player Stats API is where the Game Portal gets per player, per game player statistics. To manage all of this we use a pluggable system for calculating scores based on game events. A game can provide its own scoring logic or us the default system logic. Let's look at leaderboards first.","title":"Key Concepts"},{"location":"onboarding/backend/stats_tracker/#leaderboards","text":"Open up leaderboards/leaderboards.py . You will find two important functions here. register_leaderboard_handler record_result The first function allows you to register a leaderboard 'handler' for a game. The second allows you to record the result of a multiplayer game so that the game's leaderboard gets updated. The registration process is very similar to the WorkerManager -> Worker relationship we saw earlier. In this case we create an instance of a Leaderboard handler and register it against the ID for any game we want to register. Then when we get a game event, we read the product ID from the event and look up the appropriate handler. Once we have a leaderboard handler we can record a result. The record result function signature looks like this: 1 def record_result ( product_id : str , winner_id : str , loser_id : str ) -> bool : What the system will do is get both player's current scores and then update them based on who won. The default system leaderboard handler simple adds 1 point for every win. You could change this behavior for other games by adding new handlers that run ELO calculations or other more advanced leaderboard scoring. If you open leaderboards/handler.py you will find the default handler: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class LeaderboardHandler : \"\"\"This class can be overridden and registered as a leaderboard handler. This gives individual games the ability to handle more complex scoring, such as ELO \"\"\" def get_updated_scores ( self , winner_id , winner_current_score , loser_id , loser_current_score ): \"\"\" Default implementation with return current score + 1 for the winner and current score for the loser returns: tuple containing the new score for the winner and the new scores for the loser \"\"\" if winner_current_score is None : winner_current_score = 0 if loser_current_score is None : loser_current_score = 0 return ( winner_current_score + 1 , loser_current_score ) A valid Leaderboard handler class must include the get_updated_scores method. As you can see the default logic is pretty simple. To register leaderboard handlers you can add them in stats_tracker/app.py : 1 2 3 4 5 6 7 def init_stats_tracker ( db_url_str : str ): initialise_db ( db_url_str ) # Add stats handlers for all products here. logging . info ( \"Registering player stats handlers.\" ) register_player_stats_handler ( \"default\" , PlayerStatsHandler ()) register_leaderboard_handler ( \"default\" , LeaderboardHandler ()) register_player_stats_handler ( \"exrps\" , EXRPSStatsHandler ()) We register a single Leaderboard handler there, but we register two 'Player Stats Handlers', so lets have a look at why that is.","title":"Leaderboards"},{"location":"onboarding/backend/stats_tracker/#player-stats","text":"Open up player_stats/player_stats.py . You'll notice that it is more or less the same setup as for our Leaderboards. For Player Stats however, we have a track_event function instead of a record_result function. It does however do more or less the same thing. It looks up a handler for the given product ID and uses it to process the given event. If you open up player_stats/handlers.py you will see exactly what the handlers do. The first handler you will find is the PlayerStatsHandler . This is a generic handler that can read 'game_over' events coming from the game servers. It has some simple logic that will update redis with a win/loss value for each player referenced in the event. Any two player multi-player game that just wants to track wins and losses could just use this simple handler. Rock Paper Scissors Apocalypse wanted more though, so it gets a dedicated handler: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class EXRPSStatsHandler ( PlayerStatsHandler ): \"\"\"Event handler for exRPS specific multiplayer stats.\"\"\" def process_event ( self , event ): try : if event . get ( \"event_name\" ) == \"select_weapon\" : logging . info ( f \"EXRPSStatsHandler: Handling event: { event } \" ) user_id = event [ \"user_id\" ] selection = { \"null\" : \"botch\" , \"0\" : \"rock\" , \"1\" : \"paper\" , \"2\" : \"scissors\" , }[ event [ \"event_data\" ]] get_stats_tracker_db () . hincrby ( f \"_pstats: { event [ 'user_id' ] } : { event [ 'product_id' ] } \" , f \" { selection } _selection_count\" , 1 , ) else : super () . process_event ( event ) except KeyError : logging . warning ( f \"Invalid exRPS event received: { event } \" ) We don't need to go through this code in details, but you should notice that this logic all references concepts that are specific to the game. This handler is not useful at all outside of Rock Paper Scissors. But for that one game it's great, because we get to track people's weapon selections across every multi-player game they play. This is why we registered this specific handler against the product ID for Rock Paper Scissors Apocalypse, as discussed earlier.","title":"Player Stats"},{"location":"onboarding/backend/stats_tracker/#workers","text":"Workers are back! The stats tracker only has a single worker type - an event worker. The implementation of Workers is the exact same as the Matchmaker. In fact it is the same code, just duplicated across both locations. Note You might be thinking 'but that's a terrible idea - why have the same code in two places?' and you would be right to think that. This will be the focus of a future refactoring task for you. The stats tracker does add some specialization though. It needs to listen for some different events. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 if event_data . get ( b \"type\" , None ) == b \"game_over\" : logging . info ( f \"Processing Stream Event: { event_data } \" ) product_id = event_data [ b \"product_id\" ] . decode ( \"utf-8\" ) winner_id = event_data [ b \"winner_id\" ] . decode ( \"utf-8\" ) loser_id = event_data [ b \"loser_id\" ] . decode ( \"utf-8\" ) record_result ( product_id , winner_id , loser_id ) processed_event_count += 1 if event_data . get ( b \"product_id\" , None ) is not None : product_id = event_data [ b \"product_id\" ] . decode ( \"utf-8\" ) track_event ( product_id , { a . decode ( \"utf-8\" ): b . decode ( \"utf-8\" ) for a , b in event_data . items () }, ) The above code sample comes from stats_tracker/workers/event_stream_workers.py . This is where the worker decides if it needs to call record_result to update a leaderboard, which it does by checking if the event is a game_over type event. It also decides whether to call track_event in our player_stats package. If there is a product_id field specified we will attempt to track the events. In both cases it's up to the handlers we discussed earlier how to handle the data coming from the event. They might decide to do nothing with it or they might decide to save information to the database. That's all implementation specific.","title":"Workers"},{"location":"onboarding/backend/stats_tracker/#running-the-tests","text":"At this point I think it's a good idea you to figure out this part on your own. The commands are all the same as for the Matchmaker, and the Game Portal server before that. You need to build and run a test image then run the tests, coverage and type checking.","title":"Running the tests"},{"location":"onboarding/backend/workers/","text":"Back when you being introduced to the matchmaker you saw some diagrams that spoke of Redis Streams and Events. You were told the Matchmaker consumes data from an event stream and uses that data to move games around between the pending, lobby and active sets. The Matchmaker Worker is what is responsible for all of this. It is another application, distinct from our server code but using the same codebase, that we run on it's on server whose only job is to process these events. Entry Point Our Matchmaker Worker is just a Python process running on a Linux container. A worker can be started by running the code in matchmaker/game_worker.py . Most of the code in there is processing application args, setting up logging and metrics. The bits we're interested in are: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 worker_manager = WorkerManager () # 1. Create worker manager worker_manager . register_worker ( GameCurationWorker ( config )) # 2. Add worker worker_manager . register_worker ( GameEventWorker ( config . EVENT_STREAM_URL ) ) # 3. Add another one < snip > logging . info ( \"Starting worker main loop...\" ) while not sigHandler . terminate : # 4. Loop until terminate signal is received events_processed = 0 with s . time (): events_processed = worker_manager . run_workers () # 5.Run workers c . inc ( events_processed ) logging . info ( \"Termination signal received - stopping worker\" ) All we're doing here is creating an instance of something called a 'WorkerManager', adding some 'workers' to it and then running an infinite loop (until a terminate signal is received) and telling the 'worker manager' to 'run workers'. Lets run through the code, following the numbered comments: 'WorkerManager' is a custom class. It manages a collection of 'Worker' objects. Here we add a 'GameCurationWorker' to our WorkerManager. It's job is to look through the Pending, Lobby and Active sets to see if it needs to clean up any old or expired games. For example, a player may create a game but not join, which would leave that game sitting in the pending set forever. Here we add a 'GameEventWorker'. This worker listens for game events, specifically the 'creator_joined', 'all_players_joined' and 'game_over' events. It uses these events to update Matchmaker game data so that it has an accurate picture of the current game state. We run a loop until the application is closed. In this loop we call a method 'run_workers' of our worker manager. This method loops through all registered workers and runs their code. So essentially all this program does is call a set of functions over and over and over and over until the application is forcefully closed. The code for our workers is in matchmakers/workers . The Worker code The WorkerManager itself is very simple. Open up worker_manager.py . The first thing you'll find is an interface: 1 2 3 4 5 6 7 8 9 10 class AsyncWorker : \"\"\"Base class that needs to be implemented in order for an object to be registered with the Worker Manager. \"\"\" def run ( self ): raise NotImplementedError () def get_name ( self ): raise NotImplementedError () As the docstring says, in order for a worker to be registered with our WorkerManager it needs to implement a 'run' method and a 'get_name' method. The WorkerManager itself only has two methods: register_worker run_workers Registering a worker adds it to a list. Calling run_workers iterates over that list calling the 'run' method of the worker. Game Curation Open up game_management_workers.py . This is where our Game Curation Worker lives. The method we're most interested in is: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 def purge_expired_games ( self , product_id , batch_size = 10 ) -> int : \"\"\"Remove any games from the pending/lobby/active sets that have been inactive for too long. The oldest games are read from the three sets and deleted if the 'is_expired' property of the game object returns True. product_id (str):The ID of the product whose games are being cleaned up batch_size (int):The number of games to process on each run \"\"\" purged_game_count = 0 for game_id in self . dao . get_oldest_pending_games ( product_id , result_set_size = batch_size ): if self . purge_game_if_expired ( product_id , game_id ): purged_game_count += 1 for game_id in self . dao . get_oldest_lobby_games ( product_id , result_set_size = batch_size ): if self . purge_game_if_expired ( product_id , game_id ): purged_game_count += 1 for game_id in self . dao . get_oldest_active_games ( product_id , result_set_size = batch_size ): if self . purge_game_if_expired ( product_id , game_id ): purged_game_count += 1 return purged_game_count The code should be pretty self explanatory. It reads the oldest entries from from the Pending, Lobby and Active sets, checks if they have expired and purges them from the DB if they have. Each set has an expiry time that is configurable (see STATE_EXPIRY in matchmaker/game_data/models.py ). For example, a pending game will expire if the creator doesn't join within 60 seconds of creating it. Once the creator has joined their game will expire if no other player joins for 10 minutes. This worker's job is to keep our database nice and clean. Game Events The Game Event worker is another place in which the Matchmaker interfaces with the actual games that are using it. We saw earlier that our Matchmaker server will send HTTP requests to the game servers to create, join and remove games. But now the Matchmaker needs to listen to what is going on with the game servers, rather than issuing requests to them. Our Game Event worker is a bit more complex. It is reading events directly from a Redis Stream and depending on the event it will perform certain actions. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 if event_data . get ( b \"type\" , None ) == b \"state_change\" : logging . info ( f \"Processing Stream Event: { event_data } \" ) self . update_game_state ( event_data [ b \"product_id\" ] . decode ( \"utf-8\" ), event_data [ b \"game_id\" ] . decode ( \"utf-8\" ), event_data [ b \"new_state\" ] . decode ( \"utf-8\" ), ) processed_event_count += 1 elif event_data . get ( b \"type\" , None ) == b \"game_removed\" : self . handle_game_removal ( event_data [ b \"product_id\" ] . decode ( \"utf-8\" ), event_data [ b \"game_id\" ] . decode ( \"utf-8\" ), ) processed_event_count += 1 elif event_data . get ( b \"type\" , None ) == b \"player_disconnect\" : self . handle_player_disconnect ( event_data [ b \"product_id\" ] . decode ( \"utf-8\" ), event_data [ b \"game_id\" ] . decode ( \"utf-8\" ), event_data [ b \"player_id\" ] . decode ( \"utf-8\" ), ) It cares about three events: state_change game_removed player_disconnect State Change The Matchmaker maintains it's own internal state for games: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # The game has been created CREATED = \"created\" # The creator of the game has joined the game # on the actual game server. Other players can # now join. CREATOR_JOINED = \"creator_joined\" # All required players have now joined. This signifies # that the game can be started ALL_PLAYERS_JOINED = \"all_players_joined\" # The game is in progress - the duration will vary from # game to game IN_PROGRESS = \"in_progress\" # The game has ended ENDED = \"ended\" We've talked about all of these states already. The game server sends out state_change events that the matchmaker uses to updates it's own state. Any game that wants to hook into the matchmaker should send these events. This worker will also take more specific action when the state changes to CREATOR_JOINED'. At this point the game needs to move to the Lobby set from the Pending set. Game Removed This event is a notification from the game server to say a game has been removed from the game server. The worker will try to remove any records of the game that it currently has. Player Disconnect In this case a non-host disconnected from an active game. Our worker needs to respond by placing the game back in the Lobby set so that they can try join again, or allow someone else to join. Working with the Workers From your build_tools directory run: 1 make ps You should see something like: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 Name Command State Ports ----------------------------------------------------------------------------------------------------------------- game-portal /bin/sh -c gunicorn game_p ... Up 0 .0.0.0:8000->8000/tcp game-portal-client docker-entrypoint.sh npm r ... Up 0 .0.0.0:8002->8002/tcp game-rps docker-entrypoint.sh /bin/ ... Up 0 .0.0.0:8080->8080/tcp, 0 .0.0.0:8085->8085/tcp game-rps-client docker-entrypoint.sh /bin/ ... Up 0 .0.0.0:8090->8090/tcp gameportaldb docker-entrypoint.sh mysqld Up 0 .0.0.0:3306->3306/tcp, 33060 /tcp grafana /run.sh Up 0 .0.0.0:3001->3000/tcp matchmaker /bin/sh -c gunicorn --relo ... Up 0 .0.0.0:5050->5050/tcp matchmaker-worker /bin/sh -c python game_wor ... Up 0 .0.0.0:5051->5051/tcp prometheus /bin/prometheus --config.f ... Up 0 .0.0.0:9090->9090/tcp redis-db docker-entrypoint.sh redis ... Up 0 .0.0.0:6379->6379/tcp stats-tracker /bin/sh -c gunicorn --relo ... Up 0 .0.0.0:5000->5000/tcp stats-tracker-worker /bin/sh -c python stats_wo ... Up 0 .0.0.0:5002->5002/tcp The line we're interested in now is: 1 matchmaker-worker /bin/sh -c python game_wor ... Up 0 .0.0.0:5051->5051/tcp This is the container that is running our Matchmaker worker. Note Note that there is a port exposed on this container 0.0.0.0:5051->5051/tcp . This isn't our worker exactly, it is a metrics server that were using to share metrics about the worker so that we can monitor its performance. All the usual commands work for this container: 1 2 3 4 5 make logs a=matchmaker-worker make build a=matchmaker-worker make start a=matchmaker-worker make restart a=matchmaker-worker make stop a=matchmaker-worker Tests You have already run the tests for the workers. Since our worker and server live in the one codebase, everything you did in the last section around running tests, coverage and type checking was also covering the worker code. You've now go enough information about the Matchmaker system to go exploring and hopefully make some sense of it all. There will be may more courses on this stuff available on codeovertime.com , so don't worry if this part is hard to follow. The onboarding course is just meant to get everything up and running with a general understanding of how it all works. Just enough so that you know where to look and what you need to learn.","title":"The Workers"},{"location":"onboarding/backend/workers/#entry-point","text":"Our Matchmaker Worker is just a Python process running on a Linux container. A worker can be started by running the code in matchmaker/game_worker.py . Most of the code in there is processing application args, setting up logging and metrics. The bits we're interested in are: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 worker_manager = WorkerManager () # 1. Create worker manager worker_manager . register_worker ( GameCurationWorker ( config )) # 2. Add worker worker_manager . register_worker ( GameEventWorker ( config . EVENT_STREAM_URL ) ) # 3. Add another one < snip > logging . info ( \"Starting worker main loop...\" ) while not sigHandler . terminate : # 4. Loop until terminate signal is received events_processed = 0 with s . time (): events_processed = worker_manager . run_workers () # 5.Run workers c . inc ( events_processed ) logging . info ( \"Termination signal received - stopping worker\" ) All we're doing here is creating an instance of something called a 'WorkerManager', adding some 'workers' to it and then running an infinite loop (until a terminate signal is received) and telling the 'worker manager' to 'run workers'. Lets run through the code, following the numbered comments: 'WorkerManager' is a custom class. It manages a collection of 'Worker' objects. Here we add a 'GameCurationWorker' to our WorkerManager. It's job is to look through the Pending, Lobby and Active sets to see if it needs to clean up any old or expired games. For example, a player may create a game but not join, which would leave that game sitting in the pending set forever. Here we add a 'GameEventWorker'. This worker listens for game events, specifically the 'creator_joined', 'all_players_joined' and 'game_over' events. It uses these events to update Matchmaker game data so that it has an accurate picture of the current game state. We run a loop until the application is closed. In this loop we call a method 'run_workers' of our worker manager. This method loops through all registered workers and runs their code. So essentially all this program does is call a set of functions over and over and over and over until the application is forcefully closed. The code for our workers is in matchmakers/workers .","title":"Entry Point"},{"location":"onboarding/backend/workers/#the-worker-code","text":"The WorkerManager itself is very simple. Open up worker_manager.py . The first thing you'll find is an interface: 1 2 3 4 5 6 7 8 9 10 class AsyncWorker : \"\"\"Base class that needs to be implemented in order for an object to be registered with the Worker Manager. \"\"\" def run ( self ): raise NotImplementedError () def get_name ( self ): raise NotImplementedError () As the docstring says, in order for a worker to be registered with our WorkerManager it needs to implement a 'run' method and a 'get_name' method. The WorkerManager itself only has two methods: register_worker run_workers Registering a worker adds it to a list. Calling run_workers iterates over that list calling the 'run' method of the worker.","title":"The Worker code"},{"location":"onboarding/backend/workers/#game-curation","text":"Open up game_management_workers.py . This is where our Game Curation Worker lives. The method we're most interested in is: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 def purge_expired_games ( self , product_id , batch_size = 10 ) -> int : \"\"\"Remove any games from the pending/lobby/active sets that have been inactive for too long. The oldest games are read from the three sets and deleted if the 'is_expired' property of the game object returns True. product_id (str):The ID of the product whose games are being cleaned up batch_size (int):The number of games to process on each run \"\"\" purged_game_count = 0 for game_id in self . dao . get_oldest_pending_games ( product_id , result_set_size = batch_size ): if self . purge_game_if_expired ( product_id , game_id ): purged_game_count += 1 for game_id in self . dao . get_oldest_lobby_games ( product_id , result_set_size = batch_size ): if self . purge_game_if_expired ( product_id , game_id ): purged_game_count += 1 for game_id in self . dao . get_oldest_active_games ( product_id , result_set_size = batch_size ): if self . purge_game_if_expired ( product_id , game_id ): purged_game_count += 1 return purged_game_count The code should be pretty self explanatory. It reads the oldest entries from from the Pending, Lobby and Active sets, checks if they have expired and purges them from the DB if they have. Each set has an expiry time that is configurable (see STATE_EXPIRY in matchmaker/game_data/models.py ). For example, a pending game will expire if the creator doesn't join within 60 seconds of creating it. Once the creator has joined their game will expire if no other player joins for 10 minutes. This worker's job is to keep our database nice and clean.","title":"Game Curation"},{"location":"onboarding/backend/workers/#game-events","text":"The Game Event worker is another place in which the Matchmaker interfaces with the actual games that are using it. We saw earlier that our Matchmaker server will send HTTP requests to the game servers to create, join and remove games. But now the Matchmaker needs to listen to what is going on with the game servers, rather than issuing requests to them. Our Game Event worker is a bit more complex. It is reading events directly from a Redis Stream and depending on the event it will perform certain actions. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 if event_data . get ( b \"type\" , None ) == b \"state_change\" : logging . info ( f \"Processing Stream Event: { event_data } \" ) self . update_game_state ( event_data [ b \"product_id\" ] . decode ( \"utf-8\" ), event_data [ b \"game_id\" ] . decode ( \"utf-8\" ), event_data [ b \"new_state\" ] . decode ( \"utf-8\" ), ) processed_event_count += 1 elif event_data . get ( b \"type\" , None ) == b \"game_removed\" : self . handle_game_removal ( event_data [ b \"product_id\" ] . decode ( \"utf-8\" ), event_data [ b \"game_id\" ] . decode ( \"utf-8\" ), ) processed_event_count += 1 elif event_data . get ( b \"type\" , None ) == b \"player_disconnect\" : self . handle_player_disconnect ( event_data [ b \"product_id\" ] . decode ( \"utf-8\" ), event_data [ b \"game_id\" ] . decode ( \"utf-8\" ), event_data [ b \"player_id\" ] . decode ( \"utf-8\" ), ) It cares about three events: state_change game_removed player_disconnect","title":"Game Events"},{"location":"onboarding/backend/workers/#state-change","text":"The Matchmaker maintains it's own internal state for games: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # The game has been created CREATED = \"created\" # The creator of the game has joined the game # on the actual game server. Other players can # now join. CREATOR_JOINED = \"creator_joined\" # All required players have now joined. This signifies # that the game can be started ALL_PLAYERS_JOINED = \"all_players_joined\" # The game is in progress - the duration will vary from # game to game IN_PROGRESS = \"in_progress\" # The game has ended ENDED = \"ended\" We've talked about all of these states already. The game server sends out state_change events that the matchmaker uses to updates it's own state. Any game that wants to hook into the matchmaker should send these events. This worker will also take more specific action when the state changes to CREATOR_JOINED'. At this point the game needs to move to the Lobby set from the Pending set.","title":"State Change"},{"location":"onboarding/backend/workers/#game-removed","text":"This event is a notification from the game server to say a game has been removed from the game server. The worker will try to remove any records of the game that it currently has.","title":"Game Removed"},{"location":"onboarding/backend/workers/#player-disconnect","text":"In this case a non-host disconnected from an active game. Our worker needs to respond by placing the game back in the Lobby set so that they can try join again, or allow someone else to join.","title":"Player Disconnect"},{"location":"onboarding/backend/workers/#working-with-the-workers","text":"From your build_tools directory run: 1 make ps You should see something like: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 Name Command State Ports ----------------------------------------------------------------------------------------------------------------- game-portal /bin/sh -c gunicorn game_p ... Up 0 .0.0.0:8000->8000/tcp game-portal-client docker-entrypoint.sh npm r ... Up 0 .0.0.0:8002->8002/tcp game-rps docker-entrypoint.sh /bin/ ... Up 0 .0.0.0:8080->8080/tcp, 0 .0.0.0:8085->8085/tcp game-rps-client docker-entrypoint.sh /bin/ ... Up 0 .0.0.0:8090->8090/tcp gameportaldb docker-entrypoint.sh mysqld Up 0 .0.0.0:3306->3306/tcp, 33060 /tcp grafana /run.sh Up 0 .0.0.0:3001->3000/tcp matchmaker /bin/sh -c gunicorn --relo ... Up 0 .0.0.0:5050->5050/tcp matchmaker-worker /bin/sh -c python game_wor ... Up 0 .0.0.0:5051->5051/tcp prometheus /bin/prometheus --config.f ... Up 0 .0.0.0:9090->9090/tcp redis-db docker-entrypoint.sh redis ... Up 0 .0.0.0:6379->6379/tcp stats-tracker /bin/sh -c gunicorn --relo ... Up 0 .0.0.0:5000->5000/tcp stats-tracker-worker /bin/sh -c python stats_wo ... Up 0 .0.0.0:5002->5002/tcp The line we're interested in now is: 1 matchmaker-worker /bin/sh -c python game_wor ... Up 0 .0.0.0:5051->5051/tcp This is the container that is running our Matchmaker worker. Note Note that there is a port exposed on this container 0.0.0.0:5051->5051/tcp . This isn't our worker exactly, it is a metrics server that were using to share metrics about the worker so that we can monitor its performance. All the usual commands work for this container: 1 2 3 4 5 make logs a=matchmaker-worker make build a=matchmaker-worker make start a=matchmaker-worker make restart a=matchmaker-worker make stop a=matchmaker-worker","title":"Working with the Workers"},{"location":"onboarding/backend/workers/#tests","text":"You have already run the tests for the workers. Since our worker and server live in the one codebase, everything you did in the last section around running tests, coverage and type checking was also covering the worker code. You've now go enough information about the Matchmaker system to go exploring and hopefully make some sense of it all. There will be may more courses on this stuff available on codeovertime.com , so don't worry if this part is hard to follow. The onboarding course is just meant to get everything up and running with a general understanding of how it all works. Just enough so that you know where to look and what you need to learn.","title":"Tests"},{"location":"onboarding/backend/working_with_matchmaker/","text":"In this section we'll take a high level tour of the Matchmaker could, pointing out key some key areas and concepts. Prerequisites At this point you should have your full Varcade Games stack up and running, but before proceeding let's double check. From your build_tools directory run: 1 make ps You should see something like: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 Name Command State Ports ----------------------------------------------------------------------------------------------------------------- game-portal /bin/sh -c gunicorn game_p ... Up 0 .0.0.0:8000->8000/tcp game-portal-client docker-entrypoint.sh npm r ... Up 0 .0.0.0:8002->8002/tcp game-rps docker-entrypoint.sh /bin/ ... Up 0 .0.0.0:8080->8080/tcp, 0 .0.0.0:8085->8085/tcp game-rps-client docker-entrypoint.sh /bin/ ... Up 0 .0.0.0:8090->8090/tcp gameportaldb docker-entrypoint.sh mysqld Up 0 .0.0.0:3306->3306/tcp, 33060 /tcp grafana /run.sh Up 0 .0.0.0:3001->3000/tcp matchmaker /bin/sh -c gunicorn --relo ... Up 0 .0.0.0:5050->5050/tcp matchmaker-worker /bin/sh -c python game_wor ... Up 0 .0.0.0:5051->5051/tcp prometheus /bin/prometheus --config.f ... Up 0 .0.0.0:9090->9090/tcp redis-db docker-entrypoint.sh redis ... Up 0 .0.0.0:6379->6379/tcp stats-tracker /bin/sh -c gunicorn --relo ... Up 0 .0.0.0:5000->5000/tcp stats-tracker-worker /bin/sh -c python stats_wo ... Up 0 .0.0.0:5002->5002/tcp The line you're interested in is: 1 matchmaker /bin/sh -c gunicorn --relo ... Up 0 .0.0.0:5050->5050/tcp This is our dev build of the game client. Notice at the end of the line: 1 0 .0.0.0:5050 This is telling us that the container is listening on port 5050... so let's try it. In your browser enter 'localhost:5050' in the URL bar and hit enter. If your setup is working you should see an error. But why would you see an error if the setup is working? The error should look like this: 1 2 3 Not Found The requested URL was not found on the server. If you entered the URL manually please check your spelling and try again. This is because when using the Matchmaker you need to interact with it using specific URLs that we have defined in our Application Programming Interface (API). More on this below! Entry point The Matchmaker code is located in varcade_games/matchmaker/matchmaker . The actual entry point to the code is in app.py . This is the code we run to start the server. It creates and initializes a ' Flask app. It is a 'micro framework' that allows us to run a lightweight HTTP server. We will use it to create the endpoints that the Matchmaker UI will send create/join game requests to. This is the Matchmaker API . API The definition of the Matchmaker API can be found in matchmaker/lobby/api.py . There you will find functions with signatures like this: 1 2 3 @game_lobby . route ( \"/<product_id>/create_game\" , methods = [ \"POST\" ]) def create_new_game ( product_id ): ... This is how we register an endpoint with Flask and it is using the concepts of ' Blueprints ' in Flask. The blueprint for our lobby is defined earlier in the api.py file: 1 game_lobby = Blueprint ( \"game_lobby\" , __name__ ) Here we simple create a blueprint called 'game_lobby'. Back in app.py you can see where this blueprint gets registered with Flask: 1 app . register_blueprint ( game_lobby , url_prefix = \"/game_lobby\" ) This is basically our way to telling Flask \"I have a bunch of endpoints I'd like you know know about, they're group conceptually into something I'm calling a lobby\". Once you run the serve you can access your endpoint by visiting the URL of you server and giving the path for your blueprint. So in the above example we register our blueprint with a url_prefix . This means that when ever we access our lobby we will have to use a path like this: 1 http://localhost/game_lobby Now lets jump back to the endpoint mentioned earlier: 1 2 3 @game_lobby . route ( \"/<product_id>/create_game\" , methods = [ \"POST\" ]) def create_new_game ( product_id ): ... Here we use a decorator to add a route to our blueprint. We also give a path for this endpoint. Let's deconstruct this decorator: 1 @game_lobby . route ( \"/<product_id>/create_game\" , methods = [ \"POST\" ]) Basically we are adding a 'route' or and endpoint to our game_lobby blueprint. We are giving that endpoint a path /<product_id>/create_game . The bit inside the <angled brackets> is important here. This endpoint is about creating a game, but what game? Our Matchmaker is generic so we could be trying to create a multi-player game for any game that is registered with the game portal. We've only registered one game so far, Rock Paper Scissors, and we gave it the ID 'exrps'. So if we want to create a game our endpoint now looks like this: 1 http://localhost/game_lobby/exrps/create_game So a request to this URL will connect to the local server, hit the game_lobby blueprint and then get mapped to the <product_id>/create_game route. Once Flask has matched a URL to a route it will extract that product ID and give it as an argument to the function the route is attached to: 1 2 3 @game_lobby . route ( \"/<product_id>/create_game\" , methods = [ \"POST\" ]) def create_new_game ( product_id ): ... So our create_new_game function is passed the 'product_id' that gets extracted from the URL, which is enough information for it to go ahead and create a game. Lobby Endpoints We've defined three endpoints in our Matchmaker API: 1 2 3 4 5 6 7 8 # Create a new multi-player game @game_lobby . route ( \"/<product_id>/create_game\" , methods = [ \"POST\" ]) # Join and existing multi-player game @game_lobby . route ( \"/<product_id>/join_game/<game_id>\" , methods = [ \"POST\" ]) # Fetch all games that are currently open to join @game_lobby . route ( \"/<product_id>/open_games\" , methods = [ \"GET\" ]) These endpoints provide the functionality we discussed in the previous section. All of them require that we specify a product ID so that Matchmaker knows what game it is working with. The create and join are the more interesting endpoints because, as mentioned in the last section, they need to talk to the game server. Game Server API In matchmaker/core/game_server_api.py you will find the the code that allows the Matchmaker to send requests to the game servers. In order for a game to use this Matchmaker for managing games and player connections to those games it must provide a set of endpoints that conform to what is defined here. For example, the first function in this file: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def send_create_game_request ( user_id , user_name , game_id , game_server ): \"\"\"Sends a 'create game' request to the remote game server. :param str user_id: The ID of the user creating the game :param str user_name: The username of the user creating the game :param str game_id: UID of the new game being created :param matchmaker.core.GameServer game_server: the target game server :returns: A dict containing the 'token' for the game that was created :rtype: dict :raises GameServerNetworkError: If the response from the remote game server is not a 200 \"\"\" request_data = { \"gameId\" : game_id , \"userId\" : user_id , \"username\" : user_name } return _send_request ( game_server , \"create_game\" , request_data ) This function with send a 'create_game' request to a game server, just like we saw in the diagrams in the previous section. The Matchmaker expects that any game server that has been registered with it has some endpoint: <game_server_url>/create_game The endpoint should also take a gameId , userId and username as input data. If the game server does not have this endpoint then the Matchmaker will not be able to interact with it. The game server API has four endpoints that are expected to be implemented by game servers: 1 2 3 4 create_game - Create a new game on the remote game server join_game - Join an existing game on the remote server remove_game - Remove a game from the remote server remove_player - Remove a player from a remote game on a remote server If you open up game_rps/server/game_server/app.js you will find all of these endpoints are defined there: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 app . post ( '/create_game' , function ( req , res ) { ... }) app . post ( '/join_game' , function ( req , res ) { ... }) app . post ( '/remove_game' , function ( req , res ) { ... }) app . post ( '/remove_player' , function ( req , res ) { ... }) This is why our Matchmaker is able to create games on the Rock Paper Scissors Apocalypse server. But our Matchmaker doesn't just send requests to game servers in order to organize games, it needs to keep its own records of the games it have created and it needs to curate those records. Time to take a look at the data layer. DAO A DAO or Data Access Object gives us an abstracted interface to manage Matchmaker game data. It is one of the more complex parts of the code and also the most important. With the matchmaker we have to account for a lot data consistency challenges, like what happens if two players try to join the same game at the exact same time? The DAO aims to account for that while also providing a relatively straight forward interface to us in the Matchmaker API. The DAO code is in matchmaker/game_data/dao.py , but before we dig in there let's take a look at it in action. Here is the the code that creates a game using the DAO in our Matchmaker API: 1 2 3 4 5 6 7 8 9 10 11 12 new_game = Game ( uuid . uuid4 () . hex , product_id , game_server . game_server_url , user_profile . user_id , user_profile . username , ** game_server . settings , ) < snip > get_game_dao () . create_game ( new_game ) All we need to do is create a Game object with the required attributes and then called get_game_dao() to get a reference to our DAO and then call the create_game() function on it. This DAO function will take care of adding our game data to our database as well as adding it to the pending set. In fact anyone using the DAO doesn't need to know anything about pending, active or lobby sets. As the user of the DAO you are just creating, joining and fetching lists of games. You don't need to know anything about how that data is managed behind the scenes. I'm not going to say much more about the DAO - there will be a dedicated course for that. For now you can explore yourself and see if you can figure out what is going on. Making Changes Making changes to our backend services is a bit different since it doesn't have some UI you can test directly. In order to test to Matchmaker you need the whole Varcade Games stack running so you can verify that it is talking to game server correctly, listening out for events correctly and that its API is working as expected. A robust set of tests is essential for any server side application, and our Matchmaker is not exception. Running the Tests In your terminal navigate over to the server directory for the website. For example, if your code is located in ~/code/varcade_games then you'd run: 1 cd ~/code/varcade_games/matchmaker Just like the Game Portal tests we ran earlier, our tests use a docker image. We build an image with all of the code and tests, then we run the container and run the tests. This gives us a consistent environment to run our tests in - us and everyone else running these tests will be running with the same dependencies and configurations. If we just ran the tests on our dev machine we could get different results due to different configuration. I've abstracted away most of the complexity of running the tests so all you need to do is run: 1 make build_test_image This may take a while... Next we run the image as follows: 1 make run_test_image_mounted Once it's done you can run the following make commands to run the actual tests: 1 make run_tests You should see a whole lot of output after running that command, and it hopefully ends with something like the following: 1 ======== 97 passed, 44 warnings in 2 .55s ======== (There are a few warnings... but the tests pass!) These tests test the functionality of the matchmaker - they tell us if something functional broke. So let's break something... Open up matchmaker/lobby/api.py . Find the function called get_open_games . This is the API endpoint that returns the list of open games that players can join. Change the following line: 1 2 3 4 5 available_games = get_game_dao () . get_available_games ( product_id , page_index , min ( entry_count , current_app . config [ \"LOBBY_MAX_PAGE_SIZE\" ]), ) to 1 2 3 4 5 available_games = get_game_dao () . get_available_games ( 'test, page_index , min ( entry_count , current_app . config [ \"LOBBY_MAX_PAGE_SIZE\" ]), ) All we're doing here is making it so the endpoint ignores the product ID given to it and simply inserts 'test'. We should expect this to break some stuff since we need a valid product ID in order to fetch any open games for that product. Run the tests again with make run_tests . The out put should have changed: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #<snip> self = <test_api.TestFindGameAPI object at 0x7f4ae7c64f90>, test_client = <FlaskClient <Flask 'app' >> def test_view_available_games_success ( self, test_client ) : response = test_client.get ( f \"game_lobby/{self.test_game.product_id}/open_games\" , headers =[( \"Content-Type\" , \"application/json\" )] , ) # No games create yet assert len ( json.loads ( response.data )) == 0 self.dao.create_game ( self.test_game ) self.dao.publish_game ( self.test_game ) response = test_client.get ( f \"game_lobby/{self.test_game.product_id}/open_games\" , headers =[( \"Content-Type\" , \"application/json\" )] , ) game_list = json.loads ( response.data ) > assert len ( game_list ) == 1 E assert 0 == 1 E +0 E -1 tests/lobby/test_api.py:446: AssertionError #<snip> ========== 2 failed, 95 passed, 42 warnings in 2 .63s =================== In this output we can see that we now have a failing test. It is failing for the exact reason we made it fail. We have a test that tries to fetch a list of open games for a specific game: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def test_view_available_games_success ( self , test_client ): # Send a request to the 'open_games' endpoint response = test_client . get ( f \"game_lobby/ { self . test_game . product_id } /open_games\" , headers = [( \"Content-Type\" , \"application/json\" )], ) # No games create yet assert len ( json . loads ( response . data )) == 0 # Manually create a game self . dao . create_game ( self . test_game ) self . dao . publish_game ( self . test_game ) # Fetch list of available games response = test_client . get ( f \"game_lobby/ { self . test_game . product_id } /open_games\" , headers = [( \"Content-Type\" , \"application/json\" )], ) game_list = json . loads ( response . data ) # Our test fails here assert len ( game_list ) == 1 assert game_list [ 0 ][ \"game_id\" ] == self . test_game . game_id The reason our test is now failing is because it creates a game with a product ID of 'test_game.product_id', BUT our change just overwrites the actual product ID with 'test'. This results in our endpoint returning an empty list since 'test' is not a valid game and therefore can't have any open games. Revert the change and run the tests again to see them passing once again. Coverage Now try running: 1 make run_coverage This tells us how much of our code is covered by tests: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 ----------- coverage: platform linux, python 3 .7.8-final-0 ----------- Name Stmts Miss Cover Missing ----------------------------------------------------------------------------- matchmaker/__init__.py 0 0 100 % matchmaker/app.py 28 2 93 % 25 , 49 matchmaker/config.py 34 4 88 % 53 , 56 -58 matchmaker/core/__init__.py 0 0 100 % matchmaker/core/game_server_api.py 30 0 100 % matchmaker/core/game_servers.py 29 0 100 % matchmaker/game_data/__init__.py 0 0 100 % matchmaker/game_data/dao.py 110 0 100 % matchmaker/game_data/models.py 122 2 98 % 69 , 168 matchmaker/game_worker.py 40 40 0 % 1 -67 matchmaker/lobby/__init__.py 0 0 100 % matchmaker/lobby/api.py 94 0 100 % matchmaker/workers/__init__.py 0 0 100 % matchmaker/workers/event_stream_workers.py 79 4 95 % 89 -93, 103 -107 matchmaker/workers/game_management_workers.py 60 1 98 % 115 matchmaker/workers/worker_manager.py 33 2 94 % 61 -62 ----------------------------------------------------------------------------- TOTAL 659 55 92 % AS I mentioned before, code coverage is a useful indicator about how much test coverage you have but it's important to understand that 100% coverage doesn't mean you have bug free or high quality code. Don't use coverage it as a target, use it as a guide. Type Checking For our Python projects we also have some type checking. Python is a dynamically typed language, meaning we have no compiler to tell us about errors and we often have to wait until we are running the code to know whether it even runs. Enter Mypy. Mypy is a static type checker that will analyze our code and tell us if there is any in there that might be problematic. You can run the type checker against the game portal by running: 1 make run_type_checking Which should result in some output like: 1 2 3 4 5 6 7 8 echo \"Running Mypy against web app\" && \\ mypy --ignore-missing-imports app.py && \\ echo \"Running Mypy against game worker\" && \\ mypy --ignore-missing-imports game_worker.py ' Running Mypy against web app Success: no issues found in 1 source file Running Mypy against game worker Success: no issues found in 1 source file You should run your tests and type checking before you commit any changes to the repository. That's it for the Matchmaker for now. The Matchmaker server at least - you may have noticed that I have yet to mention anything about the event stream events we looked at in the last section. We need to talk about workers...","title":"Working with the Matchmaker"},{"location":"onboarding/backend/working_with_matchmaker/#prerequisites","text":"At this point you should have your full Varcade Games stack up and running, but before proceeding let's double check. From your build_tools directory run: 1 make ps You should see something like: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 Name Command State Ports ----------------------------------------------------------------------------------------------------------------- game-portal /bin/sh -c gunicorn game_p ... Up 0 .0.0.0:8000->8000/tcp game-portal-client docker-entrypoint.sh npm r ... Up 0 .0.0.0:8002->8002/tcp game-rps docker-entrypoint.sh /bin/ ... Up 0 .0.0.0:8080->8080/tcp, 0 .0.0.0:8085->8085/tcp game-rps-client docker-entrypoint.sh /bin/ ... Up 0 .0.0.0:8090->8090/tcp gameportaldb docker-entrypoint.sh mysqld Up 0 .0.0.0:3306->3306/tcp, 33060 /tcp grafana /run.sh Up 0 .0.0.0:3001->3000/tcp matchmaker /bin/sh -c gunicorn --relo ... Up 0 .0.0.0:5050->5050/tcp matchmaker-worker /bin/sh -c python game_wor ... Up 0 .0.0.0:5051->5051/tcp prometheus /bin/prometheus --config.f ... Up 0 .0.0.0:9090->9090/tcp redis-db docker-entrypoint.sh redis ... Up 0 .0.0.0:6379->6379/tcp stats-tracker /bin/sh -c gunicorn --relo ... Up 0 .0.0.0:5000->5000/tcp stats-tracker-worker /bin/sh -c python stats_wo ... Up 0 .0.0.0:5002->5002/tcp The line you're interested in is: 1 matchmaker /bin/sh -c gunicorn --relo ... Up 0 .0.0.0:5050->5050/tcp This is our dev build of the game client. Notice at the end of the line: 1 0 .0.0.0:5050 This is telling us that the container is listening on port 5050... so let's try it. In your browser enter 'localhost:5050' in the URL bar and hit enter. If your setup is working you should see an error. But why would you see an error if the setup is working? The error should look like this: 1 2 3 Not Found The requested URL was not found on the server. If you entered the URL manually please check your spelling and try again. This is because when using the Matchmaker you need to interact with it using specific URLs that we have defined in our Application Programming Interface (API). More on this below!","title":"Prerequisites"},{"location":"onboarding/backend/working_with_matchmaker/#entry-point","text":"The Matchmaker code is located in varcade_games/matchmaker/matchmaker . The actual entry point to the code is in app.py . This is the code we run to start the server. It creates and initializes a ' Flask app. It is a 'micro framework' that allows us to run a lightweight HTTP server. We will use it to create the endpoints that the Matchmaker UI will send create/join game requests to. This is the Matchmaker API .","title":"Entry point"},{"location":"onboarding/backend/working_with_matchmaker/#api","text":"The definition of the Matchmaker API can be found in matchmaker/lobby/api.py . There you will find functions with signatures like this: 1 2 3 @game_lobby . route ( \"/<product_id>/create_game\" , methods = [ \"POST\" ]) def create_new_game ( product_id ): ... This is how we register an endpoint with Flask and it is using the concepts of ' Blueprints ' in Flask. The blueprint for our lobby is defined earlier in the api.py file: 1 game_lobby = Blueprint ( \"game_lobby\" , __name__ ) Here we simple create a blueprint called 'game_lobby'. Back in app.py you can see where this blueprint gets registered with Flask: 1 app . register_blueprint ( game_lobby , url_prefix = \"/game_lobby\" ) This is basically our way to telling Flask \"I have a bunch of endpoints I'd like you know know about, they're group conceptually into something I'm calling a lobby\". Once you run the serve you can access your endpoint by visiting the URL of you server and giving the path for your blueprint. So in the above example we register our blueprint with a url_prefix . This means that when ever we access our lobby we will have to use a path like this: 1 http://localhost/game_lobby Now lets jump back to the endpoint mentioned earlier: 1 2 3 @game_lobby . route ( \"/<product_id>/create_game\" , methods = [ \"POST\" ]) def create_new_game ( product_id ): ... Here we use a decorator to add a route to our blueprint. We also give a path for this endpoint. Let's deconstruct this decorator: 1 @game_lobby . route ( \"/<product_id>/create_game\" , methods = [ \"POST\" ]) Basically we are adding a 'route' or and endpoint to our game_lobby blueprint. We are giving that endpoint a path /<product_id>/create_game . The bit inside the <angled brackets> is important here. This endpoint is about creating a game, but what game? Our Matchmaker is generic so we could be trying to create a multi-player game for any game that is registered with the game portal. We've only registered one game so far, Rock Paper Scissors, and we gave it the ID 'exrps'. So if we want to create a game our endpoint now looks like this: 1 http://localhost/game_lobby/exrps/create_game So a request to this URL will connect to the local server, hit the game_lobby blueprint and then get mapped to the <product_id>/create_game route. Once Flask has matched a URL to a route it will extract that product ID and give it as an argument to the function the route is attached to: 1 2 3 @game_lobby . route ( \"/<product_id>/create_game\" , methods = [ \"POST\" ]) def create_new_game ( product_id ): ... So our create_new_game function is passed the 'product_id' that gets extracted from the URL, which is enough information for it to go ahead and create a game.","title":"API"},{"location":"onboarding/backend/working_with_matchmaker/#lobby-endpoints","text":"We've defined three endpoints in our Matchmaker API: 1 2 3 4 5 6 7 8 # Create a new multi-player game @game_lobby . route ( \"/<product_id>/create_game\" , methods = [ \"POST\" ]) # Join and existing multi-player game @game_lobby . route ( \"/<product_id>/join_game/<game_id>\" , methods = [ \"POST\" ]) # Fetch all games that are currently open to join @game_lobby . route ( \"/<product_id>/open_games\" , methods = [ \"GET\" ]) These endpoints provide the functionality we discussed in the previous section. All of them require that we specify a product ID so that Matchmaker knows what game it is working with. The create and join are the more interesting endpoints because, as mentioned in the last section, they need to talk to the game server.","title":"Lobby Endpoints"},{"location":"onboarding/backend/working_with_matchmaker/#game-server-api","text":"In matchmaker/core/game_server_api.py you will find the the code that allows the Matchmaker to send requests to the game servers. In order for a game to use this Matchmaker for managing games and player connections to those games it must provide a set of endpoints that conform to what is defined here. For example, the first function in this file: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def send_create_game_request ( user_id , user_name , game_id , game_server ): \"\"\"Sends a 'create game' request to the remote game server. :param str user_id: The ID of the user creating the game :param str user_name: The username of the user creating the game :param str game_id: UID of the new game being created :param matchmaker.core.GameServer game_server: the target game server :returns: A dict containing the 'token' for the game that was created :rtype: dict :raises GameServerNetworkError: If the response from the remote game server is not a 200 \"\"\" request_data = { \"gameId\" : game_id , \"userId\" : user_id , \"username\" : user_name } return _send_request ( game_server , \"create_game\" , request_data ) This function with send a 'create_game' request to a game server, just like we saw in the diagrams in the previous section. The Matchmaker expects that any game server that has been registered with it has some endpoint: <game_server_url>/create_game The endpoint should also take a gameId , userId and username as input data. If the game server does not have this endpoint then the Matchmaker will not be able to interact with it. The game server API has four endpoints that are expected to be implemented by game servers: 1 2 3 4 create_game - Create a new game on the remote game server join_game - Join an existing game on the remote server remove_game - Remove a game from the remote server remove_player - Remove a player from a remote game on a remote server If you open up game_rps/server/game_server/app.js you will find all of these endpoints are defined there: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 app . post ( '/create_game' , function ( req , res ) { ... }) app . post ( '/join_game' , function ( req , res ) { ... }) app . post ( '/remove_game' , function ( req , res ) { ... }) app . post ( '/remove_player' , function ( req , res ) { ... }) This is why our Matchmaker is able to create games on the Rock Paper Scissors Apocalypse server. But our Matchmaker doesn't just send requests to game servers in order to organize games, it needs to keep its own records of the games it have created and it needs to curate those records. Time to take a look at the data layer.","title":"Game Server API"},{"location":"onboarding/backend/working_with_matchmaker/#dao","text":"A DAO or Data Access Object gives us an abstracted interface to manage Matchmaker game data. It is one of the more complex parts of the code and also the most important. With the matchmaker we have to account for a lot data consistency challenges, like what happens if two players try to join the same game at the exact same time? The DAO aims to account for that while also providing a relatively straight forward interface to us in the Matchmaker API. The DAO code is in matchmaker/game_data/dao.py , but before we dig in there let's take a look at it in action. Here is the the code that creates a game using the DAO in our Matchmaker API: 1 2 3 4 5 6 7 8 9 10 11 12 new_game = Game ( uuid . uuid4 () . hex , product_id , game_server . game_server_url , user_profile . user_id , user_profile . username , ** game_server . settings , ) < snip > get_game_dao () . create_game ( new_game ) All we need to do is create a Game object with the required attributes and then called get_game_dao() to get a reference to our DAO and then call the create_game() function on it. This DAO function will take care of adding our game data to our database as well as adding it to the pending set. In fact anyone using the DAO doesn't need to know anything about pending, active or lobby sets. As the user of the DAO you are just creating, joining and fetching lists of games. You don't need to know anything about how that data is managed behind the scenes. I'm not going to say much more about the DAO - there will be a dedicated course for that. For now you can explore yourself and see if you can figure out what is going on.","title":"DAO"},{"location":"onboarding/backend/working_with_matchmaker/#making-changes","text":"Making changes to our backend services is a bit different since it doesn't have some UI you can test directly. In order to test to Matchmaker you need the whole Varcade Games stack running so you can verify that it is talking to game server correctly, listening out for events correctly and that its API is working as expected. A robust set of tests is essential for any server side application, and our Matchmaker is not exception.","title":"Making Changes"},{"location":"onboarding/backend/working_with_matchmaker/#running-the-tests","text":"In your terminal navigate over to the server directory for the website. For example, if your code is located in ~/code/varcade_games then you'd run: 1 cd ~/code/varcade_games/matchmaker Just like the Game Portal tests we ran earlier, our tests use a docker image. We build an image with all of the code and tests, then we run the container and run the tests. This gives us a consistent environment to run our tests in - us and everyone else running these tests will be running with the same dependencies and configurations. If we just ran the tests on our dev machine we could get different results due to different configuration. I've abstracted away most of the complexity of running the tests so all you need to do is run: 1 make build_test_image This may take a while... Next we run the image as follows: 1 make run_test_image_mounted Once it's done you can run the following make commands to run the actual tests: 1 make run_tests You should see a whole lot of output after running that command, and it hopefully ends with something like the following: 1 ======== 97 passed, 44 warnings in 2 .55s ======== (There are a few warnings... but the tests pass!) These tests test the functionality of the matchmaker - they tell us if something functional broke. So let's break something... Open up matchmaker/lobby/api.py . Find the function called get_open_games . This is the API endpoint that returns the list of open games that players can join. Change the following line: 1 2 3 4 5 available_games = get_game_dao () . get_available_games ( product_id , page_index , min ( entry_count , current_app . config [ \"LOBBY_MAX_PAGE_SIZE\" ]), ) to 1 2 3 4 5 available_games = get_game_dao () . get_available_games ( 'test, page_index , min ( entry_count , current_app . config [ \"LOBBY_MAX_PAGE_SIZE\" ]), ) All we're doing here is making it so the endpoint ignores the product ID given to it and simply inserts 'test'. We should expect this to break some stuff since we need a valid product ID in order to fetch any open games for that product. Run the tests again with make run_tests . The out put should have changed: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #<snip> self = <test_api.TestFindGameAPI object at 0x7f4ae7c64f90>, test_client = <FlaskClient <Flask 'app' >> def test_view_available_games_success ( self, test_client ) : response = test_client.get ( f \"game_lobby/{self.test_game.product_id}/open_games\" , headers =[( \"Content-Type\" , \"application/json\" )] , ) # No games create yet assert len ( json.loads ( response.data )) == 0 self.dao.create_game ( self.test_game ) self.dao.publish_game ( self.test_game ) response = test_client.get ( f \"game_lobby/{self.test_game.product_id}/open_games\" , headers =[( \"Content-Type\" , \"application/json\" )] , ) game_list = json.loads ( response.data ) > assert len ( game_list ) == 1 E assert 0 == 1 E +0 E -1 tests/lobby/test_api.py:446: AssertionError #<snip> ========== 2 failed, 95 passed, 42 warnings in 2 .63s =================== In this output we can see that we now have a failing test. It is failing for the exact reason we made it fail. We have a test that tries to fetch a list of open games for a specific game: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def test_view_available_games_success ( self , test_client ): # Send a request to the 'open_games' endpoint response = test_client . get ( f \"game_lobby/ { self . test_game . product_id } /open_games\" , headers = [( \"Content-Type\" , \"application/json\" )], ) # No games create yet assert len ( json . loads ( response . data )) == 0 # Manually create a game self . dao . create_game ( self . test_game ) self . dao . publish_game ( self . test_game ) # Fetch list of available games response = test_client . get ( f \"game_lobby/ { self . test_game . product_id } /open_games\" , headers = [( \"Content-Type\" , \"application/json\" )], ) game_list = json . loads ( response . data ) # Our test fails here assert len ( game_list ) == 1 assert game_list [ 0 ][ \"game_id\" ] == self . test_game . game_id The reason our test is now failing is because it creates a game with a product ID of 'test_game.product_id', BUT our change just overwrites the actual product ID with 'test'. This results in our endpoint returning an empty list since 'test' is not a valid game and therefore can't have any open games. Revert the change and run the tests again to see them passing once again.","title":"Running the Tests"},{"location":"onboarding/backend/working_with_matchmaker/#coverage","text":"Now try running: 1 make run_coverage This tells us how much of our code is covered by tests: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 ----------- coverage: platform linux, python 3 .7.8-final-0 ----------- Name Stmts Miss Cover Missing ----------------------------------------------------------------------------- matchmaker/__init__.py 0 0 100 % matchmaker/app.py 28 2 93 % 25 , 49 matchmaker/config.py 34 4 88 % 53 , 56 -58 matchmaker/core/__init__.py 0 0 100 % matchmaker/core/game_server_api.py 30 0 100 % matchmaker/core/game_servers.py 29 0 100 % matchmaker/game_data/__init__.py 0 0 100 % matchmaker/game_data/dao.py 110 0 100 % matchmaker/game_data/models.py 122 2 98 % 69 , 168 matchmaker/game_worker.py 40 40 0 % 1 -67 matchmaker/lobby/__init__.py 0 0 100 % matchmaker/lobby/api.py 94 0 100 % matchmaker/workers/__init__.py 0 0 100 % matchmaker/workers/event_stream_workers.py 79 4 95 % 89 -93, 103 -107 matchmaker/workers/game_management_workers.py 60 1 98 % 115 matchmaker/workers/worker_manager.py 33 2 94 % 61 -62 ----------------------------------------------------------------------------- TOTAL 659 55 92 % AS I mentioned before, code coverage is a useful indicator about how much test coverage you have but it's important to understand that 100% coverage doesn't mean you have bug free or high quality code. Don't use coverage it as a target, use it as a guide.","title":"Coverage"},{"location":"onboarding/backend/working_with_matchmaker/#type-checking","text":"For our Python projects we also have some type checking. Python is a dynamically typed language, meaning we have no compiler to tell us about errors and we often have to wait until we are running the code to know whether it even runs. Enter Mypy. Mypy is a static type checker that will analyze our code and tell us if there is any in there that might be problematic. You can run the type checker against the game portal by running: 1 make run_type_checking Which should result in some output like: 1 2 3 4 5 6 7 8 echo \"Running Mypy against web app\" && \\ mypy --ignore-missing-imports app.py && \\ echo \"Running Mypy against game worker\" && \\ mypy --ignore-missing-imports game_worker.py ' Running Mypy against web app Success: no issues found in 1 source file Running Mypy against game worker Success: no issues found in 1 source file You should run your tests and type checking before you commit any changes to the repository. That's it for the Matchmaker for now. The Matchmaker server at least - you may have noticed that I have yet to mention anything about the event stream events we looked at in the last section. We need to talk about workers...","title":"Type Checking"},{"location":"onboarding/instrumentation/grafana/","text":"When you run make ps from your build_tools directory, there are two entries that we have yet to look at: 1 2 grafana /run.sh Up 0 .0.0.0:3001->3000/tcp prometheus /bin/prometheus --config.f ... Up 0 .0.0.0:9090->9090/tcp Notice that both are exposing port numbers. Grafana on 3000 and Promehteus on 9090 . Why not try pointing your browser at localhost:9090 and localhost:3000 to see what's there? Prometheus On 9090 you will see a basic interface with some text fields and buttons. We're actually going to completely ignore this interface - but it's good that it's there, it means Prometheus is up and running. Grafana When you connect to localhost:3030 you should be greeted by a screen that looks something like this (you will be running whatever the latest version is so the UI might change): You can log in with username admin and password password . This password is set in build_tools/grafana/config.monitoring . Once we can log in we need to tell Grafana where is can find Prometheus so that it can pull metrics from there and make them look pretty. So we need to add a data source. On the left hand side of the Grafana interface there is a cog icon: Click this icon to access the configuration options. Under the Data Sources heading select Add Data Source and select Prometheus from the list of options: Next you will have the option to specify some options. There are three that we care about: URL Access HTTP Method URL The URL should be set to http://localhost:9090 . Notice that this is the port number you connected your browser to earlier. It's our Prometheus server. Access Access should be set to Browser . HTTP Method HTTP Method should be set to Get Your options should look something like this: Hit the Save and Test button. It should turn green if everything went as expected. If not double check your settings. Adding a Dashboard Now that we've established a connection to Prometheus we need to start gathering some metrics and displaying them somewhere. I have created a dashboard that you can use to get started. First of all open up the Dashboards menu option and select Manage : Which should display a screen that looks like this: On the right hand side of the screen is an Import button. Click this button and then select the Upload JSoN file option that is presented. The file you need to upload is in build_tools/grafana and is called vcg_grafana_dashboard.json . Once that's done you should be presented with a screen that looks something like this: This view is showing you the last 15 minutes worth of activity on your system, so if you haven't been using it then nothing will show up here. Try opening up your local Varcade games at localhost:8002 and clicking around for a while. Refresh the game list page a few times, log in, log out, player a multi-player game etc... Once you do that you will see more activity: Have a read through some of the metrics. We're mostly interested in tracking things like: All Servers Request latency (how long each request takes to process) Volume of requests Error responses Game Server Number of active games Number of active connections (should be at least 1 per game) Workers Number of events processed Have a play around on the website and see what impact it has on the metrics. Once you've done that you will notice that a lot of the numbers are very low. It's just difficult to generate the amount of load a busy website might experience by yourself. Next we'll look at load testing.","title":"Setting up Grafana"},{"location":"onboarding/instrumentation/grafana/#prometheus","text":"On 9090 you will see a basic interface with some text fields and buttons. We're actually going to completely ignore this interface - but it's good that it's there, it means Prometheus is up and running.","title":"Prometheus"},{"location":"onboarding/instrumentation/grafana/#grafana","text":"When you connect to localhost:3030 you should be greeted by a screen that looks something like this (you will be running whatever the latest version is so the UI might change): You can log in with username admin and password password . This password is set in build_tools/grafana/config.monitoring . Once we can log in we need to tell Grafana where is can find Prometheus so that it can pull metrics from there and make them look pretty. So we need to add a data source. On the left hand side of the Grafana interface there is a cog icon: Click this icon to access the configuration options. Under the Data Sources heading select Add Data Source and select Prometheus from the list of options: Next you will have the option to specify some options. There are three that we care about: URL Access HTTP Method","title":"Grafana"},{"location":"onboarding/instrumentation/grafana/#url","text":"The URL should be set to http://localhost:9090 . Notice that this is the port number you connected your browser to earlier. It's our Prometheus server.","title":"URL"},{"location":"onboarding/instrumentation/grafana/#access","text":"Access should be set to Browser .","title":"Access"},{"location":"onboarding/instrumentation/grafana/#http-method","text":"HTTP Method should be set to Get Your options should look something like this: Hit the Save and Test button. It should turn green if everything went as expected. If not double check your settings.","title":"HTTP Method"},{"location":"onboarding/instrumentation/grafana/#adding-a-dashboard","text":"Now that we've established a connection to Prometheus we need to start gathering some metrics and displaying them somewhere. I have created a dashboard that you can use to get started. First of all open up the Dashboards menu option and select Manage : Which should display a screen that looks like this: On the right hand side of the screen is an Import button. Click this button and then select the Upload JSoN file option that is presented. The file you need to upload is in build_tools/grafana and is called vcg_grafana_dashboard.json . Once that's done you should be presented with a screen that looks something like this: This view is showing you the last 15 minutes worth of activity on your system, so if you haven't been using it then nothing will show up here. Try opening up your local Varcade games at localhost:8002 and clicking around for a while. Refresh the game list page a few times, log in, log out, player a multi-player game etc... Once you do that you will see more activity: Have a read through some of the metrics. We're mostly interested in tracking things like: All Servers Request latency (how long each request takes to process) Volume of requests Error responses Game Server Number of active games Number of active connections (should be at least 1 per game) Workers Number of events processed Have a play around on the website and see what impact it has on the metrics. Once you've done that you will notice that a lot of the numbers are very low. It's just difficult to generate the amount of load a busy website might experience by yourself. Next we'll look at load testing.","title":"Adding a Dashboard"},{"location":"onboarding/instrumentation/intro/","text":"There is one final thing we need to cover before you are ready to work on Varcade Games. Instrumentation. Instrumentation is a collective term for measuring instruments that are used for indicating, measuring and recording physical quantities. When running a live product you're going to want to be sure that your live product is in fact live. Servers can crash, or worse - have bugs that start corrupting all of your data. They will also behave very differently with one user than 1,000 concurrent users. You don't want to have to sit around all day and night manually monitoring your servers to make sure they are operating as expected. We need to put in place some automated monitoring systems so that we can forget about our servers until something goes wrong. Prometheus & Grafana We will be using two open source products in order to monitor and alert on our backend services. Straight from the Grafana docs: Grafana is a complete observability stack that allows you to monitor and analyze mertrics, logs and traces. It allows you to query, visualize, alert on and understand your data no matter where it is stored. Prometheus is an open source systems monitoring system for which Grafana provides out-of-the-box support. This topic walks you through the steps to create a series of dashboards in Grafana to display system metrics for a server monitored by Prometheus. In light of the above, what we will do is use Prometheus to monitor our servers. It will gather a bunch of interesting metrics about our running servers, like how long does a request take or how many requests are we getting. We will then use Grafana to display that data in a nice dashboard that we can use to monitor system performance and stability. As always, I recommend you check out the official docs for both Prometheus and Grafana to get a sense of what they're about. k6 Another thing we will need to do is generate traffic for our system. It's all well and good testing our backend manually by ourselves, but a single person using and distributed system is a very different thing to 1,000 people using that system. We will use k6 to generate load and then monitor our system using Grafana to help understand if our system has any bottlenecks, how well it performs under load and when it breaks. We've got a bit of setup to do first, so lets get started.","title":"Introduction"},{"location":"onboarding/instrumentation/intro/#prometheus-grafana","text":"We will be using two open source products in order to monitor and alert on our backend services. Straight from the Grafana docs: Grafana is a complete observability stack that allows you to monitor and analyze mertrics, logs and traces. It allows you to query, visualize, alert on and understand your data no matter where it is stored. Prometheus is an open source systems monitoring system for which Grafana provides out-of-the-box support. This topic walks you through the steps to create a series of dashboards in Grafana to display system metrics for a server monitored by Prometheus. In light of the above, what we will do is use Prometheus to monitor our servers. It will gather a bunch of interesting metrics about our running servers, like how long does a request take or how many requests are we getting. We will then use Grafana to display that data in a nice dashboard that we can use to monitor system performance and stability. As always, I recommend you check out the official docs for both Prometheus and Grafana to get a sense of what they're about.","title":"Prometheus &amp; Grafana"},{"location":"onboarding/instrumentation/intro/#k6","text":"Another thing we will need to do is generate traffic for our system. It's all well and good testing our backend manually by ourselves, but a single person using and distributed system is a very different thing to 1,000 people using that system. We will use k6 to generate load and then monitor our system using Grafana to help understand if our system has any bottlenecks, how well it performs under load and when it breaks. We've got a bit of setup to do first, so lets get started.","title":"k6"},{"location":"onboarding/instrumentation/load_test/","text":"In order to generate some traffic on our distributed system we're going to use a tool called k6 , which is an: Open source load testing tool and SaaS for engineering teams It's a tool written in GoLang that allows us to write Javascript in order great load tests. Installing k6 To get set up with k6 you should follow the official documentation for your system. Important If you are using Windows you need to follow the Linux instructions using your Linux shell, since you will be running the load test from within your Linux environment. Running the test In order to run the load test navigate to the build_tools/load_generator directory on your command line. In that directory is a Javascript file that contains a script that will spawn 500 virtual users. Those users will each register a new account and run the various requests a browser would run to load the website. It will also create new Rock Paper Scissors Apocalypse multi-player games and play the game. To run the script enter the following command: 1 k6 run site_navigation.js If you get an error you should verify that your installation of k6 and its dependencies were all successful. If everything works you should see some output like this flash by on the screen: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 / \\ | \u203e\u203e | /\u203e\u203e/ /\u203e\u203e/ / \\ / \\ | | / / / / / \\/ \\ | ( / \u203e\u203e \\ / \\ | | \\ \\ | ( \u203e ) | / __________ \\ | __ | \\_ _ \\ \\_ ____/ .io execution: local script: site_navigation.js output: - scenarios: ( 100 .00% ) 1 scenario, 500 max VUs, 15m30s max duration ( incl. graceful stop ) : * default: 500 looping VUs for 15m0s ( gracefulStop: 30s ) INFO [ 0000 ] Fetching VCG client, identifier: 1272 source = console INFO [ 0000 ] Fetching VCG client, identifier: 1957 source = console INFO [ 0000 ] Fetching VCG client, identifier: 8352 source = console INFO [ 0000 ] Fetching VCG client, identifier: 4549 source = console INFO [ 0000 ] Fetching VCG client, identifier: 4845 source = console INFO [ 0000 ] Fetching VCG client, identifier: 2130 source = console INFO [ 0000 ] Fetching VCG client, identifier: 4910 source = console INFO [ 0000 ] Fetching VCG client, identifier: 7115 source = console There are a couple of things worth noting here. k6 tells us that it is running 500 VUs , which means 500 Virtual Users . It also says 15m30s max duration , telling us that this test will run for 15 minutes. That means our users will be load the website, creating games and playing games for 15 minutes straight. This gives us an understand of how the whole system will handle load over a specific period of time. If you want the end the text early you can just hit ctrl+c . Once the test has finished a summary will be displayed: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 running ( 00m02.8s ) , 000 /500 VUs, 0 complete and 500 interrupted iterations default \u2717 [ -------------------------------------- ] 500 VUs 00m02.8s/15m0s WARN [ 0003 ] No script iterations finished, consider making the test duration longer \u2588 landing and registration \u2717 statusCode \u21b3 99 % \u2014 \u2713 512 / \u2717 1 \u2588 homepage \u2713 statusCode checks.........................: 99 .80% \u2713 512 \u2717 1 data_received..................: 393 kB 138 kB/s data_sent......................: 160 kB 56 kB/s group_duration.................: avg = 1 .98s min = 1 .21s med = 2 .03s max = 2 .72s p ( 90 )= 2 .56s p ( 95 )= 2 .64s http_req_blocked...............: avg = 8 .57ms min = 57 .68\u00b5s med = 2 .72ms max = 35 .66ms p ( 90 )= 31 .5ms p ( 95 )= 33 .75ms http_req_connecting............: avg = 8 .35ms min = 39 .69\u00b5s med = 2 .62ms max = 35 .63ms p ( 90 )= 31 .45ms p ( 95 )= 33 .57ms http_req_duration..............: avg = 175 .8ms min = 33 .35ms med = 165 .71ms max = 1 .62s p ( 90 )= 217 .07ms p ( 95 )= 224 .57ms { expected_response:true } ...: avg = 174 .06ms min = 33 .35ms med = 165 .57ms max = 1 .62s p ( 90 )= 217 .05ms p ( 95 )= 224 .44ms http_req_failed................: 0 .19% \u2713 1 \u2717 512 http_req_receiving.............: avg = 33 .86\u00b5s min = 15 .58\u00b5s med = 29 .85\u00b5s max = 119 .25\u00b5s p ( 90 )= 52 .29\u00b5s p ( 95 )= 60 .46\u00b5s http_req_sending...............: avg = 1 .24ms min = 17 .03\u00b5s med = 213 .58\u00b5s max = 48 .79ms p ( 90 )= 2 .12ms p ( 95 )= 9 .78ms http_req_tls_handshaking.......: avg = 0s min = 0s med = 0s max = 0s p ( 90 )= 0s p ( 95 )= 0s http_req_waiting...............: avg = 174 .52ms min = 26 .01ms med = 164 .44ms max = 1 .62s p ( 90 )= 217 .02ms p ( 95 )= 224 .51ms http_reqs......................: 513 180 .657393/s vus............................: 500 min = 500 max = 500 vus_max........................: 500 min = 500 max = 500 Configuration We can configure this tests by making some changes to build_tools/load_generator/site_navigation.js : 1 2 3 4 5 6 7 8 9 10 import http from 'k6/http' ; import ws from 'k6/ws' ; import { sleep , group , check } from 'k6' ; export let options = { vus : 500 , duration : '15m' }; At the top of the file we can set the number of Virtual Users (vus) and the duration. If your machine is struggling to run the test with 500 users you can try lowering the value to 50 and going from there. The Metrics If you head back to your Grafana dashboard you won't see anything exciting just yet. The system needs a few seconds to update. Our Prometheus server will get updates from the services at regular updates, so we will see updated values every 15 seconds or so. Once the test has been running for a few minutes the dashboard should explode into life. Now when you make changes to Varcade Games you can test them under load!","title":"Running a load test"},{"location":"onboarding/instrumentation/load_test/#installing-k6","text":"To get set up with k6 you should follow the official documentation for your system. Important If you are using Windows you need to follow the Linux instructions using your Linux shell, since you will be running the load test from within your Linux environment.","title":"Installing k6"},{"location":"onboarding/instrumentation/load_test/#running-the-test","text":"In order to run the load test navigate to the build_tools/load_generator directory on your command line. In that directory is a Javascript file that contains a script that will spawn 500 virtual users. Those users will each register a new account and run the various requests a browser would run to load the website. It will also create new Rock Paper Scissors Apocalypse multi-player games and play the game. To run the script enter the following command: 1 k6 run site_navigation.js If you get an error you should verify that your installation of k6 and its dependencies were all successful. If everything works you should see some output like this flash by on the screen: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 / \\ | \u203e\u203e | /\u203e\u203e/ /\u203e\u203e/ / \\ / \\ | | / / / / / \\/ \\ | ( / \u203e\u203e \\ / \\ | | \\ \\ | ( \u203e ) | / __________ \\ | __ | \\_ _ \\ \\_ ____/ .io execution: local script: site_navigation.js output: - scenarios: ( 100 .00% ) 1 scenario, 500 max VUs, 15m30s max duration ( incl. graceful stop ) : * default: 500 looping VUs for 15m0s ( gracefulStop: 30s ) INFO [ 0000 ] Fetching VCG client, identifier: 1272 source = console INFO [ 0000 ] Fetching VCG client, identifier: 1957 source = console INFO [ 0000 ] Fetching VCG client, identifier: 8352 source = console INFO [ 0000 ] Fetching VCG client, identifier: 4549 source = console INFO [ 0000 ] Fetching VCG client, identifier: 4845 source = console INFO [ 0000 ] Fetching VCG client, identifier: 2130 source = console INFO [ 0000 ] Fetching VCG client, identifier: 4910 source = console INFO [ 0000 ] Fetching VCG client, identifier: 7115 source = console There are a couple of things worth noting here. k6 tells us that it is running 500 VUs , which means 500 Virtual Users . It also says 15m30s max duration , telling us that this test will run for 15 minutes. That means our users will be load the website, creating games and playing games for 15 minutes straight. This gives us an understand of how the whole system will handle load over a specific period of time. If you want the end the text early you can just hit ctrl+c . Once the test has finished a summary will be displayed: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 running ( 00m02.8s ) , 000 /500 VUs, 0 complete and 500 interrupted iterations default \u2717 [ -------------------------------------- ] 500 VUs 00m02.8s/15m0s WARN [ 0003 ] No script iterations finished, consider making the test duration longer \u2588 landing and registration \u2717 statusCode \u21b3 99 % \u2014 \u2713 512 / \u2717 1 \u2588 homepage \u2713 statusCode checks.........................: 99 .80% \u2713 512 \u2717 1 data_received..................: 393 kB 138 kB/s data_sent......................: 160 kB 56 kB/s group_duration.................: avg = 1 .98s min = 1 .21s med = 2 .03s max = 2 .72s p ( 90 )= 2 .56s p ( 95 )= 2 .64s http_req_blocked...............: avg = 8 .57ms min = 57 .68\u00b5s med = 2 .72ms max = 35 .66ms p ( 90 )= 31 .5ms p ( 95 )= 33 .75ms http_req_connecting............: avg = 8 .35ms min = 39 .69\u00b5s med = 2 .62ms max = 35 .63ms p ( 90 )= 31 .45ms p ( 95 )= 33 .57ms http_req_duration..............: avg = 175 .8ms min = 33 .35ms med = 165 .71ms max = 1 .62s p ( 90 )= 217 .07ms p ( 95 )= 224 .57ms { expected_response:true } ...: avg = 174 .06ms min = 33 .35ms med = 165 .57ms max = 1 .62s p ( 90 )= 217 .05ms p ( 95 )= 224 .44ms http_req_failed................: 0 .19% \u2713 1 \u2717 512 http_req_receiving.............: avg = 33 .86\u00b5s min = 15 .58\u00b5s med = 29 .85\u00b5s max = 119 .25\u00b5s p ( 90 )= 52 .29\u00b5s p ( 95 )= 60 .46\u00b5s http_req_sending...............: avg = 1 .24ms min = 17 .03\u00b5s med = 213 .58\u00b5s max = 48 .79ms p ( 90 )= 2 .12ms p ( 95 )= 9 .78ms http_req_tls_handshaking.......: avg = 0s min = 0s med = 0s max = 0s p ( 90 )= 0s p ( 95 )= 0s http_req_waiting...............: avg = 174 .52ms min = 26 .01ms med = 164 .44ms max = 1 .62s p ( 90 )= 217 .02ms p ( 95 )= 224 .51ms http_reqs......................: 513 180 .657393/s vus............................: 500 min = 500 max = 500 vus_max........................: 500 min = 500 max = 500","title":"Running the test"},{"location":"onboarding/instrumentation/load_test/#configuration","text":"We can configure this tests by making some changes to build_tools/load_generator/site_navigation.js : 1 2 3 4 5 6 7 8 9 10 import http from 'k6/http' ; import ws from 'k6/ws' ; import { sleep , group , check } from 'k6' ; export let options = { vus : 500 , duration : '15m' }; At the top of the file we can set the number of Virtual Users (vus) and the duration. If your machine is struggling to run the test with 500 users you can try lowering the value to 50 and going from there.","title":"Configuration"},{"location":"onboarding/instrumentation/load_test/#the-metrics","text":"If you head back to your Grafana dashboard you won't see anything exciting just yet. The system needs a few seconds to update. Our Prometheus server will get updates from the services at regular updates, so we will see updated values every 15 seconds or so. Once the test has been running for a few minutes the dashboard should explode into life. Now when you make changes to Varcade Games you can test them under load!","title":"The Metrics"},{"location":"onboarding/rps_game/game_design/","text":"I want to talk briefly about some of the game design decisions behind Rock Paper Scissors Apocalypse. It's a very simple take on Rock Paper Scissors so it shouldn't need that much explanation. Gameplay For this game I wanted to capture the feeling of playing an old arcade style fighting game. There's a single player mode where you face a gauntlet of AI opponents and a multi player mode where you face other humans. The flow of the single player mode is fairly standard: 1 Character select -> VS Screen -> Fight Screen -> Next opponent or Game Over These fighting games often have a thin story line explaining why its diverse array of characters decided to get together and fight. Rock Paper Scissors is so ridiculously simple that I wanted to put a really over the top story behind it, hence the 'Apocalypse' part of the game. The characters are trying to save the world by playing this game. When you select single player mode you are greeted by this storyline, after which you get to select the character you want to save humanity with. Player Stats Once you're at the character select screen you have a decision to make - what character do you want to play as? I wanted to add a element to strategy and tactics to the game, so each character has some strengths and weaknesses. The way this works is as follows: All characters have the same health, in battle the player that loses all of their health loses the current round of the battle There is a base level of damage that all players do If a player's weapon selection defeats their opponent, then their attack bonus for that weapon is added to the damage done If a player's weapon selection loses to their opponent then their defense bonus reduces the damage received So, for example, in the screen shot above our character has +40% to their scissors damage. With a base damage of 20, their scissor damage becomes 28. This character also has -10% against paper. This means that when they select rock and their opponent selects paper they will mitigate some of the damage. That 20 base damage done by the opponent becomes 18. So in terms of strategy, if you are facing this character you want to be careful when selecting paper - because their scissors will do a lot of damage to you. The way I tried to balance this was to give every character a value of 50% to use on their attack and defense stats. The character above put most of that value into scissors so that they have one devastating attack. Other characters spread the 50% out more evenly so that they are generally stronger (eg. +10% to scissors and paper attack, -10% defense against everything). The equation for calculating damage looks like this: 1 baseDamage * (1 + attack - enemy defense) All of this data is available in the game_data.js file of the game engine. The calculation itself appears in the game_models.js file in the Weapon class. Botch If a player makes no selection then the 'botch' hand is automatically selected. This selection does no damage and loses against all weapons. If both players fail to make a selection (can happen in multi player) then both will receive damage when 'botch' is used. This is so that the game will end by attrition rather than continue forever. Difficulty Progression Once a character is selected in single player mode, the player will face a series of battles with the other characters in the roster. As the player progresses their opponent will get more and more difficult. Here's how it works. AI opponents will simply select a pattern of weapon selections. So the AI will have a predefined set of choices that it will make. For example, the easiest character will take a list of selections: 1 [rock, paper, scissors] And then shuffle that list, which might end up looking like this: 1 [paper, scissors, rock] That AI opponent will then simply select paper, then scissors, then rock over and over again. The player simply needs to figure out the pattern and they will easily defeat their opponent. To make this more difficult we simply add selections to the list. So the second AI character the player faces will start will a list: 1 [rock, paper, scissors] Then a random weapon and add it to the list, eg: 1 [rock, paper, scissors, paper] Then is will shuffle that list: 1 [paper, scissors, rock, paper] And that's it. Now the player has a longer pattern that is more difficult to figure out and remember. At this point, however, we also introduce some more variance. The AI opponents will change up their pattern once they've received enough damage. So, for example, an AI opponent may have the following list: 1 [paper, paper, scissors, rock] BUT when their health drops below 30% they reshuffle the list to try and throw the player off, so the pattern changes to: 1 [paper, scissors, paper, rock] Following this format we can add new opponents and simply extend their pattern by one each time and adjust the point at which they reshuffle in response to damage received. Character Unlocks At the time of writing the game has four main characters. Two and unlocked and two are locked. In single player mode you unlock the additional characters by beating all of the standard characters in single player with the two default characters. For example, Aruka faces off against the following characters in single player: Manbo (unlocked) Raden (locked) Hogo Sha (locked) Aruka's final character is Hogo Sha, and if he wins he will unlock Hogo. Similary Manbo, who starts unlocked, will unlock Raden once she defeats here. This leaves one final character that is locked - the boss. Beating the game The final bit of game design worth talking about is the final boss. Players don't get to face the final boss just by defeating all of their opponents... I wanted to make the game a little more difficult than that. They need to beat all of their opponents without losing a single round . If they lose a round they will get a game over screen and a character unlock message. If they win every round they play - then they get to face Mainyu... the final boss. Mainyu doesn't use a strategy like the other characters. It's selections are completely random, which makes it really difficult to play against (random selections are the most difficult in Rock Paper Scissors. Humans think they can be random, but often fall into patterns - so it is possible to be good or bad and this game, which most put down to chance). Once Mainyu is defeated, it will be unlocked. Good luck! That's about it for game design for now. Hopefully this has highlighted just how complex even a seemingly trivial game like Rock Paper Scissors can be. Some of the strategy games I've worked on in the past have had tens of thousands of rows in spreadsheets filled with data about character stats, economy management, buffs etc... If you plan on making a game my recommendation would be to pick a simple but solid (and fun!) core gameplay mechanic and focus on getting it right. Keep it simple, then when it works add complexity around it. Complexity is easy to add - fun isn't. Focus on the fun. Speaking of fun, what's more fun than playing with and against other people? Let's move on to the game server.","title":"Game Design"},{"location":"onboarding/rps_game/game_design/#gameplay","text":"For this game I wanted to capture the feeling of playing an old arcade style fighting game. There's a single player mode where you face a gauntlet of AI opponents and a multi player mode where you face other humans. The flow of the single player mode is fairly standard: 1 Character select -> VS Screen -> Fight Screen -> Next opponent or Game Over These fighting games often have a thin story line explaining why its diverse array of characters decided to get together and fight. Rock Paper Scissors is so ridiculously simple that I wanted to put a really over the top story behind it, hence the 'Apocalypse' part of the game. The characters are trying to save the world by playing this game. When you select single player mode you are greeted by this storyline, after which you get to select the character you want to save humanity with.","title":"Gameplay"},{"location":"onboarding/rps_game/game_design/#player-stats","text":"Once you're at the character select screen you have a decision to make - what character do you want to play as? I wanted to add a element to strategy and tactics to the game, so each character has some strengths and weaknesses. The way this works is as follows: All characters have the same health, in battle the player that loses all of their health loses the current round of the battle There is a base level of damage that all players do If a player's weapon selection defeats their opponent, then their attack bonus for that weapon is added to the damage done If a player's weapon selection loses to their opponent then their defense bonus reduces the damage received So, for example, in the screen shot above our character has +40% to their scissors damage. With a base damage of 20, their scissor damage becomes 28. This character also has -10% against paper. This means that when they select rock and their opponent selects paper they will mitigate some of the damage. That 20 base damage done by the opponent becomes 18. So in terms of strategy, if you are facing this character you want to be careful when selecting paper - because their scissors will do a lot of damage to you. The way I tried to balance this was to give every character a value of 50% to use on their attack and defense stats. The character above put most of that value into scissors so that they have one devastating attack. Other characters spread the 50% out more evenly so that they are generally stronger (eg. +10% to scissors and paper attack, -10% defense against everything). The equation for calculating damage looks like this: 1 baseDamage * (1 + attack - enemy defense) All of this data is available in the game_data.js file of the game engine. The calculation itself appears in the game_models.js file in the Weapon class.","title":"Player Stats"},{"location":"onboarding/rps_game/game_design/#botch","text":"If a player makes no selection then the 'botch' hand is automatically selected. This selection does no damage and loses against all weapons. If both players fail to make a selection (can happen in multi player) then both will receive damage when 'botch' is used. This is so that the game will end by attrition rather than continue forever.","title":"Botch"},{"location":"onboarding/rps_game/game_design/#difficulty-progression","text":"Once a character is selected in single player mode, the player will face a series of battles with the other characters in the roster. As the player progresses their opponent will get more and more difficult. Here's how it works. AI opponents will simply select a pattern of weapon selections. So the AI will have a predefined set of choices that it will make. For example, the easiest character will take a list of selections: 1 [rock, paper, scissors] And then shuffle that list, which might end up looking like this: 1 [paper, scissors, rock] That AI opponent will then simply select paper, then scissors, then rock over and over again. The player simply needs to figure out the pattern and they will easily defeat their opponent. To make this more difficult we simply add selections to the list. So the second AI character the player faces will start will a list: 1 [rock, paper, scissors] Then a random weapon and add it to the list, eg: 1 [rock, paper, scissors, paper] Then is will shuffle that list: 1 [paper, scissors, rock, paper] And that's it. Now the player has a longer pattern that is more difficult to figure out and remember. At this point, however, we also introduce some more variance. The AI opponents will change up their pattern once they've received enough damage. So, for example, an AI opponent may have the following list: 1 [paper, paper, scissors, rock] BUT when their health drops below 30% they reshuffle the list to try and throw the player off, so the pattern changes to: 1 [paper, scissors, paper, rock] Following this format we can add new opponents and simply extend their pattern by one each time and adjust the point at which they reshuffle in response to damage received.","title":"Difficulty Progression"},{"location":"onboarding/rps_game/game_design/#character-unlocks","text":"At the time of writing the game has four main characters. Two and unlocked and two are locked. In single player mode you unlock the additional characters by beating all of the standard characters in single player with the two default characters. For example, Aruka faces off against the following characters in single player: Manbo (unlocked) Raden (locked) Hogo Sha (locked) Aruka's final character is Hogo Sha, and if he wins he will unlock Hogo. Similary Manbo, who starts unlocked, will unlock Raden once she defeats here. This leaves one final character that is locked - the boss.","title":"Character Unlocks"},{"location":"onboarding/rps_game/game_design/#beating-the-game","text":"The final bit of game design worth talking about is the final boss. Players don't get to face the final boss just by defeating all of their opponents... I wanted to make the game a little more difficult than that. They need to beat all of their opponents without losing a single round . If they lose a round they will get a game over screen and a character unlock message. If they win every round they play - then they get to face Mainyu... the final boss. Mainyu doesn't use a strategy like the other characters. It's selections are completely random, which makes it really difficult to play against (random selections are the most difficult in Rock Paper Scissors. Humans think they can be random, but often fall into patterns - so it is possible to be good or bad and this game, which most put down to chance). Once Mainyu is defeated, it will be unlocked. Good luck! That's about it for game design for now. Hopefully this has highlighted just how complex even a seemingly trivial game like Rock Paper Scissors can be. Some of the strategy games I've worked on in the past have had tens of thousands of rows in spreadsheets filled with data about character stats, economy management, buffs etc... If you plan on making a game my recommendation would be to pick a simple but solid (and fun!) core gameplay mechanic and focus on getting it right. Keep it simple, then when it works add complexity around it. Complexity is easy to add - fun isn't. Focus on the fun. Speaking of fun, what's more fun than playing with and against other people? Let's move on to the game server.","title":"Beating the game"},{"location":"onboarding/rps_game/intro/","text":"Rock Paper Scissors Apocalypse Hopefully by now you've played (and hopefully enjoyed playing) Rock Paper Scissors Apocalypse. It's not a particularly advanced game - but that was not the goal. I didn't want to create a tech demo, I wanted to create a somewhat polished but simple product. A product that includes often overlooked parts of building a product, like end credits or a settings menu. I also wanted to build something that could serve as a creative outlet. There are elements of visual design, game design, audio and narrative, as well as interesting tech: Nodejs - for our stateful game server Websockets - for 'realtime' game communication Phaser - a popular 2D game engine In this section of the docs we will focus on Phaser and the single-player game mode. Let's dive in.","title":"Introduction"},{"location":"onboarding/rps_game/intro/#rock-paper-scissors-apocalypse","text":"Hopefully by now you've played (and hopefully enjoyed playing) Rock Paper Scissors Apocalypse. It's not a particularly advanced game - but that was not the goal. I didn't want to create a tech demo, I wanted to create a somewhat polished but simple product. A product that includes often overlooked parts of building a product, like end credits or a settings menu. I also wanted to build something that could serve as a creative outlet. There are elements of visual design, game design, audio and narrative, as well as interesting tech: Nodejs - for our stateful game server Websockets - for 'realtime' game communication Phaser - a popular 2D game engine In this section of the docs we will focus on Phaser and the single-player game mode. Let's dive in.","title":"Rock Paper Scissors Apocalypse"},{"location":"onboarding/rps_game/key_concepts/","text":"Before we jump too deep into the code, let's first go through some concepts and terminology that will be useful when describing how the game works. Phaser ] The first thing you should do before looking at the game code is head over to phaser.io and checking out the game engine we'll be using. In fact, regardless of what project you start working on, or company you start working at, it's always a good idea to go read up on whatever the core technology being leveraged is. This doesn't need to be a study session, but at the very least you should: Try to understand what the producers of the technology are trying to achieve Check out a few basic examples Understand the feature set of the technology Find the documentation Phaser is our game engine of choice. It is a free and open source 2D game engine that is easy to use, performant and full featured. Scenes A Phaser project is split into scenes . When you play single player mode in Rock Paper Scissors Apocalypse the game will move through the following scenes: Boot Loading Main menu Story intro Character selection Character Intro VS Scene Fight Scene Post fight Loop back to VS scene if winner Game over We follow the traditional format for a fighting game: Select character -> face opponent -> view result -> fight next opponent or game over. So there is a progression. You fight one character at a time until you get to the final boss, unlocking characters along the way. Scenes are analogous to the scenes in a movie, but for a game they can be described as 'the different stages of interaction a player has with a game'. Our game has a number of scenes to set up the game, then a scene for the actual game play, then a scene to display the results. Each scene expects something slightly different from the user and encompasses a logical step within the game. When working on Rock Paper Scissors Apocalypse you will spend most of your time working on the scenes. They are all in the game_rps/client/src/scenes directory. At this point it's also worth calling out a couple of scenes that are somewhat specialized. The boot scene The boot scene simply loads enough of the game for us to display a loading scene. In our case it downloads a couple of fonts before transitioning to the loading scene. The boot scene is our entry point to the game - the first scene that is run. It will simply display a black screen while loading its assets, before moving directly on to the loading scene. We do this to minimize the amount of content we need to load before showing the player something. In our case we just need our font so that we can display some text in the loading scene. The loading scene The loading scene will download all of the game assets (images, audio etc...) required to run the game. We do this up front because if we only load our assets as they are needed by the game, the game would stutter and slow down during scene transitions. Assets If you open up game_rps/client/src/assets you will find all of the images, audio and fonts for the game. There is also a file in there called asset_list.json . If you open up that file what you will see is basically a manifest that contains all of the game assets. If you want to add a new asset to the game it can be added here. The file is broken down by scene and any new assets added simply need to be added here and referenced as needed by the code - the loading scene will take care of downloading the actual asset. The game engine Our game project is actually composed of three different projects: Client Game engine Server We'll ignore the server for now, but what is this game engine project? Well - since this game is both single and multi player I decided to split out the actual gameplay logic into it's own small project that can be imported into both the client and server projects. This means we have the exact same gameplay logic regardless of whether we're working on single player or multi player. It also means we can run the game on the server side - making it harder for players to cheat the leaderboards. The game engine contains: Data models for the game (Game, Player, Round, Weapon etc...) The data for the game (settings, story line, characters, credits etc...) The logic for managing a series of rounds and results The engine is event driven, which means you can subscribe to its event system to listen out for changes in game state - which is how it gets hooked into the client and server. We'll look at this in more detail later when we get into the actual code. The game engine interface The game engine interface is a class that allows us to completely decouple our game UI from the concept of single player vs multi player. Basically we have a graphics layer that doesn't care about the game mode being played, it just cares about making everything look and feel nice. The complexities of networking and interacting with the game engine live in the game engine interface. One of the first things we do when starting a new game is to create an instance of this interface. With that in mind, let's jump into the code and take a look at single-player mode.","title":"Key Concepts"},{"location":"onboarding/rps_game/key_concepts/#phaser","text":"] The first thing you should do before looking at the game code is head over to phaser.io and checking out the game engine we'll be using. In fact, regardless of what project you start working on, or company you start working at, it's always a good idea to go read up on whatever the core technology being leveraged is. This doesn't need to be a study session, but at the very least you should: Try to understand what the producers of the technology are trying to achieve Check out a few basic examples Understand the feature set of the technology Find the documentation Phaser is our game engine of choice. It is a free and open source 2D game engine that is easy to use, performant and full featured.","title":"Phaser"},{"location":"onboarding/rps_game/key_concepts/#scenes","text":"A Phaser project is split into scenes . When you play single player mode in Rock Paper Scissors Apocalypse the game will move through the following scenes: Boot Loading Main menu Story intro Character selection Character Intro VS Scene Fight Scene Post fight Loop back to VS scene if winner Game over We follow the traditional format for a fighting game: Select character -> face opponent -> view result -> fight next opponent or game over. So there is a progression. You fight one character at a time until you get to the final boss, unlocking characters along the way. Scenes are analogous to the scenes in a movie, but for a game they can be described as 'the different stages of interaction a player has with a game'. Our game has a number of scenes to set up the game, then a scene for the actual game play, then a scene to display the results. Each scene expects something slightly different from the user and encompasses a logical step within the game. When working on Rock Paper Scissors Apocalypse you will spend most of your time working on the scenes. They are all in the game_rps/client/src/scenes directory. At this point it's also worth calling out a couple of scenes that are somewhat specialized.","title":"Scenes"},{"location":"onboarding/rps_game/key_concepts/#the-boot-scene","text":"The boot scene simply loads enough of the game for us to display a loading scene. In our case it downloads a couple of fonts before transitioning to the loading scene. The boot scene is our entry point to the game - the first scene that is run. It will simply display a black screen while loading its assets, before moving directly on to the loading scene. We do this to minimize the amount of content we need to load before showing the player something. In our case we just need our font so that we can display some text in the loading scene.","title":"The boot scene"},{"location":"onboarding/rps_game/key_concepts/#the-loading-scene","text":"The loading scene will download all of the game assets (images, audio etc...) required to run the game. We do this up front because if we only load our assets as they are needed by the game, the game would stutter and slow down during scene transitions.","title":"The loading scene"},{"location":"onboarding/rps_game/key_concepts/#assets","text":"If you open up game_rps/client/src/assets you will find all of the images, audio and fonts for the game. There is also a file in there called asset_list.json . If you open up that file what you will see is basically a manifest that contains all of the game assets. If you want to add a new asset to the game it can be added here. The file is broken down by scene and any new assets added simply need to be added here and referenced as needed by the code - the loading scene will take care of downloading the actual asset.","title":"Assets"},{"location":"onboarding/rps_game/key_concepts/#the-game-engine","text":"Our game project is actually composed of three different projects: Client Game engine Server We'll ignore the server for now, but what is this game engine project? Well - since this game is both single and multi player I decided to split out the actual gameplay logic into it's own small project that can be imported into both the client and server projects. This means we have the exact same gameplay logic regardless of whether we're working on single player or multi player. It also means we can run the game on the server side - making it harder for players to cheat the leaderboards. The game engine contains: Data models for the game (Game, Player, Round, Weapon etc...) The data for the game (settings, story line, characters, credits etc...) The logic for managing a series of rounds and results The engine is event driven, which means you can subscribe to its event system to listen out for changes in game state - which is how it gets hooked into the client and server. We'll look at this in more detail later when we get into the actual code.","title":"The game engine"},{"location":"onboarding/rps_game/key_concepts/#the-game-engine-interface","text":"The game engine interface is a class that allows us to completely decouple our game UI from the concept of single player vs multi player. Basically we have a graphics layer that doesn't care about the game mode being played, it just cares about making everything look and feel nice. The complexities of networking and interacting with the game engine live in the game engine interface. One of the first things we do when starting a new game is to create an instance of this interface. With that in mind, let's jump into the code and take a look at single-player mode.","title":"The game engine interface"},{"location":"onboarding/rps_game/single_player_mode/","text":"Working with Phaser Phaser is a 2d graphics engine and does not come with any fancy UI or layout functionality. When working on Varcade Games we were able to use HTML and CSS to easily lay out all of our content in a nice organized fashion. With Phaser we're 2d graphics land, which means a Cartesian plane and a X/Y coordinates. The top left hand corner of the game is point X=0, Y=0. As we add images, test and buttons to our game we have to explicitly set their X/Y coordinates on that plane. If you're not careful you will end up with lots of hardcoded values in your code, which can become pretty painful pretty quickly. So, before we go any further we should check out our layout file. Layout Open up client/src/game_data/layout.js and have a look around. At the top we have a couple of global variables. It's useful to calculate and store screen height / width and half height / half width as they will help us position game objects relative to the screen. For example if you want to position something in the middle of the screen you set X to half width and Y to half height. You will see these values used extensively throughout the rest of the file. The first layout, and most straight forward layout, in the file is for the Loading scene: 1 2 3 4 5 6 7 8 9 10 11 12 13 LoadingScene : { ui : { text : { originX : 0.5 , originY : 0.5 , bitmapFontId : 'verdana64' , color : 0xFF0000 , fontSize : 48 , x : globalLayoutData . halfScreenWidth , y : globalLayoutData . halfScreenHeight } } }, So what can we infer from this? Well it's safe to say that there is probably a loading scene. That loading scene probably has some UI and the UI looks like it has some text. That text has a bunch of data associated with it. A lot of it should be obvious - there's an X and Y coordinate, a color, a font ID and a font size. The only bits that might be unfamiliar are originX and originY . You will see this used extensively through out our layout file as it is a really useful feature that Phaser has. When positioning an object in 2d space you can specify the coordinates relative to some point on the object... this is a lot easier to explain with a diagram: As you can see in the image above, I am describing the position of the images in space relative to a point on the image. If I set the origin X and Y of an image to (0, 0), then placing the image at coordinates (10, 10) will result in Phaser rendering that image with the top left corner at that point. If I set the origin X and origin Y of an image to (0.5, 0.5), then placing the image at coordinates (40, 30) will result in Phaser rendering that image with the center at those coordinates. Why 0.5? Because the minimum value for the origin is 0 and the maximum is 1.0. So specifying 0.5 for the origin of both X and Y represents half way of both axes. If this is confusing don't worry about - jump into the code and make some changes and see what happens. The background for the main menu scene is defined next in the layout: 1 2 3 4 5 6 7 8 9 10 MainMenuScene : { ui : { background : { originX : 0 , originY : 0 , x : 0 , y : 0 } } } Try changing the origin X and Y to 0.5 and see what happens. What do you need to change X and Y to in order to fix it? That brief introduction should be enough for you to be able to find your way around the various scene layouts - so let's move on to the code. The main menu The main menu is one of the simpler scenes in the game, so we can use it to get a sense of how scenes are set up. First off we need to create a new instance of a Phaser Scene: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 const MainMenuScene = new Phaser . Class ({ Extends : Phaser . Scene , initialize : function () { Phaser . Scene . call ( this , { key : 'MainMenuScene' }) this . menuHighlightIconIndex = 0 }, init : function ( data ) { this . error = data . error // This will be filled if returning from an error in another scene }, create : function () { ... } ... } You will see this same basic setup in all of our scenes. Initialize acts as our constructor. init is called when the scene is being started and can also be used to pass data around, as we do here. Finally the create function is where we actually create our scene by adding images and text etc... Our rendering code looks like this: 1 2 3 4 5 6 7 8 this . layoutData = getSceneLayoutData ( 'MainMenuScene' ) const bgLayout = this . layoutData . ui . background this . add . image ( bgLayout . x , bgLayout . y , 'mainMenuBg' ). setOrigin ( bgLayout . originX , bgLayout . originY ) This is where we add the background image for our scene. First we fetch the layout information for the scene. Next we call a Phaser function: this.add.image - which is basically saying to Phaser 'add an image to this scene'. We give it the various coordinates and the ID of the image (this can be found in the asset list we discussed earlier) and we're done. Notice that the add.image(...) method returns an instance of itself so that we can chain a series of method calls together. In this case we add the image and then set the origin X/Y in one go. Once the background is sorted we add two buttons - one for single player and one for multi player. For now we only need to worry about single player, so this is the code we care about: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 const singlePlayerButton = new TextButton ( this , menuButtonLayout . x , menuButtonLayout . y , 'Single Player' , menuButtonLayout . bitmapFontId , menuButtonLayout . fontSize , menuButtonLayout . color , () => { // On click console . log ( 'Starting new single player game...' ) const gameInterface = new SinglePlayerGame ({ sequence : 0 , vsScreenDelay : 500 , bossFight : false }, { undefeated : true } ) audioManager . playEffect ( 'impact' , { seek : 1 }) this . scene . start ( 'StoryIntroScene' , { gameInterface : gameInterface }) }, () => { // On hover this . fistIndicator . setY ( menuButtonLayout . y + menuButtonLayout . fistIndicatorYOffset ) this . fistIndicator . setTexture ([ 'rockIco' , 'paperIco' , 'scissorsIco' ][ ++ this . menuHighlightIconIndex % 3 ]) } ) singlePlayerButton . setOrigin ( menuButtonLayout . originX , menuButtonLayout . originY ) this . add . existing ( singlePlayerButton ) There's quite a lot going on here, but it's all pretty simple stuff. We simple create a new instance of a text button - which is a custom component that renders text that can be clicked. Hopefully you've already seen and interacted with this text button by playing the game. The text button needs some coordinates and configuration values, but what's more interesting is the final constructor argument. It's a callback - it's the code that is executed when the text button is clicked. We create an instance of a SinglePlayerGame and then call this.scene.start to progress on to the next scene in single player mode. The next scene is the StoryIntroScene which presents the game narrative - but that scene is a bit boring, so let's skip over it an move straight on to character selection. Character Selection The character selection scene will hopefully feel familiar already. Our layouts are back and really we're just loading a bunch of different assets - but there are some new concepts that are worth touching on. Custom components You've already seen one custom component in the form of a TextButton . The character select scene has another called CharacterInfoBox , which represents the following section of the UI: These custom components can be found in client/src/ui_elements.js . It's worth calling out that that some of these components are subclasses of existing Phaser entities, but some are simply an abstraction to reduce code complexity. Our TextButton , for example, extends Phaser.GameObjects.BitmapText - meaning it can be handled by Phaser like any other game object. Our CharacterInfoBox on the other hand is not a type of GameObject. It is simply a wrapper class around a group of components in the UI. It didn't make sense to me at the time to make it a game object - though this might change in the future. Regardless of whether our custom components are game objects are not, the intention is the same. We want to avoid code duplication and we want to keep our scene code simple. Tweening We've got some fancy animations going on in this scene. To do this we use a common technique called tweening , which is kind of short for in between . You may also hear this being referred to as interpolation . Basically we are telling phaser: I have this image of a character at position X. I want to move the character to position Y and I want it to take 1 second. You fill in all of the points in between to create a smooth looking animation. In Phaser the code looks like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 tweenCharacterIn : function ( character ) { character . setVisible ( true ) const tweenConfig = { // A `tween config` that tells Phaser what to animate targets : [ character ], // The game entities we want to tween x : this . layoutData . ui . character . x , // The attribute of the entity we want to tween duration : 500 , // How long we want the tween to take ease : 'Expo.easeOut' , // This is a 'easing' function, which adds a sort of deceleration effect repeat : 0 , onComplete : () => { // This is called when the animations completes this . characterSelectEnabled = true } } this . tweens . add ( tweenConfig ) }, This is the method we call when we want to animate a character on to the screen. I've added some comments to explain the various components. The most important part is: 1 x : this . layoutData . ui . character . x This is telling Phaser to tween the x attribute of our character image. When the character is off screen the x coordinate will be a negative value. We're telling Phaser to increase the x coordinate until it's value is equal to this.layoutData.ui.character.x . It looks something like this when laid out on a labelled axis: In our example the Aruka's initial coordinates are: 1 2 3 4 x: -40 y: 40 Origin x: 0.0 Origin y: 1.0 But we want Phaser to animate him over to: 1 2 3 4 x: 10 y: 40 Origin x: 0.0 Origin y: 1.0 And we want it to take 500 milliseconds. Try changing some of these values yourself. Increase or decrease the duration to slow down or speed up the animation. Also take a look at the Phaser docs to see what other ease functions are available and what they do. Again - the best way to understand this stuff is to play with it yourself. Data driven development If you've been looking through the code you may notice we load the character image and headshot by looping through the character list and creating images for each one: 1 2 3 4 5 6 7 8 9 10 const fullbody = this . add . image ( characterLayout . x - characterLayout . width , // Start off screen characterLayout . y , character . id + '_upperbody' ). setVisible ( false ). setOrigin ( characterLayout . originX , characterLayout . originY ) With the above code we create and add an image to the scene. Notice that the first argument, which is the X coordinate, is a negative value. As already mentioned above this is because we want to animate the image in from the left. Also notice that the line character.id + '_upperbody' . This is the ID of the texture. If you look through the game assets or read through the loading code you will find that the character images are all named <character_id>_<image_id>. For example: 1 2 3 man_headshot, // Manbo's headshot hog_upperbody, // Hogo Sha's upper body mai_flag // Mainyu's flag This allows us to dynamically add characters to the game simply by adding the required images and character config (their backstory etc...). We don't need to change any code - meaning our game is data driven when it comes to the characters. VS scene The VS scene is where we display who the player will be facing in the next round. This one is pretty simple - though there are a couple of things we should look at a little closer. View data If you look at the init method you'll see something called viewData : 1 2 3 4 5 6 7 8 init : function ( data ) { this . gameInterface = data . gameInterface this . viewData = this . gameInterface . getGameViewData () // This guy right here this . p1Ready = false this . p2Ready = false this . unknownOpponent = null this . battleSceneStarted = false } Back in the main menu scene we created an instance of a SinglePlayerGame . That object contains an object we call the view data . This object contains everything the UI needs to know in order to display the current state of the key. This is as close as our ever gets to the game engine (and the game server - bit we'll get to that later). It's an abstraction . This object is how we decouple our game logic from our UI. This is essential if we want to use the same engine on the client and on the server. The update method This is the first time we use Phaser 's update method. It is a scene method that is called once every frame. So if the game is running at 30 frames per second, this method will be called 30 times every second. In the VS scene we need to wait until both player have selected a character. For single player this happens instantly because in single player mode each character has a predetermined list of opponents. During multi-player we need to wait in this scene for an opponent. We don't need to worry about multi-player right now, but let's look at how we use the view data to update the state of this scene: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 if ( ! this . p2Ready && this . viewData . p2Spec != null ) { if ( this . unknownOpponent ) { // Opponent joined multi-player game, need to animate this out this . tweens . add ({ targets : this . unknownOpponent , x : '+=' + this . layoutData . graphics . unknownOpponent . xTranslationDistance , duration : this . layoutData . graphics . unknownOpponent . xTranslationDuration , ease : 'Expo.easeOut' }) } const p2Layout = this . layoutData . graphics . p2 this . p2CharacterImage . setTexture ( this . viewData . p2Spec . id + '_upperbody' ) ... } This is a snippet taken from the update method. this.p2Ready is a boolean that belongs to the VS scene. We use this to make sure we don't process character selection more than once. this.viewData.p2Spec tells us which character, if any has been selected. P2 is player 2 and spec references the specification , or settings, of the character they selected. The VS scene has no idea whether P2 is the computer or another human player on the other side of the world - and that's exactly how we want it. Once a spec has been set we are free to go ahead and render the character that was selected, using information contained within the spec. The fight scene The fight scene is where all of the action happens, so unsurprisingly it is the most complicated scene in the game. The graphics are fairly straight forward, nothing much we haven't seen in other scenes. We have some text, character art and a background. Each character has a health bar, which is another custom component that lives in client/src/ui_elements/health_bar.js . All we do is render two rectangles, one on top of the other. We size the one on top based on the % health remaining for that character. We use our update method to keep our health bars up to date: 1 2 3 4 5 update : function ( time , delta ) { this . p1HealthBar . updateHealth ( this . viewData . p1CurrentHealth ) this . p2HealthBar . updateHealth ( this . viewData . p2CurrentHealth ) ... } Again we're just pulling information from the viewData object. This information could be coming from the server, or not, the scene doesn't care. The real complexity in this scene comes from it's interactions with the game engine, so let's look there. Game Events 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 this . gameInterface . addEventListener (( event ) => this . gameEventListener ( event )) ... gameEventListener : function ( event ) { if ( event instanceof RPSRoundEvent ) { switch ( event . type ) { case RPSRoundEvent . ROUND_COUNTDOWN : this . handleRoundCountdownEvent ( event ) break case RPSRoundEvent . WEAPON_COUNTDOWN : this . handleWeaponCountdownEvent ( event ) break case RPSRoundEvent . STATE_CHANGE : this . handleStateChangeEvent ( event ) break case RPSRoundEvent . WEAPONS_SELECTED : this . handleBattleEvent ( event ) break case RPSRoundEvent . ROUND_FINISHED : this . handleRoundEnd ( event ) break case RPSRoundEvent . ROUND_STARTED : break default : console . log ( 'Got unknown round event type: ' + event . type ) break } } else if ( event instanceof RPSGameEvent ) { switch ( event . type ) { case RPSGameEvent . GAME_COMPLETE : this . leaveScene ( 'PostFightScene' , { gameInterface : this . gameInterface }) break default : console . log ( 'Got unknown game event type: ' + event . type ) break } } } First we register a handler with something called the gameInterface . This game interface is the instance of SinglePlayerGame that we created in the menu scene. It's the same object we fetch the view data from - but the view data is a read-only data model, it doesn't allow us to interact with the game. We do that directly through the SinglePlayerGame object itself. In the event handler we have napped an event ID to methods that exist without our scene. These events are coming from the game engine, and could be coming from our local client or from a game server, depending on whether we're playing single or multi player. If you've played the game enough, the events should make immediate sense: 1 2 3 4 5 6 RPSRoundEvent . ROUND_STARTED // A new round has started RPSRoundEvent . ROUND_COUNTDOWN // At the start of each round we show a 'Get Ready' message - that is this event RPSRoundEvent . WEAPON_COUNTDOWN // The 3 second countdown for weapon selection comes in this event RPSRoundEvent . STATE_CHANGE // This signifies a state change, we'll discuss states more when we get to the game engine, but states includes things like [NEW_ROUND, COUNDOWN, WAITING_FOR_WEAPON_SELECTION] RPSRoundEvent . WEAPONS_SELECTED // Both players have selected their weapon so we need to show the result RPSRoundEvent . ROUND_FINISHED // A round has ended The game engine fires out these key events letting the game client know that it should update the game state. Game States Another thing that's worth looking at is how we handle game state changes. State changes are slightly different to events in that we sometimes want to know when we enter a state and when we exit a state, so here's how we handle that: 1 2 3 4 5 6 this . stateHandlerMap [ RPSRoundStates . NEW_ROUND ] = { onEnter : () => { }, onExit : () => { } } 1 2 3 4 handleStateChangeEvent : function ( event ) { this . stateHandlerMap [ event . data . oldState ]. onExit () this . stateHandlerMap [ event . data . newState ]. onEnter () } The other scenes There are some other scenes, but we don't need to look to intensely at them just yet. Game over When that game ends, whether you lost the first match or defeated the last boss, you are sent to the game over scene. Depending on the result the scene will display a different message. If you beat the game you will get to see the end credits. Booting and Loading I've already mentioned these scenes. It's where we load all of the images and audio files we need to run the game. Narrative There are two different narrative scenes: The game lore The character lore When single player mode begins we display the game lore - this is the story line of the game. It scrolls up the screen and can be skipped. When the player selects a character they will then see that characters back story. This is also simple scrolling text that can be skipped. All of these characters, the story lines, their stats etc... are game design details. These details are configured in the game engine, so let's look there next.","title":"Single player"},{"location":"onboarding/rps_game/single_player_mode/#working-with-phaser","text":"Phaser is a 2d graphics engine and does not come with any fancy UI or layout functionality. When working on Varcade Games we were able to use HTML and CSS to easily lay out all of our content in a nice organized fashion. With Phaser we're 2d graphics land, which means a Cartesian plane and a X/Y coordinates. The top left hand corner of the game is point X=0, Y=0. As we add images, test and buttons to our game we have to explicitly set their X/Y coordinates on that plane. If you're not careful you will end up with lots of hardcoded values in your code, which can become pretty painful pretty quickly. So, before we go any further we should check out our layout file.","title":"Working with Phaser"},{"location":"onboarding/rps_game/single_player_mode/#layout","text":"Open up client/src/game_data/layout.js and have a look around. At the top we have a couple of global variables. It's useful to calculate and store screen height / width and half height / half width as they will help us position game objects relative to the screen. For example if you want to position something in the middle of the screen you set X to half width and Y to half height. You will see these values used extensively throughout the rest of the file. The first layout, and most straight forward layout, in the file is for the Loading scene: 1 2 3 4 5 6 7 8 9 10 11 12 13 LoadingScene : { ui : { text : { originX : 0.5 , originY : 0.5 , bitmapFontId : 'verdana64' , color : 0xFF0000 , fontSize : 48 , x : globalLayoutData . halfScreenWidth , y : globalLayoutData . halfScreenHeight } } }, So what can we infer from this? Well it's safe to say that there is probably a loading scene. That loading scene probably has some UI and the UI looks like it has some text. That text has a bunch of data associated with it. A lot of it should be obvious - there's an X and Y coordinate, a color, a font ID and a font size. The only bits that might be unfamiliar are originX and originY . You will see this used extensively through out our layout file as it is a really useful feature that Phaser has. When positioning an object in 2d space you can specify the coordinates relative to some point on the object... this is a lot easier to explain with a diagram: As you can see in the image above, I am describing the position of the images in space relative to a point on the image. If I set the origin X and Y of an image to (0, 0), then placing the image at coordinates (10, 10) will result in Phaser rendering that image with the top left corner at that point. If I set the origin X and origin Y of an image to (0.5, 0.5), then placing the image at coordinates (40, 30) will result in Phaser rendering that image with the center at those coordinates. Why 0.5? Because the minimum value for the origin is 0 and the maximum is 1.0. So specifying 0.5 for the origin of both X and Y represents half way of both axes. If this is confusing don't worry about - jump into the code and make some changes and see what happens. The background for the main menu scene is defined next in the layout: 1 2 3 4 5 6 7 8 9 10 MainMenuScene : { ui : { background : { originX : 0 , originY : 0 , x : 0 , y : 0 } } } Try changing the origin X and Y to 0.5 and see what happens. What do you need to change X and Y to in order to fix it? That brief introduction should be enough for you to be able to find your way around the various scene layouts - so let's move on to the code.","title":"Layout"},{"location":"onboarding/rps_game/single_player_mode/#the-main-menu","text":"The main menu is one of the simpler scenes in the game, so we can use it to get a sense of how scenes are set up. First off we need to create a new instance of a Phaser Scene: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 const MainMenuScene = new Phaser . Class ({ Extends : Phaser . Scene , initialize : function () { Phaser . Scene . call ( this , { key : 'MainMenuScene' }) this . menuHighlightIconIndex = 0 }, init : function ( data ) { this . error = data . error // This will be filled if returning from an error in another scene }, create : function () { ... } ... } You will see this same basic setup in all of our scenes. Initialize acts as our constructor. init is called when the scene is being started and can also be used to pass data around, as we do here. Finally the create function is where we actually create our scene by adding images and text etc... Our rendering code looks like this: 1 2 3 4 5 6 7 8 this . layoutData = getSceneLayoutData ( 'MainMenuScene' ) const bgLayout = this . layoutData . ui . background this . add . image ( bgLayout . x , bgLayout . y , 'mainMenuBg' ). setOrigin ( bgLayout . originX , bgLayout . originY ) This is where we add the background image for our scene. First we fetch the layout information for the scene. Next we call a Phaser function: this.add.image - which is basically saying to Phaser 'add an image to this scene'. We give it the various coordinates and the ID of the image (this can be found in the asset list we discussed earlier) and we're done. Notice that the add.image(...) method returns an instance of itself so that we can chain a series of method calls together. In this case we add the image and then set the origin X/Y in one go. Once the background is sorted we add two buttons - one for single player and one for multi player. For now we only need to worry about single player, so this is the code we care about: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 const singlePlayerButton = new TextButton ( this , menuButtonLayout . x , menuButtonLayout . y , 'Single Player' , menuButtonLayout . bitmapFontId , menuButtonLayout . fontSize , menuButtonLayout . color , () => { // On click console . log ( 'Starting new single player game...' ) const gameInterface = new SinglePlayerGame ({ sequence : 0 , vsScreenDelay : 500 , bossFight : false }, { undefeated : true } ) audioManager . playEffect ( 'impact' , { seek : 1 }) this . scene . start ( 'StoryIntroScene' , { gameInterface : gameInterface }) }, () => { // On hover this . fistIndicator . setY ( menuButtonLayout . y + menuButtonLayout . fistIndicatorYOffset ) this . fistIndicator . setTexture ([ 'rockIco' , 'paperIco' , 'scissorsIco' ][ ++ this . menuHighlightIconIndex % 3 ]) } ) singlePlayerButton . setOrigin ( menuButtonLayout . originX , menuButtonLayout . originY ) this . add . existing ( singlePlayerButton ) There's quite a lot going on here, but it's all pretty simple stuff. We simple create a new instance of a text button - which is a custom component that renders text that can be clicked. Hopefully you've already seen and interacted with this text button by playing the game. The text button needs some coordinates and configuration values, but what's more interesting is the final constructor argument. It's a callback - it's the code that is executed when the text button is clicked. We create an instance of a SinglePlayerGame and then call this.scene.start to progress on to the next scene in single player mode. The next scene is the StoryIntroScene which presents the game narrative - but that scene is a bit boring, so let's skip over it an move straight on to character selection.","title":"The main menu"},{"location":"onboarding/rps_game/single_player_mode/#character-selection","text":"The character selection scene will hopefully feel familiar already. Our layouts are back and really we're just loading a bunch of different assets - but there are some new concepts that are worth touching on.","title":"Character Selection"},{"location":"onboarding/rps_game/single_player_mode/#custom-components","text":"You've already seen one custom component in the form of a TextButton . The character select scene has another called CharacterInfoBox , which represents the following section of the UI: These custom components can be found in client/src/ui_elements.js . It's worth calling out that that some of these components are subclasses of existing Phaser entities, but some are simply an abstraction to reduce code complexity. Our TextButton , for example, extends Phaser.GameObjects.BitmapText - meaning it can be handled by Phaser like any other game object. Our CharacterInfoBox on the other hand is not a type of GameObject. It is simply a wrapper class around a group of components in the UI. It didn't make sense to me at the time to make it a game object - though this might change in the future. Regardless of whether our custom components are game objects are not, the intention is the same. We want to avoid code duplication and we want to keep our scene code simple.","title":"Custom components"},{"location":"onboarding/rps_game/single_player_mode/#tweening","text":"We've got some fancy animations going on in this scene. To do this we use a common technique called tweening , which is kind of short for in between . You may also hear this being referred to as interpolation . Basically we are telling phaser: I have this image of a character at position X. I want to move the character to position Y and I want it to take 1 second. You fill in all of the points in between to create a smooth looking animation. In Phaser the code looks like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 tweenCharacterIn : function ( character ) { character . setVisible ( true ) const tweenConfig = { // A `tween config` that tells Phaser what to animate targets : [ character ], // The game entities we want to tween x : this . layoutData . ui . character . x , // The attribute of the entity we want to tween duration : 500 , // How long we want the tween to take ease : 'Expo.easeOut' , // This is a 'easing' function, which adds a sort of deceleration effect repeat : 0 , onComplete : () => { // This is called when the animations completes this . characterSelectEnabled = true } } this . tweens . add ( tweenConfig ) }, This is the method we call when we want to animate a character on to the screen. I've added some comments to explain the various components. The most important part is: 1 x : this . layoutData . ui . character . x This is telling Phaser to tween the x attribute of our character image. When the character is off screen the x coordinate will be a negative value. We're telling Phaser to increase the x coordinate until it's value is equal to this.layoutData.ui.character.x . It looks something like this when laid out on a labelled axis: In our example the Aruka's initial coordinates are: 1 2 3 4 x: -40 y: 40 Origin x: 0.0 Origin y: 1.0 But we want Phaser to animate him over to: 1 2 3 4 x: 10 y: 40 Origin x: 0.0 Origin y: 1.0 And we want it to take 500 milliseconds. Try changing some of these values yourself. Increase or decrease the duration to slow down or speed up the animation. Also take a look at the Phaser docs to see what other ease functions are available and what they do. Again - the best way to understand this stuff is to play with it yourself.","title":"Tweening"},{"location":"onboarding/rps_game/single_player_mode/#data-driven-development","text":"If you've been looking through the code you may notice we load the character image and headshot by looping through the character list and creating images for each one: 1 2 3 4 5 6 7 8 9 10 const fullbody = this . add . image ( characterLayout . x - characterLayout . width , // Start off screen characterLayout . y , character . id + '_upperbody' ). setVisible ( false ). setOrigin ( characterLayout . originX , characterLayout . originY ) With the above code we create and add an image to the scene. Notice that the first argument, which is the X coordinate, is a negative value. As already mentioned above this is because we want to animate the image in from the left. Also notice that the line character.id + '_upperbody' . This is the ID of the texture. If you look through the game assets or read through the loading code you will find that the character images are all named <character_id>_<image_id>. For example: 1 2 3 man_headshot, // Manbo's headshot hog_upperbody, // Hogo Sha's upper body mai_flag // Mainyu's flag This allows us to dynamically add characters to the game simply by adding the required images and character config (their backstory etc...). We don't need to change any code - meaning our game is data driven when it comes to the characters.","title":"Data driven development"},{"location":"onboarding/rps_game/single_player_mode/#vs-scene","text":"The VS scene is where we display who the player will be facing in the next round. This one is pretty simple - though there are a couple of things we should look at a little closer.","title":"VS scene"},{"location":"onboarding/rps_game/single_player_mode/#view-data","text":"If you look at the init method you'll see something called viewData : 1 2 3 4 5 6 7 8 init : function ( data ) { this . gameInterface = data . gameInterface this . viewData = this . gameInterface . getGameViewData () // This guy right here this . p1Ready = false this . p2Ready = false this . unknownOpponent = null this . battleSceneStarted = false } Back in the main menu scene we created an instance of a SinglePlayerGame . That object contains an object we call the view data . This object contains everything the UI needs to know in order to display the current state of the key. This is as close as our ever gets to the game engine (and the game server - bit we'll get to that later). It's an abstraction . This object is how we decouple our game logic from our UI. This is essential if we want to use the same engine on the client and on the server.","title":"View data"},{"location":"onboarding/rps_game/single_player_mode/#the-update-method","text":"This is the first time we use Phaser 's update method. It is a scene method that is called once every frame. So if the game is running at 30 frames per second, this method will be called 30 times every second. In the VS scene we need to wait until both player have selected a character. For single player this happens instantly because in single player mode each character has a predetermined list of opponents. During multi-player we need to wait in this scene for an opponent. We don't need to worry about multi-player right now, but let's look at how we use the view data to update the state of this scene: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 if ( ! this . p2Ready && this . viewData . p2Spec != null ) { if ( this . unknownOpponent ) { // Opponent joined multi-player game, need to animate this out this . tweens . add ({ targets : this . unknownOpponent , x : '+=' + this . layoutData . graphics . unknownOpponent . xTranslationDistance , duration : this . layoutData . graphics . unknownOpponent . xTranslationDuration , ease : 'Expo.easeOut' }) } const p2Layout = this . layoutData . graphics . p2 this . p2CharacterImage . setTexture ( this . viewData . p2Spec . id + '_upperbody' ) ... } This is a snippet taken from the update method. this.p2Ready is a boolean that belongs to the VS scene. We use this to make sure we don't process character selection more than once. this.viewData.p2Spec tells us which character, if any has been selected. P2 is player 2 and spec references the specification , or settings, of the character they selected. The VS scene has no idea whether P2 is the computer or another human player on the other side of the world - and that's exactly how we want it. Once a spec has been set we are free to go ahead and render the character that was selected, using information contained within the spec.","title":"The update method"},{"location":"onboarding/rps_game/single_player_mode/#the-fight-scene","text":"The fight scene is where all of the action happens, so unsurprisingly it is the most complicated scene in the game. The graphics are fairly straight forward, nothing much we haven't seen in other scenes. We have some text, character art and a background. Each character has a health bar, which is another custom component that lives in client/src/ui_elements/health_bar.js . All we do is render two rectangles, one on top of the other. We size the one on top based on the % health remaining for that character. We use our update method to keep our health bars up to date: 1 2 3 4 5 update : function ( time , delta ) { this . p1HealthBar . updateHealth ( this . viewData . p1CurrentHealth ) this . p2HealthBar . updateHealth ( this . viewData . p2CurrentHealth ) ... } Again we're just pulling information from the viewData object. This information could be coming from the server, or not, the scene doesn't care. The real complexity in this scene comes from it's interactions with the game engine, so let's look there.","title":"The fight scene"},{"location":"onboarding/rps_game/single_player_mode/#game-events","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 this . gameInterface . addEventListener (( event ) => this . gameEventListener ( event )) ... gameEventListener : function ( event ) { if ( event instanceof RPSRoundEvent ) { switch ( event . type ) { case RPSRoundEvent . ROUND_COUNTDOWN : this . handleRoundCountdownEvent ( event ) break case RPSRoundEvent . WEAPON_COUNTDOWN : this . handleWeaponCountdownEvent ( event ) break case RPSRoundEvent . STATE_CHANGE : this . handleStateChangeEvent ( event ) break case RPSRoundEvent . WEAPONS_SELECTED : this . handleBattleEvent ( event ) break case RPSRoundEvent . ROUND_FINISHED : this . handleRoundEnd ( event ) break case RPSRoundEvent . ROUND_STARTED : break default : console . log ( 'Got unknown round event type: ' + event . type ) break } } else if ( event instanceof RPSGameEvent ) { switch ( event . type ) { case RPSGameEvent . GAME_COMPLETE : this . leaveScene ( 'PostFightScene' , { gameInterface : this . gameInterface }) break default : console . log ( 'Got unknown game event type: ' + event . type ) break } } } First we register a handler with something called the gameInterface . This game interface is the instance of SinglePlayerGame that we created in the menu scene. It's the same object we fetch the view data from - but the view data is a read-only data model, it doesn't allow us to interact with the game. We do that directly through the SinglePlayerGame object itself. In the event handler we have napped an event ID to methods that exist without our scene. These events are coming from the game engine, and could be coming from our local client or from a game server, depending on whether we're playing single or multi player. If you've played the game enough, the events should make immediate sense: 1 2 3 4 5 6 RPSRoundEvent . ROUND_STARTED // A new round has started RPSRoundEvent . ROUND_COUNTDOWN // At the start of each round we show a 'Get Ready' message - that is this event RPSRoundEvent . WEAPON_COUNTDOWN // The 3 second countdown for weapon selection comes in this event RPSRoundEvent . STATE_CHANGE // This signifies a state change, we'll discuss states more when we get to the game engine, but states includes things like [NEW_ROUND, COUNDOWN, WAITING_FOR_WEAPON_SELECTION] RPSRoundEvent . WEAPONS_SELECTED // Both players have selected their weapon so we need to show the result RPSRoundEvent . ROUND_FINISHED // A round has ended The game engine fires out these key events letting the game client know that it should update the game state.","title":"Game Events"},{"location":"onboarding/rps_game/single_player_mode/#game-states","text":"Another thing that's worth looking at is how we handle game state changes. State changes are slightly different to events in that we sometimes want to know when we enter a state and when we exit a state, so here's how we handle that: 1 2 3 4 5 6 this . stateHandlerMap [ RPSRoundStates . NEW_ROUND ] = { onEnter : () => { }, onExit : () => { } } 1 2 3 4 handleStateChangeEvent : function ( event ) { this . stateHandlerMap [ event . data . oldState ]. onExit () this . stateHandlerMap [ event . data . newState ]. onEnter () }","title":"Game States"},{"location":"onboarding/rps_game/single_player_mode/#the-other-scenes","text":"There are some other scenes, but we don't need to look to intensely at them just yet.","title":"The other scenes"},{"location":"onboarding/rps_game/single_player_mode/#game-over","text":"When that game ends, whether you lost the first match or defeated the last boss, you are sent to the game over scene. Depending on the result the scene will display a different message. If you beat the game you will get to see the end credits.","title":"Game over"},{"location":"onboarding/rps_game/single_player_mode/#booting-and-loading","text":"I've already mentioned these scenes. It's where we load all of the images and audio files we need to run the game.","title":"Booting and Loading"},{"location":"onboarding/rps_game/single_player_mode/#narrative","text":"There are two different narrative scenes: The game lore The character lore When single player mode begins we display the game lore - this is the story line of the game. It scrolls up the screen and can be skipped. When the player selects a character they will then see that characters back story. This is also simple scrolling text that can be skipped. All of these characters, the story lines, their stats etc... are game design details. These details are configured in the game engine, so let's look there next.","title":"Narrative"},{"location":"onboarding/rps_game/the_game_engine/","text":"The Game Engine is a combination of all of the game data and game logic for Rock Paper Scissors Apocalypse. It is a library that can be run in a browser or on a server - enabling multi-player gameplay. The game characters are defined here, as are the rules of the game and the execution of the game. In this section we'll have a quick look at some of the important elements of the engine. Game Data Open up game_engine/src/game_data.js . The contents of this file should be immediately familiar. It's all of the character information you've seen in the game UI. Here's the first entry in the character list: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 const characters = [ { id : 'aru' , displayName : 'Aruka' , country : 'Brazil' , stats : { health : 100 , style : 'paper' , rock : { baseDamage : 25 , damageModifier : 0 , damageMitigation : 0.2 }, paper : { baseDamage : 25 , damageModifier : 0.30 , damageMitigation : 0 }, scissors : { baseDamage : 25 , damageModifier : 0 , damageMitigation : 0 } }, singlePlayerSequence : [ 'man' , 'rad' , 'hog' ], locked : false , isBoss : false , singlePlayerUnlock : 'hog' , storyline : [ 'As humanity stood face to face with the darkest evil it had ever encountered, the indigenous warriors of the Amazon were some of the first to stand in its path.\\n' , 'Many believe that the spirit of mother nature flows through Aruka and guides him against the forces of darkness.\\n' , 'His intuition of all things natural, be they creative or destructive forces, makes Aruka a natural RPS contender. During battle he enters a trance-like state, through which his focus and composure is unwavering.' ], trashTalk : { win : [ 'The forest will always prevail...' ], lose : [ 'There is no good that lasts forever nor evil that never ends.' ] } } ... Some interesting fields here are: 1 2 3 singlePlayerSequence : [ 'man' , 'rad' , 'hog' ], These are the IDs of the characters that Aruka will face during single player mode. 1 locked : false , This tell the game client whether the character should initially be displayed as locked. If this is true you will need to make sure that the character can be unlocked (see below). 1 isBoss : false , This is, and should only be, true for one of the characters. The boss is treated differently to other players and is only faced once the player defeats all of their opponents without losing a single round. Mainyu is our boss. 1 singlePlayerUnlock : 'hog' , This entry tells us what character to unlock when this character successfully defeats every opponent in their singlePlayerSequence . Not every character unlocks another character, so this can be null. Try playing around with some of these settings and see what happens. Game Models This is where we define the various different game objects that we will use to represent players in the game, along with their characters and weapon selections. Most of these classes should be fairly self-explanatory. One thing to note is the RPSFighter : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class RPSFighter { /** * Represents the player's character selection. **/ constructor ( spec ) { this . id = spec . id this . spec = spec // Amount of damage this fighter has taken in the current round this . damage = 0 this . weapons = [ new Rock ( this . spec . stats . rock . baseDamage , { damageModifier : this . spec . stats . rock . damageModifier , damageMitigation : this . spec . stats . rock . damageMitigation }), new Paper ( this . spec . stats . paper . baseDamage , { damageModifier : this . spec . stats . paper . damageModifier , damageMitigation : this . spec . stats . paper . damageMitigation }), new Scissors ( this . spec . stats . scissors . baseDamage , { damageModifier : this . spec . stats . scissors . damageModifier , damageMitigation : this . spec . stats . scissors . damageMitigation }) ] this . currentSelectedWeaponIndex = null // True if the current round is accepting weapon selection from players this . weaponSelectAvailable = false } In it's constructor it loads stats from game_data.js . So we can balance the characters strengths and weaknesses from the data file. Or in other words - it's data driven . A couple of other interesting classes in this file are our bots: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class RPSStrategyBot extends RPSPlayer { /** * Represents an AI player (single player mode) * that uses some basic strategy, as defined in * strategy.js **/ constructor ( id , difficulty ) { super ( id ) this . strategy = getStrategy ( difficulty ) } eventListener ( event ) { if ( event instanceof RPSRoundEvent ) { if ( event . type === RPSRoundEvent . WEAPON_COUNTDOWN && event . data . value === 2 ) { this . fighter . equipWeapon ( this . strategy . getNextSelection ( this . fighter . getCurrentHealthPct ())) } if ( event . type === RPSRoundEvent . ROUND_FINISHED ) { this . strategy . reset () } } } } class RPSRandomBot extends RPSPlayer { /** * Represents an AI player (single player mode) * that simply makes random selection - * !Note! This is one of the most difficult to play against **/ eventListener ( event ) { if ( event instanceof RPSRoundEvent ) { if ( event . type === RPSRoundEvent . WEAPON_COUNTDOWN ) { this . fighter . equipWeapon ( Math . floor ( Math . random () * 3 )) } } } } The RPSRandomBot is used to create a single player enemy that will just make random selections. This is the hardest type of opponent to play against - so this is used by the final boss. The RPSStrategyBot is a little different. This object is used to create a single player enemy that plays according to strategies of varying difficulty. Our AI will always use some repeating pattern. The strategy difficulty dictates how difficult the pattern is to detect and whether the AI will change strategy after taking a certain amount of damage. These are used during single player to create a set of opponents that increase in difficulty as the player progresses. Game Play Open up game_engine/src/game_play.js . This is there the actual game happens. There is a class called RPSGame . This is class is essentially a state management system. Game States A game have a number of states it can be in: 1 2 3 4 5 6 class RPSGameStates { static get WAITING_FOR_PLAYERS () { return 0 } static get CHARACTER_SELECTION () { return 1 } static get IN_PROGRESS () { return 2 } static get GAME_OVER () { return 3 } } WAITING_FOR_PLAYERS The game has been created and is now waiting for players to be added. CHARACTER_SELECTION The game is now waiting for the players to make their character selection. IN_PROGRESS The game is in progress. GAME_OVER The game has ended. Rounds Once a game is in progress it is represented as a series of rounds. A player must win two rounds to win the game. Therefore the minimum number of rounds is 2 and the maximum is 3. Rounds are have a number of states that they progress through during gameplay: 1 2 3 4 5 static get NEW_ROUND () { return 0 } static get COUNTDOWN () { return 1 } static get WAITING_FOR_WEAPON_SELECTION () { return 2 } static get PROCESSING_RESULT () { return 3 } static get FINISHED () { return 4 } NEW_ROUND The round has been created. COUNTDOWN The 'start of round' countdown is in progress. WAITING_FOR_WEAPON_SELECTION Players can make their weapon selections. PROCESSING_RESULT The result of the player's selection are being processed. FINISHED The round has finished. A round will enter a cycle of going from WAITING_FOR_WEAPON_SELECTION to PROCESSING_RESULT until the game detects that a player has reached zero health, at which point it will progress to the FINISHED state. Tick So as you can see there is a logical progression of states that happens in order to make the game run. This progression is very similar in code to what the player experiences: Start game -> Select character -> Start battle -> start round -> select weapon -> Apply damage -> Repeat until health is zero -> End round -> Repeat until one player wins two rounds. But what is actually running this progression? That would be our game tick . The RPSGame object has a method: 1 2 3 tick () { this . stateHandlers [ this . state ]() } This method calls a state handler , which will behave differently depending on the current state of the game. This tick can be called at any desired interval. When the server is running the game it calls 'tick' every second. Single player mode calls it every half second. The speed of the game is based on the tick, because the tick is simply what causes our game states to change from one state to the next. If you want to play with this yourself, open up game_rps/client/src/game_engine_interface.js and find the line: 1 2 3 4 5 6 console . log ( 'Single player game - starting client side tick loop...' ) this . tickTimer = setInterval (() => { if ( ! this . paused ) { this . game . tick () } }, 500 ) That 500 is the 500 millisecond tick for single player. If you increase that value your single player game will run slower. Decrease it and it will run faster. That's about as deep as I want to go into the game for this onboarding course. Next we will look at the game design - understanding the gameplay will help you reason about the code.","title":"The Game Engine"},{"location":"onboarding/rps_game/the_game_engine/#game-data","text":"Open up game_engine/src/game_data.js . The contents of this file should be immediately familiar. It's all of the character information you've seen in the game UI. Here's the first entry in the character list: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 const characters = [ { id : 'aru' , displayName : 'Aruka' , country : 'Brazil' , stats : { health : 100 , style : 'paper' , rock : { baseDamage : 25 , damageModifier : 0 , damageMitigation : 0.2 }, paper : { baseDamage : 25 , damageModifier : 0.30 , damageMitigation : 0 }, scissors : { baseDamage : 25 , damageModifier : 0 , damageMitigation : 0 } }, singlePlayerSequence : [ 'man' , 'rad' , 'hog' ], locked : false , isBoss : false , singlePlayerUnlock : 'hog' , storyline : [ 'As humanity stood face to face with the darkest evil it had ever encountered, the indigenous warriors of the Amazon were some of the first to stand in its path.\\n' , 'Many believe that the spirit of mother nature flows through Aruka and guides him against the forces of darkness.\\n' , 'His intuition of all things natural, be they creative or destructive forces, makes Aruka a natural RPS contender. During battle he enters a trance-like state, through which his focus and composure is unwavering.' ], trashTalk : { win : [ 'The forest will always prevail...' ], lose : [ 'There is no good that lasts forever nor evil that never ends.' ] } } ... Some interesting fields here are: 1 2 3 singlePlayerSequence : [ 'man' , 'rad' , 'hog' ], These are the IDs of the characters that Aruka will face during single player mode. 1 locked : false , This tell the game client whether the character should initially be displayed as locked. If this is true you will need to make sure that the character can be unlocked (see below). 1 isBoss : false , This is, and should only be, true for one of the characters. The boss is treated differently to other players and is only faced once the player defeats all of their opponents without losing a single round. Mainyu is our boss. 1 singlePlayerUnlock : 'hog' , This entry tells us what character to unlock when this character successfully defeats every opponent in their singlePlayerSequence . Not every character unlocks another character, so this can be null. Try playing around with some of these settings and see what happens.","title":"Game Data"},{"location":"onboarding/rps_game/the_game_engine/#game-models","text":"This is where we define the various different game objects that we will use to represent players in the game, along with their characters and weapon selections. Most of these classes should be fairly self-explanatory. One thing to note is the RPSFighter : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class RPSFighter { /** * Represents the player's character selection. **/ constructor ( spec ) { this . id = spec . id this . spec = spec // Amount of damage this fighter has taken in the current round this . damage = 0 this . weapons = [ new Rock ( this . spec . stats . rock . baseDamage , { damageModifier : this . spec . stats . rock . damageModifier , damageMitigation : this . spec . stats . rock . damageMitigation }), new Paper ( this . spec . stats . paper . baseDamage , { damageModifier : this . spec . stats . paper . damageModifier , damageMitigation : this . spec . stats . paper . damageMitigation }), new Scissors ( this . spec . stats . scissors . baseDamage , { damageModifier : this . spec . stats . scissors . damageModifier , damageMitigation : this . spec . stats . scissors . damageMitigation }) ] this . currentSelectedWeaponIndex = null // True if the current round is accepting weapon selection from players this . weaponSelectAvailable = false } In it's constructor it loads stats from game_data.js . So we can balance the characters strengths and weaknesses from the data file. Or in other words - it's data driven . A couple of other interesting classes in this file are our bots: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class RPSStrategyBot extends RPSPlayer { /** * Represents an AI player (single player mode) * that uses some basic strategy, as defined in * strategy.js **/ constructor ( id , difficulty ) { super ( id ) this . strategy = getStrategy ( difficulty ) } eventListener ( event ) { if ( event instanceof RPSRoundEvent ) { if ( event . type === RPSRoundEvent . WEAPON_COUNTDOWN && event . data . value === 2 ) { this . fighter . equipWeapon ( this . strategy . getNextSelection ( this . fighter . getCurrentHealthPct ())) } if ( event . type === RPSRoundEvent . ROUND_FINISHED ) { this . strategy . reset () } } } } class RPSRandomBot extends RPSPlayer { /** * Represents an AI player (single player mode) * that simply makes random selection - * !Note! This is one of the most difficult to play against **/ eventListener ( event ) { if ( event instanceof RPSRoundEvent ) { if ( event . type === RPSRoundEvent . WEAPON_COUNTDOWN ) { this . fighter . equipWeapon ( Math . floor ( Math . random () * 3 )) } } } } The RPSRandomBot is used to create a single player enemy that will just make random selections. This is the hardest type of opponent to play against - so this is used by the final boss. The RPSStrategyBot is a little different. This object is used to create a single player enemy that plays according to strategies of varying difficulty. Our AI will always use some repeating pattern. The strategy difficulty dictates how difficult the pattern is to detect and whether the AI will change strategy after taking a certain amount of damage. These are used during single player to create a set of opponents that increase in difficulty as the player progresses.","title":"Game Models"},{"location":"onboarding/rps_game/the_game_engine/#game-play","text":"Open up game_engine/src/game_play.js . This is there the actual game happens. There is a class called RPSGame . This is class is essentially a state management system.","title":"Game Play"},{"location":"onboarding/rps_game/the_game_engine/#game-states","text":"A game have a number of states it can be in: 1 2 3 4 5 6 class RPSGameStates { static get WAITING_FOR_PLAYERS () { return 0 } static get CHARACTER_SELECTION () { return 1 } static get IN_PROGRESS () { return 2 } static get GAME_OVER () { return 3 } }","title":"Game States"},{"location":"onboarding/rps_game/the_game_engine/#waiting_for_players","text":"The game has been created and is now waiting for players to be added.","title":"WAITING_FOR_PLAYERS"},{"location":"onboarding/rps_game/the_game_engine/#character_selection","text":"The game is now waiting for the players to make their character selection.","title":"CHARACTER_SELECTION"},{"location":"onboarding/rps_game/the_game_engine/#in_progress","text":"The game is in progress.","title":"IN_PROGRESS"},{"location":"onboarding/rps_game/the_game_engine/#game_over","text":"The game has ended.","title":"GAME_OVER"},{"location":"onboarding/rps_game/the_game_engine/#rounds","text":"Once a game is in progress it is represented as a series of rounds. A player must win two rounds to win the game. Therefore the minimum number of rounds is 2 and the maximum is 3. Rounds are have a number of states that they progress through during gameplay: 1 2 3 4 5 static get NEW_ROUND () { return 0 } static get COUNTDOWN () { return 1 } static get WAITING_FOR_WEAPON_SELECTION () { return 2 } static get PROCESSING_RESULT () { return 3 } static get FINISHED () { return 4 }","title":"Rounds"},{"location":"onboarding/rps_game/the_game_engine/#new_round","text":"The round has been created.","title":"NEW_ROUND"},{"location":"onboarding/rps_game/the_game_engine/#countdown","text":"The 'start of round' countdown is in progress.","title":"COUNTDOWN"},{"location":"onboarding/rps_game/the_game_engine/#waiting_for_weapon_selection","text":"Players can make their weapon selections.","title":"WAITING_FOR_WEAPON_SELECTION"},{"location":"onboarding/rps_game/the_game_engine/#processing_result","text":"The result of the player's selection are being processed.","title":"PROCESSING_RESULT"},{"location":"onboarding/rps_game/the_game_engine/#finished","text":"The round has finished. A round will enter a cycle of going from WAITING_FOR_WEAPON_SELECTION to PROCESSING_RESULT until the game detects that a player has reached zero health, at which point it will progress to the FINISHED state.","title":"FINISHED"},{"location":"onboarding/rps_game/the_game_engine/#tick","text":"So as you can see there is a logical progression of states that happens in order to make the game run. This progression is very similar in code to what the player experiences: Start game -> Select character -> Start battle -> start round -> select weapon -> Apply damage -> Repeat until health is zero -> End round -> Repeat until one player wins two rounds. But what is actually running this progression? That would be our game tick . The RPSGame object has a method: 1 2 3 tick () { this . stateHandlers [ this . state ]() } This method calls a state handler , which will behave differently depending on the current state of the game. This tick can be called at any desired interval. When the server is running the game it calls 'tick' every second. Single player mode calls it every half second. The speed of the game is based on the tick, because the tick is simply what causes our game states to change from one state to the next. If you want to play with this yourself, open up game_rps/client/src/game_engine_interface.js and find the line: 1 2 3 4 5 6 console . log ( 'Single player game - starting client side tick loop...' ) this . tickTimer = setInterval (() => { if ( ! this . paused ) { this . game . tick () } }, 500 ) That 500 is the 500 millisecond tick for single player. If you increase that value your single player game will run slower. Decrease it and it will run faster. That's about as deep as I want to go into the game for this onboarding course. Next we will look at the game design - understanding the gameplay will help you reason about the code.","title":"Tick"},{"location":"onboarding/rps_game/working_with_the_game/","text":"Phaser Phaser is our game engine of choice. It's a popular 2D engine with an active and engaged community that is regularly updated. Before proceeding it's worth having a look through some of the official documentation and getting familiar with the layout of the site - you're going to need to be able to find your way around in there. Prerequisites At this point you should have your full Varcade Games stack up and running, but before proceeding let's double check. From your build_tools directory run: 1 make ps You should see something like: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 Name Command State Ports ----------------------------------------------------------------------------------------------------------------- game-portal /bin/sh -c gunicorn game_p ... Up 0 .0.0.0:8000->8000/tcp game-portal-client docker-entrypoint.sh npm r ... Up 0 .0.0.0:8002->8002/tcp game-rps docker-entrypoint.sh /bin/ ... Up 0 .0.0.0:8080->8080/tcp, 0 .0.0.0:8085->8085/tcp game-rps-client docker-entrypoint.sh /bin/ ... Up 0 .0.0.0:8090->8090/tcp gameportaldb docker-entrypoint.sh mysqld Up 0 .0.0.0:3306->3306/tcp, 33060 /tcp grafana /run.sh Up 0 .0.0.0:3001->3000/tcp matchmaker /bin/sh -c gunicorn --relo ... Up 0 .0.0.0:5050->5050/tcp matchmaker-worker /bin/sh -c python game_wor ... Up 0 .0.0.0:5051->5051/tcp prometheus /bin/prometheus --config.f ... Up 0 .0.0.0:9090->9090/tcp redis-db docker-entrypoint.sh redis ... Up 0 .0.0.0:6379->6379/tcp stats-tracker /bin/sh -c gunicorn --relo ... Up 0 .0.0.0:5000->5000/tcp stats-tracker-worker /bin/sh -c python stats_wo ... Up 0 .0.0.0:5002->5002/tcp The line you're interested in is: 1 game-rps-client docker-entrypoint.sh /bin/ ... Up 0 .0.0.0:8090->8090/tcp This is our dev build of the game client. Notice at the end of the line: 1 0 .0.0.0:8090 This is telling us that the container is listening on port 8090... so let's try it. Open up your browser and navigate to localhost:8090 . You should be greeted by this page: What we've done is basically set up a dev server that hosts the game client so that we can play and work on the game without needing to run the whole Varcade Games stack. Our game can be built and played completely in isolation - which makes our lives a bit easier by allowing us to do more of that 'hot reloading' we saw earlier when working on the game portal. If you want to view logs for our game client you can do so with the command: 1 make logs a = game-rps-client My output looks like this right now: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 game-rps-client | \u2139 \uff62wdm\uff63: Compiled successfully. game-rps-client | \u2139 \uff62wdm\uff63: Compiling... game-rps-client | \u2139 \uff62wdm\uff63: Hash: d3673e4282f220a5448c game-rps-client | Version: webpack 4 .46.0 game-rps-client | Time: 482ms game-rps-client | Built at: 08 /22/2021 2 :19:54 PM game-rps-client | Asset Size Chunks Chunk Names game-rps-client | index.html 8 .57 KiB [ emitted ] game-rps-client | main.js 19 .3 MiB main [ emitted ] main game-rps-client | + 86 hidden assets game-rps-client | Entrypoint main = main.js game-rps-client | [ ./src/scenes/fight_screen.js ] 20 KiB { main } [ built ] game-rps-client | + 155 hidden modules game-rps-client | Child html-webpack-plugin for \"index.html\" : game-rps-client | 1 asset game-rps-client | Entrypoint undefined = index.html game-rps-client | 4 modules game-rps-client | \u2139 \uff62wdm\uff63: Compiled successfully. Which is telling me what a recent change to a file triggered a recompilation, which was a success. This should feel pretty familiar - I've tried to make interactions with the various different components as consistent as possible. Let's try it out properly by breaking something and then fixing it. Open up game_rps/client/src/index.js and comment out the second import like so: 1 //import { BootScene } from './scenes/boot_scene.js' Now open up your browser again. Everything should be broken, meaning you are left with a more or less blank screen: To understand what is going on here we need to open up the browser console again. You should see an error log that looks like this: 1 2 3 4 5 6 7 8 9 javascript Uncaught ReferenceError: BootScene is not defined at eval (index.js?b635:22) at Module../src/index.js (main.js:1663) at __webpack_require__ (main.js:20) at Object.0 (main.js:1843) at __webpack_require__ (main.js:20) at main.js:84 at main.js:87 Unsurprisingly the error is telling is that BootScene is not defined . This is because we just commented out the line of code that imports the BootScene (we'll talk about what the BootScene is soon). Remove the comment and take another look at your browser. The page should have reloaded automatically and start working again. And that's it - we can now player the game on a dev client, make changes and see the impact. Next we'll look at some of the key concepts around how we've used Phaser to create Rock Paper Scissors Apocalypse. Notes: Sometimes the page might not auto-reload after making a change. This could be after you add a new file (due to permission issues with your mounted directory), after you add a new dependency through NPM or if you make changes outside of the main src directory. In this case you can restart the image by running the following from your build_tools directory: make restart a=game-rps-client . If that doesn't work, you may need to rebuild with make build a=game-rps-client before reloading.","title":"Working with Rock Paper Scissors Apocalypse"},{"location":"onboarding/rps_game/working_with_the_game/#phaser","text":"Phaser is our game engine of choice. It's a popular 2D engine with an active and engaged community that is regularly updated. Before proceeding it's worth having a look through some of the official documentation and getting familiar with the layout of the site - you're going to need to be able to find your way around in there.","title":"Phaser"},{"location":"onboarding/rps_game/working_with_the_game/#prerequisites","text":"At this point you should have your full Varcade Games stack up and running, but before proceeding let's double check. From your build_tools directory run: 1 make ps You should see something like: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 Name Command State Ports ----------------------------------------------------------------------------------------------------------------- game-portal /bin/sh -c gunicorn game_p ... Up 0 .0.0.0:8000->8000/tcp game-portal-client docker-entrypoint.sh npm r ... Up 0 .0.0.0:8002->8002/tcp game-rps docker-entrypoint.sh /bin/ ... Up 0 .0.0.0:8080->8080/tcp, 0 .0.0.0:8085->8085/tcp game-rps-client docker-entrypoint.sh /bin/ ... Up 0 .0.0.0:8090->8090/tcp gameportaldb docker-entrypoint.sh mysqld Up 0 .0.0.0:3306->3306/tcp, 33060 /tcp grafana /run.sh Up 0 .0.0.0:3001->3000/tcp matchmaker /bin/sh -c gunicorn --relo ... Up 0 .0.0.0:5050->5050/tcp matchmaker-worker /bin/sh -c python game_wor ... Up 0 .0.0.0:5051->5051/tcp prometheus /bin/prometheus --config.f ... Up 0 .0.0.0:9090->9090/tcp redis-db docker-entrypoint.sh redis ... Up 0 .0.0.0:6379->6379/tcp stats-tracker /bin/sh -c gunicorn --relo ... Up 0 .0.0.0:5000->5000/tcp stats-tracker-worker /bin/sh -c python stats_wo ... Up 0 .0.0.0:5002->5002/tcp The line you're interested in is: 1 game-rps-client docker-entrypoint.sh /bin/ ... Up 0 .0.0.0:8090->8090/tcp This is our dev build of the game client. Notice at the end of the line: 1 0 .0.0.0:8090 This is telling us that the container is listening on port 8090... so let's try it. Open up your browser and navigate to localhost:8090 . You should be greeted by this page: What we've done is basically set up a dev server that hosts the game client so that we can play and work on the game without needing to run the whole Varcade Games stack. Our game can be built and played completely in isolation - which makes our lives a bit easier by allowing us to do more of that 'hot reloading' we saw earlier when working on the game portal. If you want to view logs for our game client you can do so with the command: 1 make logs a = game-rps-client My output looks like this right now: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 game-rps-client | \u2139 \uff62wdm\uff63: Compiled successfully. game-rps-client | \u2139 \uff62wdm\uff63: Compiling... game-rps-client | \u2139 \uff62wdm\uff63: Hash: d3673e4282f220a5448c game-rps-client | Version: webpack 4 .46.0 game-rps-client | Time: 482ms game-rps-client | Built at: 08 /22/2021 2 :19:54 PM game-rps-client | Asset Size Chunks Chunk Names game-rps-client | index.html 8 .57 KiB [ emitted ] game-rps-client | main.js 19 .3 MiB main [ emitted ] main game-rps-client | + 86 hidden assets game-rps-client | Entrypoint main = main.js game-rps-client | [ ./src/scenes/fight_screen.js ] 20 KiB { main } [ built ] game-rps-client | + 155 hidden modules game-rps-client | Child html-webpack-plugin for \"index.html\" : game-rps-client | 1 asset game-rps-client | Entrypoint undefined = index.html game-rps-client | 4 modules game-rps-client | \u2139 \uff62wdm\uff63: Compiled successfully. Which is telling me what a recent change to a file triggered a recompilation, which was a success. This should feel pretty familiar - I've tried to make interactions with the various different components as consistent as possible. Let's try it out properly by breaking something and then fixing it. Open up game_rps/client/src/index.js and comment out the second import like so: 1 //import { BootScene } from './scenes/boot_scene.js' Now open up your browser again. Everything should be broken, meaning you are left with a more or less blank screen: To understand what is going on here we need to open up the browser console again. You should see an error log that looks like this: 1 2 3 4 5 6 7 8 9 javascript Uncaught ReferenceError: BootScene is not defined at eval (index.js?b635:22) at Module../src/index.js (main.js:1663) at __webpack_require__ (main.js:20) at Object.0 (main.js:1843) at __webpack_require__ (main.js:20) at main.js:84 at main.js:87 Unsurprisingly the error is telling is that BootScene is not defined . This is because we just commented out the line of code that imports the BootScene (we'll talk about what the BootScene is soon). Remove the comment and take another look at your browser. The page should have reloaded automatically and start working again. And that's it - we can now player the game on a dev client, make changes and see the impact. Next we'll look at some of the key concepts around how we've used Phaser to create Rock Paper Scissors Apocalypse.","title":"Prerequisites"},{"location":"onboarding/rps_game/working_with_the_game/#notes","text":"Sometimes the page might not auto-reload after making a change. This could be after you add a new file (due to permission issues with your mounted directory), after you add a new dependency through NPM or if you make changes outside of the main src directory. In this case you can restart the image by running the following from your build_tools directory: make restart a=game-rps-client . If that doesn't work, you may need to rebuild with make build a=game-rps-client before reloading.","title":"Notes:"},{"location":"onboarding/rps_game_server/intro/","text":"We're about to venture deep into the server side of things... Server development can be intimidating for a number of reasons: No real visual indicators of progress (like with UI development) There are a lot of pitfalls and challenges to deal with There are a lot of concepts to learn beyond coding Networking Infrastructure Security Scalability Data management Data consistency We will touch all of those things to some degree, but don't get bogged down in all of that just yet. Let's instead focus on how we connect two players together for a nice game of Rock Paper Scissors. All of the code of this module lives in game_rps/server/game_server , so open it up in your text editor/IDE and lets get started.","title":"Introduction"},{"location":"onboarding/rps_game_server/key_concepts/","text":"Before we look at the actual code, let's take a high level look at the design of the system and some of the important concepts at play. Game State First off, the Rock Paper Scissors Apocalypse (RPSA) game server is a stateful server . This means that it keeps all of its state in memory. This means that all of the games being played on the server are not saved to any persistent storage (like a database or hard disk). If the server dies all of the games are lost. This is a trade off I was happy to make in this case, because games are transient by nature. They are quick and self contained. If you're playing a game and server dies you only lose the progress for that game - it's not that big a deal. The benefit we get is that the server is quite simple and can be quite fast - since everything it needs is right there in memory. But what is the game state? Put simply the game state is: The set of all games being played at any moment in time, and the players that are playing those games. To understand exactly how this works lets go back to some of the sequence diagrams we saw earlier in the documentation. This time I've simplified them so that there are no Varcade Games components or Matchmaker components. Right now we're only interested in the game, which can be run completely standalone . Remember that, as it is much easier to work on just the game, without worrying about the game portal. Creating a game Take a moment to digest that image. The first thing that happens is that the game client creates a new game. It does this by sending a request to the game server. This is a normal HTTP request - just like any request you send through your browser. Note When a game is running from within Varcade Games it does not directly call the game server to create a game. The Matchmaker does that. In fact we actively hide this ability from game clients when deploying live. We want the matchmaker to act as a sort of security guard when it comes to creating and managing games. When the game server receives a request to create a game it will do exactly that. It will create a game (we'll see exactly how in the code later) and it will generate a token for that game. This token is how we control exactly who can connect to and play the game that was just created. Once the client has a token it can go ahead and connect to the game. This is where things change - this time the client will talk to the server over a Websocket . Earlier when we create the game we used the standard HTTP request-response model. This is where a client sends a request to a server, the server then does something and responds with an answer. That's it. It's a single interaction. When we open a socket connection (in this case a websocket ) that we're doing is creating a connection between the client and server. Once this connection is established, the client and server can freely send data to eachother as they please. Think about it like mail vs telephone. If you send someone a letter you have to wait for it to be delivered. They read it. Then they respond. If you call someone on the phone, you have a connection to them where you can both communicate at will. In our game client, once the socket connection has been created we can go ahead and allow the player that created the game to make their character selection. Once they do that, they need to sit and wait for another player to join. Note We'll talk about what happens when no one joins later when we get to the Matchmaker. Joining a game The join game flow is quite similar, except the first thing the player has to do is get a list of available games to join. Once they have that list they can ask the server join one of them (the server may say no, if for example the game has already reached max capacity). Once we have a token the rest of the flow is the same are the creation flow. The joining player selects their character. Once both players have their selection made the game can begin. At this point we have a server with an active game and two active websocket connections. Now we're ready to dig into the actual system design - what is actually happening behind all of those concepts we've just gone through?","title":"Key Concepts"},{"location":"onboarding/rps_game_server/key_concepts/#game-state","text":"First off, the Rock Paper Scissors Apocalypse (RPSA) game server is a stateful server . This means that it keeps all of its state in memory. This means that all of the games being played on the server are not saved to any persistent storage (like a database or hard disk). If the server dies all of the games are lost. This is a trade off I was happy to make in this case, because games are transient by nature. They are quick and self contained. If you're playing a game and server dies you only lose the progress for that game - it's not that big a deal. The benefit we get is that the server is quite simple and can be quite fast - since everything it needs is right there in memory. But what is the game state? Put simply the game state is: The set of all games being played at any moment in time, and the players that are playing those games. To understand exactly how this works lets go back to some of the sequence diagrams we saw earlier in the documentation. This time I've simplified them so that there are no Varcade Games components or Matchmaker components. Right now we're only interested in the game, which can be run completely standalone . Remember that, as it is much easier to work on just the game, without worrying about the game portal.","title":"Game State"},{"location":"onboarding/rps_game_server/key_concepts/#creating-a-game","text":"Take a moment to digest that image. The first thing that happens is that the game client creates a new game. It does this by sending a request to the game server. This is a normal HTTP request - just like any request you send through your browser. Note When a game is running from within Varcade Games it does not directly call the game server to create a game. The Matchmaker does that. In fact we actively hide this ability from game clients when deploying live. We want the matchmaker to act as a sort of security guard when it comes to creating and managing games. When the game server receives a request to create a game it will do exactly that. It will create a game (we'll see exactly how in the code later) and it will generate a token for that game. This token is how we control exactly who can connect to and play the game that was just created. Once the client has a token it can go ahead and connect to the game. This is where things change - this time the client will talk to the server over a Websocket . Earlier when we create the game we used the standard HTTP request-response model. This is where a client sends a request to a server, the server then does something and responds with an answer. That's it. It's a single interaction. When we open a socket connection (in this case a websocket ) that we're doing is creating a connection between the client and server. Once this connection is established, the client and server can freely send data to eachother as they please. Think about it like mail vs telephone. If you send someone a letter you have to wait for it to be delivered. They read it. Then they respond. If you call someone on the phone, you have a connection to them where you can both communicate at will. In our game client, once the socket connection has been created we can go ahead and allow the player that created the game to make their character selection. Once they do that, they need to sit and wait for another player to join. Note We'll talk about what happens when no one joins later when we get to the Matchmaker.","title":"Creating a game"},{"location":"onboarding/rps_game_server/key_concepts/#joining-a-game","text":"The join game flow is quite similar, except the first thing the player has to do is get a list of available games to join. Once they have that list they can ask the server join one of them (the server may say no, if for example the game has already reached max capacity). Once we have a token the rest of the flow is the same are the creation flow. The joining player selects their character. Once both players have their selection made the game can begin. At this point we have a server with an active game and two active websocket connections. Now we're ready to dig into the actual system design - what is actually happening behind all of those concepts we've just gone through?","title":"Joining a game"},{"location":"onboarding/rps_game_server/playing_with_others/","text":"At this point you should have your Varcade Games stack running. Point your browser at localhost:8090 to get access to the standalone game client, just like we did earlier when we talked about single player mode. When you select Multiplayer in the standalone client you get access to some additional debug UI that allows you to create your own multiplayer games, without needing Varcade Games and its matchmaker. You will find this to be very useful for testing multiplayer functionality as it will drastically increase you ability to make changes and test those changes quickly. Creating a game Select Multiplayer mode from the main menu and you will see a text box appear below the game. Enter a 'User id' (this can be any valid string) and hit the 'Select Name' button. Now you should have the option to create a game: Enter a game ID (again, any valid string will do - I went with 'test') then hit 'Create game'. Once you've done this the game client should change scene over to the character selection scene. Select a character and you should see this: We're halfway there... Joining a game Next open up a new tab in your browser and navigate to localhost:8090 . Select Multiplayer mode, just like before, and enter a different User id. Once you submit your user id you should see a list of available games to join under 'Active Games': Click the join link to join the game. This should cause the client to transition to the character select scene. Once you select your character, both clients should update and show the VS scene, then the game. Here I have set up two browser windows side by side so I can play against myself: Give it a try! Once you've played a game or two also try refreshing one or both of the browser windows. What happens if the host disconnects? What happens if the person that joined disconnects? It's worth spending a bit of time playing around and breaking things here.","title":"Playing with Others"},{"location":"onboarding/rps_game_server/playing_with_others/#creating-a-game","text":"Select Multiplayer mode from the main menu and you will see a text box appear below the game. Enter a 'User id' (this can be any valid string) and hit the 'Select Name' button. Now you should have the option to create a game: Enter a game ID (again, any valid string will do - I went with 'test') then hit 'Create game'. Once you've done this the game client should change scene over to the character selection scene. Select a character and you should see this: We're halfway there...","title":"Creating a game"},{"location":"onboarding/rps_game_server/playing_with_others/#joining-a-game","text":"Next open up a new tab in your browser and navigate to localhost:8090 . Select Multiplayer mode, just like before, and enter a different User id. Once you submit your user id you should see a list of available games to join under 'Active Games': Click the join link to join the game. This should cause the client to transition to the character select scene. Once you select your character, both clients should update and show the VS scene, then the game. Here I have set up two browser windows side by side so I can play against myself: Give it a try! Once you've played a game or two also try refreshing one or both of the browser windows. What happens if the host disconnects? What happens if the person that joined disconnects? It's worth spending a bit of time playing around and breaking things here.","title":"Joining a game"},{"location":"onboarding/rps_game_server/system_design/","text":"The game server doesn't actually have all that much code. The game engine is a separately library that is shared between client and server, so the server doesn't need to worry about gameplay really. What it needs to do is create games and listen for player interactions and send messages and forth between the server and the game client. That's the server's main priority. Structure The diagram below shows some of the layers and interaction you will find in the server code. Note There is also an index.js file. It is the file that the NodeJS server launches. It just has some basic startup configuration in it. We don't need to consider it for now. The HTTP Server So the entry point to our game server is app.js . It's here that you can see the various other game server components getting initialized: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // Metrics const metricsMiddleware = promBundle ({ includePath : true , httpDurationMetricName : 'game_rps_server_http_request_duration' }) // Prometheus middleware // HTTP Server const app = express () app . use ( metricsMiddleware ) app . use ( cors ()) app . use ( express . json ()) app . use ( httpLogger ) // Rock Paper Scissors Game Server const rpsGameServer = new RPS . RPSServer ( promBundle . promClient ) First up there are some metrics, so we can monitor the game server and make sure it's performing ok. Then the HTTP server we need for game management. We are using a popular HTTP server for NodeJS called Express . You can check out the official docs here . If you look down below the initialization section you will see where we set up 'routing' for Express JS. This is how we register endpoints for our game client and matchmaker to connect to when they want to create or join a game. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 app . post ( '/create_game' , function ( req , res ) { logger . info ( 'Received create game request: ${JSON.stringify(req.body)}' ) if ( ! validateGameRequest ( req , res )) { return } try { const gameData = rpsGameServer . createGame ( req . body . gameId , req . body . userId , req . body . username ) res . json ( gameData ) } catch ( err ) { if ( err instanceof RPSErrors . ValidationError ) { logger . warn ( 'Unable to create a new game, error message: ${err.message}' ) sendErrorResponse ( res , 400 , err . message ) } else { logger . error ( 'Unable to create a new game, error message: ${err.message}' ) sendErrorResponse ( res , 500 , 'An unexpected error occurred while trying to join the game.' ) } } }) Here we're adding a new endpoint to the app object, which is our reference to an Express server. This endpoint will accept 'POST' requests from clients that send requests to '/create_game'. The Game Server Once our metrics and HTTP server are set up we can create the game server: 1 const rpsGameServer = new RPS . RPSServer ( promBundle . promClient ) RPSServer can be found in game_server/rps.js . It is what connects players to games and manages the various events that are fired during a game. This makes it one of the more complex pieces of code in the project. But don't worry about that, how it works is pretty straight forward. RPSServer has the following member variables: 1 2 this . activeGames = {} // Maps a game ID to a GameHandler.MultiPlayerGame object this . tokenGameMap = {} // Maps game tokens to game IDs When we create a game we generate a token. Then we add token: game_id to the tokenGameMap object. Finally we add game_id: game to the activeGames object. Remember our sequence diagram earlier, where the Game Server returned a token to the game client? That is this token. When a player connects to a game server a token is supplied. The game server can then map that to a game ID and look up the corresponding game. Joining a game We do this because game IDs are shared with the Game Portal client, so nefarious players could potentially connect to games directly without going through the matchmaker. Most of what this class is doing is initializing the websocket connection, handling messages coming from the game clients and dealing with error scenarios, like if a connection drops. So we're still not playing the game yet - for that we need to once again consider the Game Engine.","title":"System Design"},{"location":"onboarding/rps_game_server/system_design/#structure","text":"The diagram below shows some of the layers and interaction you will find in the server code. Note There is also an index.js file. It is the file that the NodeJS server launches. It just has some basic startup configuration in it. We don't need to consider it for now.","title":"Structure"},{"location":"onboarding/rps_game_server/system_design/#the-http-server","text":"So the entry point to our game server is app.js . It's here that you can see the various other game server components getting initialized: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // Metrics const metricsMiddleware = promBundle ({ includePath : true , httpDurationMetricName : 'game_rps_server_http_request_duration' }) // Prometheus middleware // HTTP Server const app = express () app . use ( metricsMiddleware ) app . use ( cors ()) app . use ( express . json ()) app . use ( httpLogger ) // Rock Paper Scissors Game Server const rpsGameServer = new RPS . RPSServer ( promBundle . promClient ) First up there are some metrics, so we can monitor the game server and make sure it's performing ok. Then the HTTP server we need for game management. We are using a popular HTTP server for NodeJS called Express . You can check out the official docs here . If you look down below the initialization section you will see where we set up 'routing' for Express JS. This is how we register endpoints for our game client and matchmaker to connect to when they want to create or join a game. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 app . post ( '/create_game' , function ( req , res ) { logger . info ( 'Received create game request: ${JSON.stringify(req.body)}' ) if ( ! validateGameRequest ( req , res )) { return } try { const gameData = rpsGameServer . createGame ( req . body . gameId , req . body . userId , req . body . username ) res . json ( gameData ) } catch ( err ) { if ( err instanceof RPSErrors . ValidationError ) { logger . warn ( 'Unable to create a new game, error message: ${err.message}' ) sendErrorResponse ( res , 400 , err . message ) } else { logger . error ( 'Unable to create a new game, error message: ${err.message}' ) sendErrorResponse ( res , 500 , 'An unexpected error occurred while trying to join the game.' ) } } }) Here we're adding a new endpoint to the app object, which is our reference to an Express server. This endpoint will accept 'POST' requests from clients that send requests to '/create_game'.","title":"The HTTP Server"},{"location":"onboarding/rps_game_server/system_design/#the-game-server","text":"Once our metrics and HTTP server are set up we can create the game server: 1 const rpsGameServer = new RPS . RPSServer ( promBundle . promClient ) RPSServer can be found in game_server/rps.js . It is what connects players to games and manages the various events that are fired during a game. This makes it one of the more complex pieces of code in the project. But don't worry about that, how it works is pretty straight forward. RPSServer has the following member variables: 1 2 this . activeGames = {} // Maps a game ID to a GameHandler.MultiPlayerGame object this . tokenGameMap = {} // Maps game tokens to game IDs When we create a game we generate a token. Then we add token: game_id to the tokenGameMap object. Finally we add game_id: game to the activeGames object. Remember our sequence diagram earlier, where the Game Server returned a token to the game client? That is this token. When a player connects to a game server a token is supplied. The game server can then map that to a game ID and look up the corresponding game.","title":"The Game Server"},{"location":"onboarding/rps_game_server/system_design/#joining-a-game","text":"We do this because game IDs are shared with the Game Portal client, so nefarious players could potentially connect to games directly without going through the matchmaker. Most of what this class is doing is initializing the websocket connection, handling messages coming from the game clients and dealing with error scenarios, like if a connection drops. So we're still not playing the game yet - for that we need to once again consider the Game Engine.","title":"Joining a game"},{"location":"onboarding/rps_game_server/the_game_engine/","text":"I've mentioned a few times how the game engine is shared between the client and server. The MultiPlayerGame class in game_server/game_handler.js is what creates and runs the actual game logic. It is the server side equivalent of the client side game_engine_interface file we looked at on the client. The gameplay Player Input In single player mode user input is easy. Players click with their mouse and we handle it. In multi player we need to send that click to the server and then send it out to the other player. In the constructor of the MultiPlayerGame class you can see where we set up some functions to handle this. 1 2 3 4 5 this . messageHandlers = { select_fighter : ( conn , msg ) => this . handleSelectFighter ( conn , msg ), start_battle : ( conn , msg ) => this . handleStartBattle ( conn , msg ), select_weapon : ( conn , msg ) => this . handleSelectWeapon ( conn , msg ) } The three entries in this messageHandlers object represent the different possible player inputs. Players only really have two interactions with the game. They select a fighter and then choose between rock, paper and scissors on a loop. start_battle is a message that clients send to signal that they are ready to fight. We need to do this so that we can sync up the beginning of the battle scene. We won't go too deep on the rest of the code here as that warrants a course of it's own, and we will be back here once we get to the Matchmaker. You should absolutely explore it yourself though, try get a sense of what is going on in there.","title":"The Game Engine"},{"location":"onboarding/rps_game_server/the_game_engine/#the-gameplay","text":"","title":"The gameplay"},{"location":"onboarding/rps_game_server/the_game_engine/#player-input","text":"In single player mode user input is easy. Players click with their mouse and we handle it. In multi player we need to send that click to the server and then send it out to the other player. In the constructor of the MultiPlayerGame class you can see where we set up some functions to handle this. 1 2 3 4 5 this . messageHandlers = { select_fighter : ( conn , msg ) => this . handleSelectFighter ( conn , msg ), start_battle : ( conn , msg ) => this . handleStartBattle ( conn , msg ), select_weapon : ( conn , msg ) => this . handleSelectWeapon ( conn , msg ) } The three entries in this messageHandlers object represent the different possible player inputs. Players only really have two interactions with the game. They select a fighter and then choose between rock, paper and scissors on a loop. start_battle is a message that clients send to signal that they are ready to fight. We need to do this so that we can sync up the beginning of the battle scene. We won't go too deep on the rest of the code here as that warrants a course of it's own, and we will be back here once we get to the Matchmaker. You should absolutely explore it yourself though, try get a sense of what is going on in there.","title":"Player Input"},{"location":"onboarding/varcade_games/adding_a_game/","text":"Adding a game to Varcade Games Navigate your browser to localhost:8000/admin . You should be greeted by a login page. Use the credentials that you provided in the early step where you ran ./manage.py createsuperuser . Once logged in you should see a menu that looks like this: Click the add link under the GAMES category. Fill in all of the fields with dummy data, for example: Game id: test_game Name: My Game Desc: A great game that you should play! Client url: empty Cover art: See below Game type: SinglePlayerOnly Game State: Coming Soon Adding Cover Art There is some sample cover art in the rps_game project. In VSCode you will find this file in game_rps/client/assets/exrps_cover.jpg . On Windows This might be a bit confusing on Windows. The file we want to upload to our browser lives on our Ubuntu instance, so how do we actually access it from Windows? In VSCode you can right click the image and select reveal in file explorer . This will open up a window showing the folder that contains the file. At the top of the window is a path to the file: Once you click the path it will turn into a text field that you can copy and paste: Copy that path and then select the browse button in the admin interface. You can now paste the image page in the upload window that pops up: Hit the save button and you're done. All that's left is to head back over to localhost:8002 and play the game.","title":"Adding a game"},{"location":"onboarding/varcade_games/adding_a_game/#adding-a-game-to-varcade-games","text":"Navigate your browser to localhost:8000/admin . You should be greeted by a login page. Use the credentials that you provided in the early step where you ran ./manage.py createsuperuser . Once logged in you should see a menu that looks like this: Click the add link under the GAMES category. Fill in all of the fields with dummy data, for example: Game id: test_game Name: My Game Desc: A great game that you should play! Client url: empty Cover art: See below Game type: SinglePlayerOnly Game State: Coming Soon","title":"Adding a game to Varcade Games"},{"location":"onboarding/varcade_games/adding_a_game/#adding-cover-art","text":"There is some sample cover art in the rps_game project. In VSCode you will find this file in game_rps/client/assets/exrps_cover.jpg .","title":"Adding Cover Art"},{"location":"onboarding/varcade_games/adding_a_game/#on-windows","text":"This might be a bit confusing on Windows. The file we want to upload to our browser lives on our Ubuntu instance, so how do we actually access it from Windows? In VSCode you can right click the image and select reveal in file explorer . This will open up a window showing the folder that contains the file. At the top of the window is a path to the file: Once you click the path it will turn into a text field that you can copy and paste: Copy that path and then select the browse button in the admin interface. You can now paste the image page in the upload window that pops up: Hit the save button and you're done. All that's left is to head back over to localhost:8002 and play the game.","title":"On Windows"},{"location":"onboarding/varcade_games/admin/","text":"The Admin Panel In order to follow along with this section you'll need to have the project up and running - so if you haven't done that, you should get it all setup before continuing. The admin panel is a part of the Website project. In you browser, navigate to localhost:8000/admin/ . If you're not already logged in here you will be greeted with a login screen. Log in with the credentials you provided when initially setting up the project and you should be greeted with something like this: You get this out of the box with Django, and it's one of the reasons I decided to go with Django for the server side of Varcade Games. Django Admin Some of these menu options are there by default, such as ACCOUNTS and SITES , but two of them are specific to Varcade Games. Games This section is where we add games, as you should have done already while setting up the project. Profiles In this section we can view user profiles, which are automatically created whenever a new account is created - more on this later. Basically as admin of the website you can view and manipulate player accounts as needed - and since the internet is what it is, it will be needed. The Code Let's have a look at the code behind all of this, because we've already used the admin panel enough to more or less know what it's about. Games If you open up website/server/game_portal/games/admin.py you should see the following code: 1 2 3 4 from django.contrib import admin from .models import Game admin . site . register ( Game ) And that's it. That's more or less all we need to do in order to add a custom section to the Django admin panel. But before you do that you need to create the model that you want to represent in the first place. All you can see from the imports above, this Game model is in the models.py file. The Game model is a database model that describes a single game in Varcade Games and it looks like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Game ( models . Model ): class GameTypes ( models . TextChoices ): SINGLE_PLAYER_ONLY = \"SPO\" , \"SinglePlayerOnly\" MULTI_PLAYER_ONLY = \"MPO\" , \"MultiPlayerOnly\" MULTI_AND_SINGLE_PLAYER = \"MSP\" , \"MultiAndSinglePlayer\" class GameState ( models . TextChoices ): ACTIVE = \"ACT\" , \"Active\" INACTIVE = \"INA\" , \"Inactive\" COMING_SOON = \"CMS\" , \"ComingSoon\" game_id : models . CharField = models . CharField ( max_length = 10 ) name : models . CharField = models . CharField ( max_length = 40 ) desc : models . CharField = models . CharField ( max_length = 180 ) client_url : models . CharField = models . CharField ( max_length = 160 ) cover_art : models . ImageField = models . ImageField ( upload_to = \"images\" , null = True ) banner_art : models . ImageField = models . ImageField ( upload_to = \"images\" , null = True ) stats_config : models . FileField = models . FileField ( upload_to = \"stats_config\" , null = True ) game_type : models . CharField = models . CharField ( max_length = 3 , choices = GameTypes . choices , default = GameTypes . SINGLE_PLAYER_ONLY ) game_state : models . CharField = models . CharField ( max_length = 3 , choices = GameState . choices , default = GameState . INACTIVE ) def __str__ ( self ) -> str : return self . name Have a look at all of those instance variables in the Game class: 1 2 3 4 5 game_id name desc client_url ... Are they familiar? They should be - take another look at the admin panel. Django automatically maps the fields of our database model to the admin panel, provided we have registered it - which we did in our admin.py file. For all of this to work our model needs to extend models.Model : 1 class Game ( models . Model ): This tells Django that our Game object will be a database model. Each of the instance variables is a Django specific type that Django knows how to handle. The type of the model's fields also dictates how they are rendered in the admin panel. The models.ImageField is rendered as an upload field in UI. The models.Charfield that have choices associated with them are rendered as dropdowns etc... Most of these fields are pretty straight forward. CharFields are just strings that Django can store in a database table. But the same is not true for the ImageField or the FileField. We need to store these files somewhere. Django will only store the path of that file in the database. To understands how this works we need to have a look at the settings file. The Setting File The settings.py is the core of our Django project. Remember back to the intro for this section, where I shared the following snippet from the Django homepage: Django is a high-level Python web framework that encourages rapid development and clean, pragmatic design. Built by experienced developers, it takes care of much of the hassle of web development, so you can focus on writing your app... It is through the setting.py that we will harness the power of Django. It's the interface through which we configure Django so that it can do the heavy lifting. Go ahead and open up website/server/game_portal/game_portal/setting.py . The section we're interested in right now is: 1 2 3 4 5 6 7 8 9 if DEBUG : CORS_ALLOW_ALL_ORIGINS = True STATIC_ROOT = os . path . join ( BASE_DIR , \"staticfiles\" ) MEDIA_ROOT = os . path . join ( BASE_DIR , \"media/\" ) else : CORS_ALLOWED_ORIGINS = [ \"https://varcade-games.com\" ] STATIC_ROOT = \"/var/lib/game_portal/data/staticfiles\" MEDIA_ROOT = \"/var/lib/game_portal/data/media/\" MEDIA_URL = \"https://api.varcade-games.com/media/\" More specifically we are interested in the MEDIA_ROOT and MEDIA_URL . The MEDIA_ROOT setting tells Django where it can store files locally. So any files we upload via the admin webpanel will go here. The MEDIA_URL setting tells Django where to request these files from. So why do we have this DEBUG condition and two different values for these settings? As the name implies, one is our debug config - which is active whenever we're running on our local dev server. However, when the website is deployed to a live server we need to tweak things a bit - but don't worry about this for now, we'll get to that later. For now - files will be saved to your game-portal container in the BASE_DIR - which correspond to website/server/game_portal directory. In fact - have a look in your file explorer right now. If you are running Varcade Games at the moment and have your local file system mounted on to the running Varcade Games container then you should see that media directory - and it should contain the files you uploaded when configuring Rock Paper Scissors Apocalypse . Summary So that's how we configure and store games. We create a class that is an instance of the Django model. We register that class with the Django admin system. We tell Django where we want static files to go (uploaded images etc...). Once all of that is done we can view our class in the admin panel and create/delete/modify data models as needed via that interface. Now that we have a game defined - how does it actually end up embedded in Varcade Games? That's what we will explore next.","title":"The Admin panel"},{"location":"onboarding/varcade_games/admin/#the-admin-panel","text":"In order to follow along with this section you'll need to have the project up and running - so if you haven't done that, you should get it all setup before continuing. The admin panel is a part of the Website project. In you browser, navigate to localhost:8000/admin/ . If you're not already logged in here you will be greeted with a login screen. Log in with the credentials you provided when initially setting up the project and you should be greeted with something like this: You get this out of the box with Django, and it's one of the reasons I decided to go with Django for the server side of Varcade Games.","title":"The Admin Panel"},{"location":"onboarding/varcade_games/admin/#django-admin","text":"Some of these menu options are there by default, such as ACCOUNTS and SITES , but two of them are specific to Varcade Games.","title":"Django Admin"},{"location":"onboarding/varcade_games/admin/#games","text":"This section is where we add games, as you should have done already while setting up the project.","title":"Games"},{"location":"onboarding/varcade_games/admin/#profiles","text":"In this section we can view user profiles, which are automatically created whenever a new account is created - more on this later. Basically as admin of the website you can view and manipulate player accounts as needed - and since the internet is what it is, it will be needed.","title":"Profiles"},{"location":"onboarding/varcade_games/admin/#the-code","text":"Let's have a look at the code behind all of this, because we've already used the admin panel enough to more or less know what it's about.","title":"The Code"},{"location":"onboarding/varcade_games/admin/#games_1","text":"If you open up website/server/game_portal/games/admin.py you should see the following code: 1 2 3 4 from django.contrib import admin from .models import Game admin . site . register ( Game ) And that's it. That's more or less all we need to do in order to add a custom section to the Django admin panel. But before you do that you need to create the model that you want to represent in the first place. All you can see from the imports above, this Game model is in the models.py file. The Game model is a database model that describes a single game in Varcade Games and it looks like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Game ( models . Model ): class GameTypes ( models . TextChoices ): SINGLE_PLAYER_ONLY = \"SPO\" , \"SinglePlayerOnly\" MULTI_PLAYER_ONLY = \"MPO\" , \"MultiPlayerOnly\" MULTI_AND_SINGLE_PLAYER = \"MSP\" , \"MultiAndSinglePlayer\" class GameState ( models . TextChoices ): ACTIVE = \"ACT\" , \"Active\" INACTIVE = \"INA\" , \"Inactive\" COMING_SOON = \"CMS\" , \"ComingSoon\" game_id : models . CharField = models . CharField ( max_length = 10 ) name : models . CharField = models . CharField ( max_length = 40 ) desc : models . CharField = models . CharField ( max_length = 180 ) client_url : models . CharField = models . CharField ( max_length = 160 ) cover_art : models . ImageField = models . ImageField ( upload_to = \"images\" , null = True ) banner_art : models . ImageField = models . ImageField ( upload_to = \"images\" , null = True ) stats_config : models . FileField = models . FileField ( upload_to = \"stats_config\" , null = True ) game_type : models . CharField = models . CharField ( max_length = 3 , choices = GameTypes . choices , default = GameTypes . SINGLE_PLAYER_ONLY ) game_state : models . CharField = models . CharField ( max_length = 3 , choices = GameState . choices , default = GameState . INACTIVE ) def __str__ ( self ) -> str : return self . name Have a look at all of those instance variables in the Game class: 1 2 3 4 5 game_id name desc client_url ... Are they familiar? They should be - take another look at the admin panel. Django automatically maps the fields of our database model to the admin panel, provided we have registered it - which we did in our admin.py file. For all of this to work our model needs to extend models.Model : 1 class Game ( models . Model ): This tells Django that our Game object will be a database model. Each of the instance variables is a Django specific type that Django knows how to handle. The type of the model's fields also dictates how they are rendered in the admin panel. The models.ImageField is rendered as an upload field in UI. The models.Charfield that have choices associated with them are rendered as dropdowns etc... Most of these fields are pretty straight forward. CharFields are just strings that Django can store in a database table. But the same is not true for the ImageField or the FileField. We need to store these files somewhere. Django will only store the path of that file in the database. To understands how this works we need to have a look at the settings file.","title":"Games"},{"location":"onboarding/varcade_games/admin/#the-setting-file","text":"The settings.py is the core of our Django project. Remember back to the intro for this section, where I shared the following snippet from the Django homepage: Django is a high-level Python web framework that encourages rapid development and clean, pragmatic design. Built by experienced developers, it takes care of much of the hassle of web development, so you can focus on writing your app... It is through the setting.py that we will harness the power of Django. It's the interface through which we configure Django so that it can do the heavy lifting. Go ahead and open up website/server/game_portal/game_portal/setting.py . The section we're interested in right now is: 1 2 3 4 5 6 7 8 9 if DEBUG : CORS_ALLOW_ALL_ORIGINS = True STATIC_ROOT = os . path . join ( BASE_DIR , \"staticfiles\" ) MEDIA_ROOT = os . path . join ( BASE_DIR , \"media/\" ) else : CORS_ALLOWED_ORIGINS = [ \"https://varcade-games.com\" ] STATIC_ROOT = \"/var/lib/game_portal/data/staticfiles\" MEDIA_ROOT = \"/var/lib/game_portal/data/media/\" MEDIA_URL = \"https://api.varcade-games.com/media/\" More specifically we are interested in the MEDIA_ROOT and MEDIA_URL . The MEDIA_ROOT setting tells Django where it can store files locally. So any files we upload via the admin webpanel will go here. The MEDIA_URL setting tells Django where to request these files from. So why do we have this DEBUG condition and two different values for these settings? As the name implies, one is our debug config - which is active whenever we're running on our local dev server. However, when the website is deployed to a live server we need to tweak things a bit - but don't worry about this for now, we'll get to that later. For now - files will be saved to your game-portal container in the BASE_DIR - which correspond to website/server/game_portal directory. In fact - have a look in your file explorer right now. If you are running Varcade Games at the moment and have your local file system mounted on to the running Varcade Games container then you should see that media directory - and it should contain the files you uploaded when configuring Rock Paper Scissors Apocalypse .","title":"The Setting File"},{"location":"onboarding/varcade_games/admin/#summary","text":"So that's how we configure and store games. We create a class that is an instance of the Django model. We register that class with the Django admin system. We tell Django where we want static files to go (uploaded images etc...). Once all of that is done we can view our class in the admin panel and create/delete/modify data models as needed via that interface. Now that we have a game defined - how does it actually end up embedded in Varcade Games? That's what we will explore next.","title":"Summary"},{"location":"onboarding/varcade_games/embedding_games/","text":"Embedding Games Before we dig into the details of how games are loaded via the web UI, let's have a look at the process from a high level. Take a second to digest that image. We have multiple servers in play: Game Portal Used to configure games via admin panel API to serve active games to players File Server This is where players download the actual game from. Taking this step by step, the following is happening: Using a browser, we configure a game through the Admin Panel We run the Varcade Games client (our Vue.js project) in the browser We did this by navigating to localhost:8002 The Varcade Games client fetches the game data from the Game Portal The Varcade Games client uses that game data to download the game client from a file server The URL we added to the game we configured in the Admin Panel is this file server The Varcade Games client runs the game The game is a single javascript file, which we will look at in more detail later The Games API If you've already been exploring the networking section of the browser dev tools then you may have already seen this request: 1 Request URL: http://api.varcade.local:8000/games/v1/games/ This is step 3 from the list above. The response to this request looks something like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 { \"count\" : 1 , \"next\" : null , \"previous\" : null , \"results\" :[ { \"game_id\" : \"exrps\" , \"name\" : \"Rock Paper Scissors Apocalypse\" , \"desc\" : \"An fun but intense fighting game based on rock paper scissors. Single player and multi player modes available.\" , \"client_url\" : \"http://localhost:8090/main.js\" , \"cover_art\" : \"http://api.varcade.local:8000/media/images/exrps_cover_Wsyt72t.jpg\" , \"banner_art\" : \"http://api.varcade.local:8000/media/images/exrps_banner.jpg\" , \"stats_config\" : \"http://api.varcade.local:8000/media/stats_config/exrps_stats.json\" , \"game_state\" : \"ACT\" } ] } A couple of things should look familiar here. First off - all of that information is exactly what we put into the Admin Panel when we configured the game. It is all of the information needed by the Varcade Games client to display a game. Secondly, there are a couple of URLs in there. http://api.varcade.local:8000/media/images/exrps_cover_Wsyt72t.jpg http://api.varcade.local:8000/media/images/exrps_banner.jpg http://api.varcade.local:8000/media/stats_config/exrps_stats.json Remember the Django settings file from the previous section on the Admin Panel? This is our MEDIA_ROOT . Once we have all of the data we need from the Games API we can go ahead that display a game to the user. Loading games in the client Open up website/client/src/views/GamePlay.vue . This is the game page - where you will have played Rock Paper Scissors Apocalypse. Looking at the HTML, there are three main components on this page: 1 2 3 4 5 < wp-active-game :selected-game = \"selectedGame\" /> ... < wp-player-stats :selected-game = \"selectedGame\" /> ... < wp-game-leaderboard :game-id = \"gameId\" /> These are custom Vue components. We have one that presents our game, one that presents the player statistics for the game and another that presents the leaderboard for that game. Let's have a look at wp-active-game , it's at: website/client/src/components/wp-active-game.vue . If you scroll down to the code section of the file you will find this function (slightly modified for brevity): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 loadGameData : function () { if ( this . gameScriptLoaded ()) { console . log ( 'Will not load game - it appears to be loaded already' ) } else { let gameScript = document . createElement ( 'script' ); gameScript . setAttribute ( 'src' , this . selectedGame . client_url ); gameScript . setAttribute ( 'type' , 'text/javascript' ); gameScript . setAttribute ( 'id' , `_game_instance_ ${ this . gameId } ` ) document . body . appendChild ( gameScript ); this . loadingInterval = setInterval (() => { console . log ( \"Game loading...\" ); const gameContainerElement = document . getElementById ( 'gameContainer' ) this . gameLoaded = gameContainerElement != null && gameContainerElement . firstChild != null if ( this . gameLoaded ) { clearInterval ( this . loadingInterval ); console . log ( \"Game loaded.\" ); } }, 500 ); } } This is where we load the game. All we're doing is using javascript to add a new tag to the HTML page. This new tag is a script tag, and in that script tag we specify the URL of the game client. There is also some code that runs every 500 milliseconds to check if the initial loading of the game is complete, so that it can update the UI. And that's it for how the game is loaded - until of course we dig into how the game actually works. Before that - there is another hook we should take a look at. The Matchmaker.","title":"Embedding games"},{"location":"onboarding/varcade_games/embedding_games/#embedding-games","text":"Before we dig into the details of how games are loaded via the web UI, let's have a look at the process from a high level. Take a second to digest that image. We have multiple servers in play: Game Portal Used to configure games via admin panel API to serve active games to players File Server This is where players download the actual game from. Taking this step by step, the following is happening: Using a browser, we configure a game through the Admin Panel We run the Varcade Games client (our Vue.js project) in the browser We did this by navigating to localhost:8002 The Varcade Games client fetches the game data from the Game Portal The Varcade Games client uses that game data to download the game client from a file server The URL we added to the game we configured in the Admin Panel is this file server The Varcade Games client runs the game The game is a single javascript file, which we will look at in more detail later","title":"Embedding Games"},{"location":"onboarding/varcade_games/embedding_games/#the-games-api","text":"If you've already been exploring the networking section of the browser dev tools then you may have already seen this request: 1 Request URL: http://api.varcade.local:8000/games/v1/games/ This is step 3 from the list above. The response to this request looks something like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 { \"count\" : 1 , \"next\" : null , \"previous\" : null , \"results\" :[ { \"game_id\" : \"exrps\" , \"name\" : \"Rock Paper Scissors Apocalypse\" , \"desc\" : \"An fun but intense fighting game based on rock paper scissors. Single player and multi player modes available.\" , \"client_url\" : \"http://localhost:8090/main.js\" , \"cover_art\" : \"http://api.varcade.local:8000/media/images/exrps_cover_Wsyt72t.jpg\" , \"banner_art\" : \"http://api.varcade.local:8000/media/images/exrps_banner.jpg\" , \"stats_config\" : \"http://api.varcade.local:8000/media/stats_config/exrps_stats.json\" , \"game_state\" : \"ACT\" } ] } A couple of things should look familiar here. First off - all of that information is exactly what we put into the Admin Panel when we configured the game. It is all of the information needed by the Varcade Games client to display a game. Secondly, there are a couple of URLs in there. http://api.varcade.local:8000/media/images/exrps_cover_Wsyt72t.jpg http://api.varcade.local:8000/media/images/exrps_banner.jpg http://api.varcade.local:8000/media/stats_config/exrps_stats.json Remember the Django settings file from the previous section on the Admin Panel? This is our MEDIA_ROOT . Once we have all of the data we need from the Games API we can go ahead that display a game to the user.","title":"The Games API"},{"location":"onboarding/varcade_games/embedding_games/#loading-games-in-the-client","text":"Open up website/client/src/views/GamePlay.vue . This is the game page - where you will have played Rock Paper Scissors Apocalypse. Looking at the HTML, there are three main components on this page: 1 2 3 4 5 < wp-active-game :selected-game = \"selectedGame\" /> ... < wp-player-stats :selected-game = \"selectedGame\" /> ... < wp-game-leaderboard :game-id = \"gameId\" /> These are custom Vue components. We have one that presents our game, one that presents the player statistics for the game and another that presents the leaderboard for that game. Let's have a look at wp-active-game , it's at: website/client/src/components/wp-active-game.vue . If you scroll down to the code section of the file you will find this function (slightly modified for brevity): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 loadGameData : function () { if ( this . gameScriptLoaded ()) { console . log ( 'Will not load game - it appears to be loaded already' ) } else { let gameScript = document . createElement ( 'script' ); gameScript . setAttribute ( 'src' , this . selectedGame . client_url ); gameScript . setAttribute ( 'type' , 'text/javascript' ); gameScript . setAttribute ( 'id' , `_game_instance_ ${ this . gameId } ` ) document . body . appendChild ( gameScript ); this . loadingInterval = setInterval (() => { console . log ( \"Game loading...\" ); const gameContainerElement = document . getElementById ( 'gameContainer' ) this . gameLoaded = gameContainerElement != null && gameContainerElement . firstChild != null if ( this . gameLoaded ) { clearInterval ( this . loadingInterval ); console . log ( \"Game loaded.\" ); } }, 500 ); } } This is where we load the game. All we're doing is using javascript to add a new tag to the HTML page. This new tag is a script tag, and in that script tag we specify the URL of the game client. There is also some code that runs every 500 milliseconds to check if the initial loading of the game is complete, so that it can update the UI. And that's it for how the game is loaded - until of course we dig into how the game actually works. Before that - there is another hook we should take a look at. The Matchmaker.","title":"Loading games in the client"},{"location":"onboarding/varcade_games/get_the_code/","text":"Running The Project First things first, we need to get our hands on the code. SSH Keys We will create some SSH keys so that we can pull code securely from Github. From the home directory of your Ubuntu terminal (you can get there by typing cd ~/ in the Ubuntu terminal and hitting return), run the following command to create some SSH keys (replacing the email address here with your own): 1 ssh-keygen -t ed25519 -C john.doe@foo.com You will then be prompted to to select a directory and a passphrase. You can just hit return twice to accept the defaults. The output from this process should look something like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u2718 kev \ue0b0 ~ \ue0b0 ssh-keygen -t ed25519 -C john.doe@foo.com Generating public/private ed25519 key pair. Enter file in which to save the key (/home/kev/.ssh/id_ed25519): Created directory '/home/kev/.ssh'. Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /home/kev/.ssh/id_ed25519 Your public key has been saved in /home/kev/.ssh/id_ed25519.pub The key fingerprint is: <REDACTED> john.doe@foo.com The key's randomart image is: +--[ED25519 256]--+ | o.o+O@#| << snipped >> | | +----[SHA256]-----+ Next we need to attach the pubic SSH key that we just generated to our Github account. Run the following command in your Ubuntu terminal: 1 cat ~/.ssh/id_ed25519.pub The output of the command will look something like: 1 ssh-ed25519 AAAAC3NzaC1lZLI1TTE5AAAAIK0wmN/Cr3JXqmLW7u+g9pTh+wyqDHpSQEISczXkBx9q john.doe@foo.com Copy that line, we will use it in the next step. Open your github account and go to Your Profile (Icon at the top right of the screen) > Settings > SSH and GPG keys. Click the New SSH Key button. Give your SSH key a name that helps you understand what machine this key belongs to and then paste in the output from the previous command (your ssh key output). Downloading the code Now we can get the code. Head back over to your Ubuntu terminal and create a new directory for your code: 1 2 3 cd ~/ mkdir code cd code The clone all of the required repos using the following commands: 1 2 3 4 5 git clone git@github.com:theblacknight/build_tools.git git clone git@github.com:theblacknight/website.git git clone git@github.com:theblacknight/matchmaker.git git clone git@github.com:theblacknight/stats_tracker.git git clone git@github.com:theblacknight/game_rps.git If you entered a passphrase for your SSH key you will need to enter it now. The output will look something like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 kev \ue0b0 ~/code \ue0b0 git clone git@github.com:theblacknight/build_tools.git Cloning into 'build_tools'... The authenticity of host 'github.com (140.82.121.4)' can't be established. RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8. Are you sure you want to continue connecting (yes/no/[fingerprint])? yes Warning: Permanently added 'github.com,140.82.121.4' (RSA) to the list of known hosts. Enter passphrase for key '/home/kev/.ssh/id_ed25519': remote: Enumerating objects: 356, done. remote: Counting objects: 100% (356/356), done. remote: Compressing objects: 100% (178/178), done. remote: Total 356 (delta 247), reused 268 (delta 161), pack-reused 0 Receiving objects: 100% (356/356), 62.04 KiB | 577.00 KiB/s, done. Resolving deltas: 100% (247/247), done. Working with the code !! Windows Specific Once all of the projects are cloned you can do something pretty cool. Run the following command: 1 code . This is a special program in the Windows Ubuntu distro that will open up VSCode on your local machine, but connect it to the Ubuntu instance so that you can modify the code that we just cloned directly from Windows! Feel free to explore the code for a while before proceeding. There are detailed README files in each project folder and in all first level sub-folders that should help you understand what each of the different pieces is doing.","title":"Running The Project"},{"location":"onboarding/varcade_games/get_the_code/#running-the-project","text":"First things first, we need to get our hands on the code.","title":"Running The Project"},{"location":"onboarding/varcade_games/get_the_code/#ssh-keys","text":"We will create some SSH keys so that we can pull code securely from Github. From the home directory of your Ubuntu terminal (you can get there by typing cd ~/ in the Ubuntu terminal and hitting return), run the following command to create some SSH keys (replacing the email address here with your own): 1 ssh-keygen -t ed25519 -C john.doe@foo.com You will then be prompted to to select a directory and a passphrase. You can just hit return twice to accept the defaults. The output from this process should look something like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u2718 kev \ue0b0 ~ \ue0b0 ssh-keygen -t ed25519 -C john.doe@foo.com Generating public/private ed25519 key pair. Enter file in which to save the key (/home/kev/.ssh/id_ed25519): Created directory '/home/kev/.ssh'. Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /home/kev/.ssh/id_ed25519 Your public key has been saved in /home/kev/.ssh/id_ed25519.pub The key fingerprint is: <REDACTED> john.doe@foo.com The key's randomart image is: +--[ED25519 256]--+ | o.o+O@#| << snipped >> | | +----[SHA256]-----+ Next we need to attach the pubic SSH key that we just generated to our Github account. Run the following command in your Ubuntu terminal: 1 cat ~/.ssh/id_ed25519.pub The output of the command will look something like: 1 ssh-ed25519 AAAAC3NzaC1lZLI1TTE5AAAAIK0wmN/Cr3JXqmLW7u+g9pTh+wyqDHpSQEISczXkBx9q john.doe@foo.com Copy that line, we will use it in the next step. Open your github account and go to Your Profile (Icon at the top right of the screen) > Settings > SSH and GPG keys. Click the New SSH Key button. Give your SSH key a name that helps you understand what machine this key belongs to and then paste in the output from the previous command (your ssh key output).","title":"SSH Keys"},{"location":"onboarding/varcade_games/get_the_code/#downloading-the-code","text":"Now we can get the code. Head back over to your Ubuntu terminal and create a new directory for your code: 1 2 3 cd ~/ mkdir code cd code The clone all of the required repos using the following commands: 1 2 3 4 5 git clone git@github.com:theblacknight/build_tools.git git clone git@github.com:theblacknight/website.git git clone git@github.com:theblacknight/matchmaker.git git clone git@github.com:theblacknight/stats_tracker.git git clone git@github.com:theblacknight/game_rps.git If you entered a passphrase for your SSH key you will need to enter it now. The output will look something like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 kev \ue0b0 ~/code \ue0b0 git clone git@github.com:theblacknight/build_tools.git Cloning into 'build_tools'... The authenticity of host 'github.com (140.82.121.4)' can't be established. RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8. Are you sure you want to continue connecting (yes/no/[fingerprint])? yes Warning: Permanently added 'github.com,140.82.121.4' (RSA) to the list of known hosts. Enter passphrase for key '/home/kev/.ssh/id_ed25519': remote: Enumerating objects: 356, done. remote: Counting objects: 100% (356/356), done. remote: Compressing objects: 100% (178/178), done. remote: Total 356 (delta 247), reused 268 (delta 161), pack-reused 0 Receiving objects: 100% (356/356), 62.04 KiB | 577.00 KiB/s, done. Resolving deltas: 100% (247/247), done.","title":"Downloading the code"},{"location":"onboarding/varcade_games/get_the_code/#working-with-the-code","text":"","title":"Working with the code"},{"location":"onboarding/varcade_games/get_the_code/#windows-specific","text":"Once all of the projects are cloned you can do something pretty cool. Run the following command: 1 code . This is a special program in the Windows Ubuntu distro that will open up VSCode on your local machine, but connect it to the Ubuntu instance so that you can modify the code that we just cloned directly from Windows! Feel free to explore the code for a while before proceeding. There are detailed README files in each project folder and in all first level sub-folders that should help you understand what each of the different pieces is doing.","title":"!! Windows Specific"},{"location":"onboarding/varcade_games/intro_client/","text":"Introduction At this point you should be pretty familiar with Varcade games from a user perspective. Now it's time to start looking beneath the surface to understand how is all actually works. In this section we will go through the architecture of the system, try and understand what is happening from the perspective of the browser, make some code changes and run some tests. Up until now we've been getting things set up but from here on out... we're engineering. Notes From this point on you will have to start exploring and finding your own way around. As I've said before, this is the most effective path for learning, so keep the following in mind: Be curious - ask questions, think about what you're seeing/experiencing and why it does/doesn't make sense Don't be afraid to get lost in the code Don't be afraid to make changes break things Don't worry if you don't understand something (there will be plenty you won't understand, that's why we're here - to learn) You can do this - but like everything worthwhile, it's going to take time and effort","title":"Introduction"},{"location":"onboarding/varcade_games/intro_client/#introduction","text":"At this point you should be pretty familiar with Varcade games from a user perspective. Now it's time to start looking beneath the surface to understand how is all actually works. In this section we will go through the architecture of the system, try and understand what is happening from the perspective of the browser, make some code changes and run some tests. Up until now we've been getting things set up but from here on out... we're engineering.","title":"Introduction"},{"location":"onboarding/varcade_games/intro_client/#notes","text":"From this point on you will have to start exploring and finding your own way around. As I've said before, this is the most effective path for learning, so keep the following in mind: Be curious - ask questions, think about what you're seeing/experiencing and why it does/doesn't make sense Don't be afraid to get lost in the code Don't be afraid to make changes break things Don't worry if you don't understand something (there will be plenty you won't understand, that's why we're here - to learn) You can do this - but like everything worthwhile, it's going to take time and effort","title":"Notes"},{"location":"onboarding/varcade_games/intro_server/","text":"Introduction Varcade Games is pluggable . This means we can dynamically add games via the web application's admin panel. This section will cover the behind the scenes for this functionality. The server side of Varcade Games is built using Django . From the Django homepage: Django is a high-level Python web framework that encourages rapid development and clean, pragmatic design. Built by experienced developers, it takes care of much of the hassle of web development, so you can focus on writing your app without needing to reinvent the wheel. It\u2019s free and open source. Or more succinctly: The web framework for perfectionists with deadlines. This project leverages the built in Django admin system as well as some Javascript to dynamically add and remove games to and from the system - no code changes or deployments required! First lets take a look at the admin panel...","title":"Introduction"},{"location":"onboarding/varcade_games/intro_server/#introduction","text":"Varcade Games is pluggable . This means we can dynamically add games via the web application's admin panel. This section will cover the behind the scenes for this functionality. The server side of Varcade Games is built using Django . From the Django homepage: Django is a high-level Python web framework that encourages rapid development and clean, pragmatic design. Built by experienced developers, it takes care of much of the hassle of web development, so you can focus on writing your app without needing to reinvent the wheel. It\u2019s free and open source. Or more succinctly: The web framework for perfectionists with deadlines. This project leverages the built in Django admin system as well as some Javascript to dynamically add and remove games to and from the system - no code changes or deployments required! First lets take a look at the admin panel...","title":"Introduction"},{"location":"onboarding/varcade_games/making_changes/","text":"Making Changes Ok, finally it's time to actually get our hands dirty and change some code. To start we're going to work on the website project, also know as the Game Portal . Prerequisites The following must be true before continuing here: Your local Varcade games dev server is up and running You can access the web portal through http://localhost:8002 You can create and account and log in to your local dev server Changing the client The first thing we will do is get a view of our logs so that we can see what happens when we make some changes. In your terminal, navigate to the build_tools project and run the following command: 1 make logs a = game-portal-client This should result in your terminal filling up with a bunch of information that should look something like: 1 2 3 4 5 6 7 8 9 10 game-portal-client | <s> [ webpack.Progress ] 95 % emitting game-portal-client | <s> [ webpack.Progress ] 95 % emitting HtmlWebpackPlugin game-portal-client | <s> [ webpack.Progress ] 95 % emitting CopyPlugin game-portal-client | <s> [ webpack.Progress ] 98 % after emitting game-portal-client | <s> [ webpack.Progress ] 98 % after emitting CopyPlugin game-portal-client | DONE Compiled successfully in 213ms7:42:57 AM game-portal-client | <s> [ webpack.Progress ] 100 % game-portal-client | App running at: game-portal-client | - Local: http://localhost:8002/ game-portal-client | - Network: http://varcade.local/ Don't worry if yours doesn't look identical - the output here will depend on a number of factors. Next hit enter a few times in that same terminal window. This will add a few blank lines to the bottom of the output, which creates a sort of separator between the latest log output and future log output. This is a useful trick for when you want to view a chunk of logs starting at a point in time. Note : This little trick doesn't actually change the logs or anything, just adds some blank lines to your terminal. If you run the log command again in another window the blank lines will not be there. Removing the header The first change we're going to make is to remove the header from the login/registration page. We have a lovely big picture on that page and we'd like to see what it looks like without a chunk at the top being blocked by the header. In your browser open up http://localhost:8002 . If you are already logged in, click the logout button at the top right corner of the screen. Next, open up the code in what ever editor/IDE you are using and open the following file: 1 website/client/src/views/Index.vue This is the file that contains our core Vue components that allow users to register and log in. At the top of the file you will see the following: 1 2 3 4 5 6 7 8 < template > < div class = \"index-screen-image\" > < wp-top-bar v-bind:display-logout-option = \"false\" /> < div class = \"login-box-container\" > < wp-login-register /> </ div > </ div > </ template > Modify line 3 so that it looks like this: 1 <!--<wp-top-bar v-bind:display-logout-option=\"false\"/>--> What this does is 'comment out' that line of HTML. It means that the browser will ignore this line - which in turn will stop our header from being rendered. Once you've made this change, save the file and then head back over to your browser. The change should be immediately apparent - you don't even need to refresh the page! What sorcery is this? How is that even possible? This sorcery is called 'hot reloading' (see official docs ) and to see it in action let's head back over to our terminal! In the terminal window you should see something like this: 1 2 3 4 5 6 7 8 9 10 11 12 game-portal-client | <s> [ webpack.Progress ] 94 % after asset optimization game-portal-client | <s> [ webpack.Progress ] 94 % after seal game-portal-client | <s> [ webpack.Progress ] 95 % emitting game-portal-client | <s> [ webpack.Progress ] 95 % emitting HtmlWebpackPlugin game-portal-client | <s> [ webpack.Progress ] 95 % emitting CopyPlugin game-portal-client | <s> [ webpack.Progress ] 98 % after emitting game-portal-client | <s> [ webpack.Progress ] 98 % after emitting CopyPlugin game-portal-client | DONE Compiled successfully in 168ms7:44:20 AM game-portal-client | <s> [ webpack.Progress ] 100 % game-portal-client | App running at: game-portal-client | - Local: http://localhost:8002/ game-portal-client | - Network: http://varcade.local/ Your output should look exactly the same as mine. If you scroll up you will notice that what you're looking at here is essentially a progress bar. Scroll enough and you will reach the point where we added our blank lines, and you should see the following: 1 2 3 game-portal-client | WAIT Compiling...7:44:19 AM game-portal-client | <s> [ webpack.Progress ] 0 % compiling game-portal-client | <s> [ webpack.Progress ] 10 % building 0 /0 modules 0 active So what actually happened here? When we run our Vue.js app in development mode it watches all of the files in the project to see if any of them change. As soon as one changes, Vue will rebuild itself and update any active pages in place! That's exactly what we just did - and the logs show Vue.js reacting to the change we made, by recompiling the project. Pretty cool right? This allows us to make changes to our web application and immediately see the change. When things go wrong The above example show what happens when we successfully make a change... but what happens when we break something (and we will... we'll break loads of things!)? Well, let's find out. Head back over to your editor and remove the --> at the end of the file we modified so that it looks like this: 1 <!--<wp-top-bar v-bind:display-logout-option=\"false\"/> Then hit save and head back over to your browser. Bit of a different story right? You should still be able to see the Varcade Games homepage, but there is an error message displayed over it: 1 2 3 4 5 6 7 8 9 Failed to compile . . / src / views / Index . vue Module Error ( from . / node_modules / eslint - loader / index . js ) : /game_portal_client/src/views/Index.vue 54 : 1 error Parsing error : eof - in - comment vue / no - parsing - error \u2716 1 problem ( 1 error , 0 warnings ) Whenever you break the game portal client you will see an error like this. If you take a log at your logs you will also see this same error. This is important because we sometimes get a more descriptive error in our logs, like we do in this case: 1 2 3 4 5 6 7 8 9 10 11 game-portal-client | ( Emitted value instead of an instance of Error ) game-portal-client | Errors compiling template: game-portal-client | tag <div> has no matching end tag. game-portal-client | 1 | game-portal-client | 2 | game-portal-client | | game-portal-client | <s> [ webpack.Progress ] 100 % game-portal-client | 3 | <div class = \"index-screen-image\" > game-portal-client | | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ game-portal-client | 4 | game-portal-client | @ ./src/views/Index.vue?vue & type = template & id = 23543608 & 1 :0-410 1 :0-410 This message tells us that <div class=\"index-screen-image\"> has no matching end tag, which makes sense because on that line after that line in our template we opened a comment but never closed it: 1 2 3 4 5 6 7 8 9 < template > < div class = \"index-screen-image\" > <!--<wp-top-bar v-bind:display-logout-option=\"false\"/> <div class=\"login-box-container\"> <wp-login-register/> </div> </div> </template> Remove the <!-- from the start of line 4 and save the file. This will leave our page back in it's original state. What's next You are now equipped to start working on the Varcade Games game portal client. Take some time to look around the various files in the project. Make some changes, see what happens. The client/src/components directory is especially important as this is where the various components that make up the website live. Next we will look at what to do after we make changes to the code.","title":"Making Changes"},{"location":"onboarding/varcade_games/making_changes/#making-changes","text":"Ok, finally it's time to actually get our hands dirty and change some code. To start we're going to work on the website project, also know as the Game Portal .","title":"Making Changes"},{"location":"onboarding/varcade_games/making_changes/#prerequisites","text":"The following must be true before continuing here: Your local Varcade games dev server is up and running You can access the web portal through http://localhost:8002 You can create and account and log in to your local dev server","title":"Prerequisites"},{"location":"onboarding/varcade_games/making_changes/#changing-the-client","text":"The first thing we will do is get a view of our logs so that we can see what happens when we make some changes. In your terminal, navigate to the build_tools project and run the following command: 1 make logs a = game-portal-client This should result in your terminal filling up with a bunch of information that should look something like: 1 2 3 4 5 6 7 8 9 10 game-portal-client | <s> [ webpack.Progress ] 95 % emitting game-portal-client | <s> [ webpack.Progress ] 95 % emitting HtmlWebpackPlugin game-portal-client | <s> [ webpack.Progress ] 95 % emitting CopyPlugin game-portal-client | <s> [ webpack.Progress ] 98 % after emitting game-portal-client | <s> [ webpack.Progress ] 98 % after emitting CopyPlugin game-portal-client | DONE Compiled successfully in 213ms7:42:57 AM game-portal-client | <s> [ webpack.Progress ] 100 % game-portal-client | App running at: game-portal-client | - Local: http://localhost:8002/ game-portal-client | - Network: http://varcade.local/ Don't worry if yours doesn't look identical - the output here will depend on a number of factors. Next hit enter a few times in that same terminal window. This will add a few blank lines to the bottom of the output, which creates a sort of separator between the latest log output and future log output. This is a useful trick for when you want to view a chunk of logs starting at a point in time. Note : This little trick doesn't actually change the logs or anything, just adds some blank lines to your terminal. If you run the log command again in another window the blank lines will not be there.","title":"Changing the client"},{"location":"onboarding/varcade_games/making_changes/#removing-the-header","text":"The first change we're going to make is to remove the header from the login/registration page. We have a lovely big picture on that page and we'd like to see what it looks like without a chunk at the top being blocked by the header. In your browser open up http://localhost:8002 . If you are already logged in, click the logout button at the top right corner of the screen. Next, open up the code in what ever editor/IDE you are using and open the following file: 1 website/client/src/views/Index.vue This is the file that contains our core Vue components that allow users to register and log in. At the top of the file you will see the following: 1 2 3 4 5 6 7 8 < template > < div class = \"index-screen-image\" > < wp-top-bar v-bind:display-logout-option = \"false\" /> < div class = \"login-box-container\" > < wp-login-register /> </ div > </ div > </ template > Modify line 3 so that it looks like this: 1 <!--<wp-top-bar v-bind:display-logout-option=\"false\"/>--> What this does is 'comment out' that line of HTML. It means that the browser will ignore this line - which in turn will stop our header from being rendered. Once you've made this change, save the file and then head back over to your browser. The change should be immediately apparent - you don't even need to refresh the page! What sorcery is this? How is that even possible? This sorcery is called 'hot reloading' (see official docs ) and to see it in action let's head back over to our terminal! In the terminal window you should see something like this: 1 2 3 4 5 6 7 8 9 10 11 12 game-portal-client | <s> [ webpack.Progress ] 94 % after asset optimization game-portal-client | <s> [ webpack.Progress ] 94 % after seal game-portal-client | <s> [ webpack.Progress ] 95 % emitting game-portal-client | <s> [ webpack.Progress ] 95 % emitting HtmlWebpackPlugin game-portal-client | <s> [ webpack.Progress ] 95 % emitting CopyPlugin game-portal-client | <s> [ webpack.Progress ] 98 % after emitting game-portal-client | <s> [ webpack.Progress ] 98 % after emitting CopyPlugin game-portal-client | DONE Compiled successfully in 168ms7:44:20 AM game-portal-client | <s> [ webpack.Progress ] 100 % game-portal-client | App running at: game-portal-client | - Local: http://localhost:8002/ game-portal-client | - Network: http://varcade.local/ Your output should look exactly the same as mine. If you scroll up you will notice that what you're looking at here is essentially a progress bar. Scroll enough and you will reach the point where we added our blank lines, and you should see the following: 1 2 3 game-portal-client | WAIT Compiling...7:44:19 AM game-portal-client | <s> [ webpack.Progress ] 0 % compiling game-portal-client | <s> [ webpack.Progress ] 10 % building 0 /0 modules 0 active So what actually happened here? When we run our Vue.js app in development mode it watches all of the files in the project to see if any of them change. As soon as one changes, Vue will rebuild itself and update any active pages in place! That's exactly what we just did - and the logs show Vue.js reacting to the change we made, by recompiling the project. Pretty cool right? This allows us to make changes to our web application and immediately see the change.","title":"Removing the header"},{"location":"onboarding/varcade_games/making_changes/#when-things-go-wrong","text":"The above example show what happens when we successfully make a change... but what happens when we break something (and we will... we'll break loads of things!)? Well, let's find out. Head back over to your editor and remove the --> at the end of the file we modified so that it looks like this: 1 <!--<wp-top-bar v-bind:display-logout-option=\"false\"/> Then hit save and head back over to your browser. Bit of a different story right? You should still be able to see the Varcade Games homepage, but there is an error message displayed over it: 1 2 3 4 5 6 7 8 9 Failed to compile . . / src / views / Index . vue Module Error ( from . / node_modules / eslint - loader / index . js ) : /game_portal_client/src/views/Index.vue 54 : 1 error Parsing error : eof - in - comment vue / no - parsing - error \u2716 1 problem ( 1 error , 0 warnings ) Whenever you break the game portal client you will see an error like this. If you take a log at your logs you will also see this same error. This is important because we sometimes get a more descriptive error in our logs, like we do in this case: 1 2 3 4 5 6 7 8 9 10 11 game-portal-client | ( Emitted value instead of an instance of Error ) game-portal-client | Errors compiling template: game-portal-client | tag <div> has no matching end tag. game-portal-client | 1 | game-portal-client | 2 | game-portal-client | | game-portal-client | <s> [ webpack.Progress ] 100 % game-portal-client | 3 | <div class = \"index-screen-image\" > game-portal-client | | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ game-portal-client | 4 | game-portal-client | @ ./src/views/Index.vue?vue & type = template & id = 23543608 & 1 :0-410 1 :0-410 This message tells us that <div class=\"index-screen-image\"> has no matching end tag, which makes sense because on that line after that line in our template we opened a comment but never closed it: 1 2 3 4 5 6 7 8 9 < template > < div class = \"index-screen-image\" > <!--<wp-top-bar v-bind:display-logout-option=\"false\"/> <div class=\"login-box-container\"> <wp-login-register/> </div> </div> </template> Remove the <!-- from the start of line 4 and save the file. This will leave our page back in it's original state.","title":"When things go wrong"},{"location":"onboarding/varcade_games/making_changes/#whats-next","text":"You are now equipped to start working on the Varcade Games game portal client. Take some time to look around the various files in the project. Make some changes, see what happens. The client/src/components directory is especially important as this is where the various components that make up the website live. Next we will look at what to do after we make changes to the code.","title":"What's next"},{"location":"onboarding/varcade_games/matchmaker/","text":"The Matchmaker The Varcade Games client comes with some built-in functionality that allows players to create and join games online. Game developers can hook into this built in functionality to interact with our matchmaker server. So what we have is: A matchmaker SDK A matchmaker server The Varcade Games client provides the SDK and manages interactions with the Matchmaker so that game developers don't need to. The UI for creating and joining games will be consistent across all games in the portfolio. The Matchmaker SDK Open up website/client/src/components/wp-active-game.vue again. You may have already noticed there is a custom component in there for the matchmaker: 1 < wp-matchmaker :game-id = \"gameId\" /> If you open up that file, website/client/src/components/matchmaker.vue , you will see that it contains a modal : 1 2 3 4 5 6 < modal name = \"matchmaker-modal\" width = \"800\" height = \"600\" :scrollable = \"false\" :reset = \"true\" > ... A modal is a piece of UI that appears over our main UI. Hopefully you have seen this in action already. When you click Multi-player on the Rock Paper Scissors Apocalypse main menu a window pops up. That is a modal, and this is where it is defined. One function worth checking out at this point is the initMatchmaker method: 1 2 3 4 5 6 7 8 9 10 11 12 13 initMatchmaker : function () { if ( ! this . matchmaker && ! window . getMatchmaker ) { const matchmaker = new Matchmaker ( this . gameId , this . $store , () => { this . $modal . show ( 'matchmaker-modal' ); this . refreshGameList (); }); this . matchmaker = matchmaker ; window . getMatchmaker = function () { return matchmaker ; } } } This is how we expose the Matchmaker functionality to the game client. We create an instance of a Matchmaker object. We then attach a function called getMatchmaker to the global Javascript window object. The Matchmaker Object The above code initializes the Matchmaker object here: 1 2 3 4 new Matchmaker ( this . gameId , this . $store , () => { this . $modal . show ( 'matchmaker-modal' ); this . refreshGameList (); }); To understand a bit better what is going on here, let's look at the source. Open up website/client/src/matchmaker.js . This class is an interface to the Matchmaker server. It exposes all of the functionality of that server to the Varcade Games client, for example: Get a list of open games Create a new game Join an existing game The matchmaker also provides a hook for the actual game client to hook into the matchmaker. Remember earlier on when we attached our Matchmaker object to the window object? Game client can access that same window object. Any Javascript executing on the page can. So that the game client does is call window.getMatchmaker() , and if a player selects multi-player they can call matchmaker.showMatchmaker(callback) . The whole thing looks something like this: It's worth spending a minute going through this diagram. First off, you should notice that I've split the diagram in two with a red dotted line. It's important to not what exactly is within the scope of the Varcade Games Client and what is not. Within the client we have a matchmaker Vue file, which is responsible for the matchmaker UI, and we have a matchmaker object, which is a normal object that provides access to the matchmaker server and the matchmaker UI. But next to those two we have a window object and the actual game client (the graphics and gameplay etc...). The window is a global Javascript script object that represents a tab in your browser. So every time you open up a new webpage in your browser, that webpage has access to this global object. That means that any Javascript running on that page also has access to it. We use this fact to share our matchmaker object between two different applications running on the same page. One application is the Varcade games client. The other is the game, which has nothing to do with the Varcade Games client - it just happens to have been downloaded by it. Since both have access to this shared object, they can now interact - and that is how clicking the multi-player button in the game UI can open a modal in the Varcade Games UI. We'll look at exactly how the game client does this in a later section. That's it for the matchmaker for now - we will come back and look at all of this in a lot more detail later on when we look at multi-player gameplay and the matchmaker server. But first, let's jump in to some single player Rock Paper Scissors Apocalypse.","title":"The Matchmaker"},{"location":"onboarding/varcade_games/matchmaker/#the-matchmaker","text":"The Varcade Games client comes with some built-in functionality that allows players to create and join games online. Game developers can hook into this built in functionality to interact with our matchmaker server. So what we have is: A matchmaker SDK A matchmaker server The Varcade Games client provides the SDK and manages interactions with the Matchmaker so that game developers don't need to. The UI for creating and joining games will be consistent across all games in the portfolio.","title":"The Matchmaker"},{"location":"onboarding/varcade_games/matchmaker/#the-matchmaker-sdk","text":"Open up website/client/src/components/wp-active-game.vue again. You may have already noticed there is a custom component in there for the matchmaker: 1 < wp-matchmaker :game-id = \"gameId\" /> If you open up that file, website/client/src/components/matchmaker.vue , you will see that it contains a modal : 1 2 3 4 5 6 < modal name = \"matchmaker-modal\" width = \"800\" height = \"600\" :scrollable = \"false\" :reset = \"true\" > ... A modal is a piece of UI that appears over our main UI. Hopefully you have seen this in action already. When you click Multi-player on the Rock Paper Scissors Apocalypse main menu a window pops up. That is a modal, and this is where it is defined. One function worth checking out at this point is the initMatchmaker method: 1 2 3 4 5 6 7 8 9 10 11 12 13 initMatchmaker : function () { if ( ! this . matchmaker && ! window . getMatchmaker ) { const matchmaker = new Matchmaker ( this . gameId , this . $store , () => { this . $modal . show ( 'matchmaker-modal' ); this . refreshGameList (); }); this . matchmaker = matchmaker ; window . getMatchmaker = function () { return matchmaker ; } } } This is how we expose the Matchmaker functionality to the game client. We create an instance of a Matchmaker object. We then attach a function called getMatchmaker to the global Javascript window object.","title":"The Matchmaker SDK"},{"location":"onboarding/varcade_games/matchmaker/#the-matchmaker-object","text":"The above code initializes the Matchmaker object here: 1 2 3 4 new Matchmaker ( this . gameId , this . $store , () => { this . $modal . show ( 'matchmaker-modal' ); this . refreshGameList (); }); To understand a bit better what is going on here, let's look at the source. Open up website/client/src/matchmaker.js . This class is an interface to the Matchmaker server. It exposes all of the functionality of that server to the Varcade Games client, for example: Get a list of open games Create a new game Join an existing game The matchmaker also provides a hook for the actual game client to hook into the matchmaker. Remember earlier on when we attached our Matchmaker object to the window object? Game client can access that same window object. Any Javascript executing on the page can. So that the game client does is call window.getMatchmaker() , and if a player selects multi-player they can call matchmaker.showMatchmaker(callback) . The whole thing looks something like this: It's worth spending a minute going through this diagram. First off, you should notice that I've split the diagram in two with a red dotted line. It's important to not what exactly is within the scope of the Varcade Games Client and what is not. Within the client we have a matchmaker Vue file, which is responsible for the matchmaker UI, and we have a matchmaker object, which is a normal object that provides access to the matchmaker server and the matchmaker UI. But next to those two we have a window object and the actual game client (the graphics and gameplay etc...). The window is a global Javascript script object that represents a tab in your browser. So every time you open up a new webpage in your browser, that webpage has access to this global object. That means that any Javascript running on that page also has access to it. We use this fact to share our matchmaker object between two different applications running on the same page. One application is the Varcade games client. The other is the game, which has nothing to do with the Varcade Games client - it just happens to have been downloaded by it. Since both have access to this shared object, they can now interact - and that is how clicking the multi-player button in the game UI can open a modal in the Varcade Games UI. We'll look at exactly how the game client does this in a later section. That's it for the matchmaker for now - we will come back and look at all of this in a lot more detail later on when we look at multi-player gameplay and the matchmaker server. But first, let's jump in to some single player Rock Paper Scissors Apocalypse.","title":"The Matchmaker Object"},{"location":"onboarding/varcade_games/reverse_engineering/","text":"Reverse Engineering Now that we've been through the full project setup and you have seen some of the system architecture in detail it is time to spend some time digging around yourself. Let's start with your browser console. The Browser Console If you've ever done any sort of web development you're likely familiar with the browser console as well as the value that it brings. If not, you're about to find out. Digging around in Varcade Games If you development stack isn't running then go ahead and start it up. Then open your browser to your local Varcade Games instance at localhost:8002 . Log in to some existing account, or create a new one if you need to. Inspecting a webpage Once you've arrived at the games page do the following: Right-click on the Varcade Games title at the top left hand corner of the browser window In the menu that pops up select the Inspect item You should see something like this: You have just opened the built-in web browser dev tools. As the name suggests, this is a set of tools for developers. Depending on the browser you are using (I am using Brave) this may look different, but most of the popular browser these days have more or less the same options available. In our dev tools you'll be presented with some HTML. More specifically, you are seeing the HTML that was created for displaying Varcade Games. If you move your mouse over some of the HTML in the tools window you will notice that different elements on the page get highlighted. You can even right click on the HTML elements to interact with them. Try right-clicking the '<body>' tag and selecting Delete element . Everything is gone! This is expected - all we've done here is dynamically modify the HTML in our browser. But don't worry, refresh the page and everything will come back, just the way it was. You can open up these dev tools on any web page that you visit and have a look around at how they structure their website. Some will be complex, others less so - but it's always interesting to jump in and have a look at how your favourite websites are built. Spend some time digging around in the HTML. Try removing some elements and see what effect it has on the page. Everything you see and do here will be valuable for when you actually start working on the project. Styling Along with the HTML you'll also notice a section in the dev tools for CSS. In my case it's on the right hand side of the window under the heading Styles . Any CSS that is defined for the page you are viewing will show up here - and yes you can go ahead and modify this too. This tool is particularly useful when you are actively designing and building a page as you can change values here to get quick feedback on how it looks before you go ahead and modify your CSS files. So let's play with it. Left-click on the body tag. In the styles section of your dev tools you should now see some style information for the body of our webpage. Notice that if you uncheck the background entry, the page background turns white. If you uncheck the color entry then all of the text on the page turns black. Two things worth noticing in this UI: Sometimes unchecking a style doesn't do anything! Some of the styles are crossed off! To address the first point, it's worth understanding what CSS actually means. It stands for Cascading StyleSheets . The word cascading is the one that matters here. It means 'to pass on'. What is happening here is that the body element in our CSS defines some styling, but other elements on the page may choose to define their own styling . So the information in the body style will cascade down through all child elements, but that does not mean that the child elements need to use that style, they may have their own style - as children often do. That leads on to the second point. When you see an entry in this list crossed off then it means some CSS has been defined elsewhere that overrides it. In our case, we have overridden the default body style that colors text black so that we can color it white. If you uncheck the box beside the color: white style you will notice that the color: black style is no longer crossed off. That is because we are no longer overriding in. Using these tools you can play around with different styles and visuals for your pages (or other peoples pages if you like!). Adding new styles In the style window you should see an entry called element.style or just element . If you click that entry you can add what ever styling you want to the selected element Trying copying and pasting some of these style changes into that section and notice the difference it makes to the webpage: background: red; margin: 100px; font-size: 2em; The Console The page inspector is great for understanding the layout and styling of any given webpage - but modern webpages are a lot more than just structured content and pretty colors. They're active. Especially in the case of the pages that contain our games. Active pages means there is some Javascript running somewhere - and where there are scripts running we need logs to understand what the hell is going on. Along the top of the dev tools section of your browser window there should be a 'Console' tab. Whenever you write some Javascript for a browser and write to the console it shows up here. So for example 1 console.log ( \"Hello World\" ) Running this Javascript in a browser will print Hello World to the console. In our console you can see there is a lot more going on, but before we dig in - let's get a fresh view of the information. First open up the game page so you can see Rock Paper Scissors Apocalypse . Then refresh the page to captured all of the output that comes with loading this page. If you scroll up towards the top you should see some messages like this: 1 2 3 4 5 6 7 8 9 10 11 ... Phaser v3.55.2 ( WebGL | Web Audio ) https://phaser.io Checking local storage for save data... Game loading... Game loaded. Boot complete - loading assets Loading assets... Loading 'global' assets... Loading icons: ui/icons.png,50,50 Loading bgMusic: audio/battle.wav ... This is what is being logged by the game client to help us understand what is going on. The short snippet above shows the game starting up and then beginning to load assets (the images/audio etc...). It's worth noting that not all of these logs are coming from code we wrote . Some of the log messages are coming from Phaser - the 2D game engine we are using. Some of them are coming from Vue.js - the web framework we are using. You don't need to understand any of these logs just yet, but you need to know they are there. Leave the console open and try navigating around the website, playing the game, playing multi-player etc... and see what is being printed out there. Understanding how to find and interpret logs will be vital later on when you start extending Varcade Games. Networking The final section of the browser dev tools we're going to look at here is the Network section: Again this may look slightly different in your browser, but the concepts are all the same. Select the Network tab in your browser and refresh the page. What you're looking at here is all of the requests that your browser sent to the server in order to load the page. In our case it there are requests be sent to multiple servers as we load the: Page's HTML Page's Javascript Page's CSS Game's Javascript Images for the game Audio for the game Leaderboard and player stats for the game In the table of requests we can also see the Status of the request, the Type of resource being requests (image/script/text etc...) and a few other bits of useful information about the size of the response and the amount of time it took. If you click on any one of the requests you will get a lot more information about it: The request in the image above is the request to fetch the actual game code for Rock Paper Scissors Apocalypse. Have a look at the request URL. It is http://localhost:8090/main.js . Is this URL familiar for any reason? Cast your mind back to when we set up the game in the Varcade Games admin panel. For every game we entered a URL... the above URL is that URL. Coincidence? No. When we register a game with Varcade Games we tell the system where the game code is located, and this is the point where we actually call that URL to get the game code. Again, these tools are all interactive. You can modify and re-send requests if you like, or preview the response data. Exploration Ok - I think you are now armed with enough information to start exploring and trying to reverse engineer some of what is going on behind the scenes are Varcade Games. Like I said before - jump in, click things, break things. Any damage you do and be undone by refreshing the page. And most importantly: think . As you explore the website using the devtools, have a think about: What does this request do? Why does this one take longer than that one? What happens if I remove this HTML element? What would the game page look like with a red background? What happens if I change the URL in the admin panel? Will the game break? What are all of these messages in the console? And don't be afraid to look things up. Head over to Duck Duck Go (or Google... I suppose) and search for some of the words you see but don't understand. This exploration and research is far more valuable than anything you read here or watch on some tutorial video. Notes: There are some practical applications for the console in your day to day life, for example if you're viewing a webpage and it has an annoying flashing ad, or and image you don't like, you can open up the console and remove it! The next time some webpage stops working as expected, try opening up the console and having a look at the logs. If you need to contact support the information you find here might be useful.","title":"Reverse Engineering"},{"location":"onboarding/varcade_games/reverse_engineering/#reverse-engineering","text":"Now that we've been through the full project setup and you have seen some of the system architecture in detail it is time to spend some time digging around yourself. Let's start with your browser console.","title":"Reverse Engineering"},{"location":"onboarding/varcade_games/reverse_engineering/#the-browser-console","text":"If you've ever done any sort of web development you're likely familiar with the browser console as well as the value that it brings. If not, you're about to find out.","title":"The Browser Console"},{"location":"onboarding/varcade_games/reverse_engineering/#digging-around-in-varcade-games","text":"If you development stack isn't running then go ahead and start it up. Then open your browser to your local Varcade Games instance at localhost:8002 . Log in to some existing account, or create a new one if you need to.","title":"Digging around in Varcade Games"},{"location":"onboarding/varcade_games/reverse_engineering/#inspecting-a-webpage","text":"Once you've arrived at the games page do the following: Right-click on the Varcade Games title at the top left hand corner of the browser window In the menu that pops up select the Inspect item You should see something like this: You have just opened the built-in web browser dev tools. As the name suggests, this is a set of tools for developers. Depending on the browser you are using (I am using Brave) this may look different, but most of the popular browser these days have more or less the same options available. In our dev tools you'll be presented with some HTML. More specifically, you are seeing the HTML that was created for displaying Varcade Games. If you move your mouse over some of the HTML in the tools window you will notice that different elements on the page get highlighted. You can even right click on the HTML elements to interact with them. Try right-clicking the '<body>' tag and selecting Delete element . Everything is gone! This is expected - all we've done here is dynamically modify the HTML in our browser. But don't worry, refresh the page and everything will come back, just the way it was. You can open up these dev tools on any web page that you visit and have a look around at how they structure their website. Some will be complex, others less so - but it's always interesting to jump in and have a look at how your favourite websites are built. Spend some time digging around in the HTML. Try removing some elements and see what effect it has on the page. Everything you see and do here will be valuable for when you actually start working on the project.","title":"Inspecting a webpage"},{"location":"onboarding/varcade_games/reverse_engineering/#styling","text":"Along with the HTML you'll also notice a section in the dev tools for CSS. In my case it's on the right hand side of the window under the heading Styles . Any CSS that is defined for the page you are viewing will show up here - and yes you can go ahead and modify this too. This tool is particularly useful when you are actively designing and building a page as you can change values here to get quick feedback on how it looks before you go ahead and modify your CSS files. So let's play with it. Left-click on the body tag. In the styles section of your dev tools you should now see some style information for the body of our webpage. Notice that if you uncheck the background entry, the page background turns white. If you uncheck the color entry then all of the text on the page turns black. Two things worth noticing in this UI: Sometimes unchecking a style doesn't do anything! Some of the styles are crossed off! To address the first point, it's worth understanding what CSS actually means. It stands for Cascading StyleSheets . The word cascading is the one that matters here. It means 'to pass on'. What is happening here is that the body element in our CSS defines some styling, but other elements on the page may choose to define their own styling . So the information in the body style will cascade down through all child elements, but that does not mean that the child elements need to use that style, they may have their own style - as children often do. That leads on to the second point. When you see an entry in this list crossed off then it means some CSS has been defined elsewhere that overrides it. In our case, we have overridden the default body style that colors text black so that we can color it white. If you uncheck the box beside the color: white style you will notice that the color: black style is no longer crossed off. That is because we are no longer overriding in. Using these tools you can play around with different styles and visuals for your pages (or other peoples pages if you like!).","title":"Styling"},{"location":"onboarding/varcade_games/reverse_engineering/#adding-new-styles","text":"In the style window you should see an entry called element.style or just element . If you click that entry you can add what ever styling you want to the selected element Trying copying and pasting some of these style changes into that section and notice the difference it makes to the webpage: background: red; margin: 100px; font-size: 2em;","title":"Adding new styles"},{"location":"onboarding/varcade_games/reverse_engineering/#the-console","text":"The page inspector is great for understanding the layout and styling of any given webpage - but modern webpages are a lot more than just structured content and pretty colors. They're active. Especially in the case of the pages that contain our games. Active pages means there is some Javascript running somewhere - and where there are scripts running we need logs to understand what the hell is going on. Along the top of the dev tools section of your browser window there should be a 'Console' tab. Whenever you write some Javascript for a browser and write to the console it shows up here. So for example 1 console.log ( \"Hello World\" ) Running this Javascript in a browser will print Hello World to the console. In our console you can see there is a lot more going on, but before we dig in - let's get a fresh view of the information. First open up the game page so you can see Rock Paper Scissors Apocalypse . Then refresh the page to captured all of the output that comes with loading this page. If you scroll up towards the top you should see some messages like this: 1 2 3 4 5 6 7 8 9 10 11 ... Phaser v3.55.2 ( WebGL | Web Audio ) https://phaser.io Checking local storage for save data... Game loading... Game loaded. Boot complete - loading assets Loading assets... Loading 'global' assets... Loading icons: ui/icons.png,50,50 Loading bgMusic: audio/battle.wav ... This is what is being logged by the game client to help us understand what is going on. The short snippet above shows the game starting up and then beginning to load assets (the images/audio etc...). It's worth noting that not all of these logs are coming from code we wrote . Some of the log messages are coming from Phaser - the 2D game engine we are using. Some of them are coming from Vue.js - the web framework we are using. You don't need to understand any of these logs just yet, but you need to know they are there. Leave the console open and try navigating around the website, playing the game, playing multi-player etc... and see what is being printed out there. Understanding how to find and interpret logs will be vital later on when you start extending Varcade Games.","title":"The Console"},{"location":"onboarding/varcade_games/reverse_engineering/#networking","text":"The final section of the browser dev tools we're going to look at here is the Network section: Again this may look slightly different in your browser, but the concepts are all the same. Select the Network tab in your browser and refresh the page. What you're looking at here is all of the requests that your browser sent to the server in order to load the page. In our case it there are requests be sent to multiple servers as we load the: Page's HTML Page's Javascript Page's CSS Game's Javascript Images for the game Audio for the game Leaderboard and player stats for the game In the table of requests we can also see the Status of the request, the Type of resource being requests (image/script/text etc...) and a few other bits of useful information about the size of the response and the amount of time it took. If you click on any one of the requests you will get a lot more information about it: The request in the image above is the request to fetch the actual game code for Rock Paper Scissors Apocalypse. Have a look at the request URL. It is http://localhost:8090/main.js . Is this URL familiar for any reason? Cast your mind back to when we set up the game in the Varcade Games admin panel. For every game we entered a URL... the above URL is that URL. Coincidence? No. When we register a game with Varcade Games we tell the system where the game code is located, and this is the point where we actually call that URL to get the game code. Again, these tools are all interactive. You can modify and re-send requests if you like, or preview the response data.","title":"Networking"},{"location":"onboarding/varcade_games/reverse_engineering/#exploration","text":"Ok - I think you are now armed with enough information to start exploring and trying to reverse engineer some of what is going on behind the scenes are Varcade Games. Like I said before - jump in, click things, break things. Any damage you do and be undone by refreshing the page. And most importantly: think . As you explore the website using the devtools, have a think about: What does this request do? Why does this one take longer than that one? What happens if I remove this HTML element? What would the game page look like with a red background? What happens if I change the URL in the admin panel? Will the game break? What are all of these messages in the console? And don't be afraid to look things up. Head over to Duck Duck Go (or Google... I suppose) and search for some of the words you see but don't understand. This exploration and research is far more valuable than anything you read here or watch on some tutorial video. Notes: There are some practical applications for the console in your day to day life, for example if you're viewing a webpage and it has an annoying flashing ad, or and image you don't like, you can open up the console and remove it! The next time some webpage stops working as expected, try opening up the console and having a look at the logs. If you need to contact support the information you find here might be useful.","title":"Exploration"},{"location":"onboarding/varcade_games/running_vcg/","text":"Building the applications From your terminal, open the build_tools directory: 1 cd ~/code/build_tools We'll use Vim to create a settings file for our local environment. If you haven't used Vim before, this may be a strange experience. First type vim .env.local in your terminal and hit return . This will result in a blank screen. Next press i to enter insert mode and then type the following line: 1 ENV_CODE_OVER_TIME_ROOT=/home/<your user name here>/code Then press the esc key and type :wq and hit return If you did everything exactly as I've written above, there should now be a new file in the build_tools directory called .env.local . This file tells the build scripts where the code is, so it's pretty important. You should now be able to open this file in VSCode. If you have any issues with Vim you can create the file via VSCode - but it's good to start wrapping your head around Vim now, as it will be useful in the future. Next we need to install a couple tools for building and running the project: 1 2 sudo apt install make sudo apt install docker-compose Building Varcade Games Windows Only Make sure docker is running (in Windows). Open Docker and open the setting screen to: Docker > Settings > Resources > WSL Integration > Enable integration with additional distros Make sure that Ubuntu-20.04 is checked in the Enable integration with additional distros section: Back in your terminal, run: 1 make build This will kick off a build of the various different applications. This will take a few minutes as all of the dependencies will need to download. Nearly there! Running the applications All we need to do now is run make start from the Ubuntu terminal. That will start up all of the applications and you can check their state by running make ps . If any of the services fail to start, run make start again. Before we can actually interact with Varcade Games we need to initialize the database. Run the following command to connect to the game-portal application: 1 docker exec -it game-portal bash Next run: 1 ./manage.py migrate You will see some output like this: Next run: 1 ./manage.py createsuperuser You will need to follow a few steps to create your admin user account for managing Varcade Games. We have one final thing to do - that is set up our local networking environment. Open notepad as administrator. The select File > Open and navigate to C:\\Windows\\System32\\drivers\\etc\\ and open the file called hosts . The directory may appear empty, so be sure to select all files from the drop down at the bottom right that says text files . Add the following line to the bottom of the file: 1 127 .0.0.1 varcade.local api.varcade.local games.varcade.local matchmaker.varcade.local rps.varcade.local Save and close notepad. Now, if you point your browser at localhost:8002 you should arrive at the landing page for Varcade Games . You can log in with the username and password you entered in the previous step when you ran ./manage.py createsuperuser . Unfortunately there won't be much to see. We need to add game.","title":"Running vcg"},{"location":"onboarding/varcade_games/running_vcg/#building-the-applications","text":"From your terminal, open the build_tools directory: 1 cd ~/code/build_tools We'll use Vim to create a settings file for our local environment. If you haven't used Vim before, this may be a strange experience. First type vim .env.local in your terminal and hit return . This will result in a blank screen. Next press i to enter insert mode and then type the following line: 1 ENV_CODE_OVER_TIME_ROOT=/home/<your user name here>/code Then press the esc key and type :wq and hit return If you did everything exactly as I've written above, there should now be a new file in the build_tools directory called .env.local . This file tells the build scripts where the code is, so it's pretty important. You should now be able to open this file in VSCode. If you have any issues with Vim you can create the file via VSCode - but it's good to start wrapping your head around Vim now, as it will be useful in the future. Next we need to install a couple tools for building and running the project: 1 2 sudo apt install make sudo apt install docker-compose","title":"Building the applications"},{"location":"onboarding/varcade_games/running_vcg/#building-varcade-games","text":"","title":"Building Varcade Games"},{"location":"onboarding/varcade_games/running_vcg/#windows-only","text":"Make sure docker is running (in Windows). Open Docker and open the setting screen to: Docker > Settings > Resources > WSL Integration > Enable integration with additional distros Make sure that Ubuntu-20.04 is checked in the Enable integration with additional distros section: Back in your terminal, run: 1 make build This will kick off a build of the various different applications. This will take a few minutes as all of the dependencies will need to download. Nearly there!","title":"Windows Only"},{"location":"onboarding/varcade_games/running_vcg/#running-the-applications","text":"All we need to do now is run make start from the Ubuntu terminal. That will start up all of the applications and you can check their state by running make ps . If any of the services fail to start, run make start again. Before we can actually interact with Varcade Games we need to initialize the database. Run the following command to connect to the game-portal application: 1 docker exec -it game-portal bash Next run: 1 ./manage.py migrate You will see some output like this: Next run: 1 ./manage.py createsuperuser You will need to follow a few steps to create your admin user account for managing Varcade Games. We have one final thing to do - that is set up our local networking environment. Open notepad as administrator. The select File > Open and navigate to C:\\Windows\\System32\\drivers\\etc\\ and open the file called hosts . The directory may appear empty, so be sure to select all files from the drop down at the bottom right that says text files . Add the following line to the bottom of the file: 1 127 .0.0.1 varcade.local api.varcade.local games.varcade.local matchmaker.varcade.local rps.varcade.local Save and close notepad. Now, if you point your browser at localhost:8002 you should arrive at the landing page for Varcade Games . You can log in with the username and password you entered in the previous step when you ran ./manage.py createsuperuser . Unfortunately there won't be much to see. We need to add game.","title":"Running the applications"},{"location":"onboarding/varcade_games/system_architecture/","text":"System Architecture At this point you should have your local development environment all set up and you should be able to log in to your own private instance of Varcade games and play Rock Paper Scissors Apocalypse . So let's have a look at the big picture - what's actually going on behind the scenes. In the above diagram I have colored all of the components that make up Varcade Games in grey. The green boxes (Redis and MySQL) are third party dependencies. Varcade Games needs them to operate, but they exist as independent products built by someone else. And finally, in blue is our actual game. Rock Paper Scissors Apocalypse. This game has nothing to do with Varcade Games, technically at least. It is plugged into the system, but the system doesn't need it to operate. The game doesn't need Varcade Games to function either. It is using it as a host. I'll briefly introduce the various components here before we dig more deeply into how they work and how to work with them. Components Varcade Games Client & Server The first box on the left hand side center of the diagram is our Varcade Games Client. This is what the user interacts with. Where they log in, browse games and select games to play. This client is built using Vue.js , so there is a lot of Javascript, HTML and CSS in there. The client connects to a dedicated Varcade Games server. This server is responsible for managing player accounts and managing games. It is built using Django , so we'll be working in Python on the server side. It also uses MySQL as a database to store the player account and game information. Player Stats Server In our diagram we can see that the Varcade Games Server connects to something called the 'Stats Tracker' server. This server's job is to serve leaderboards and interesting statistics to the game portal. Each game page will have a metrics and leaderboard section, the Varcade Games client gets that information from the Varcade Games server, but that server must request the information from the Stats Tracker server first. This server is built using Flask , which means we're working with Python. Matchmaker Server The Varcade Games client also connects to the Matchmaker server. The client has a built in Matchmaker maker UI so that players can find each other and play together. The Matchmaker server is responsible for creating and managing multi-player games. It is generic by nature and doesn't really know anything about the games that are using it, so each game that wants to use it must be registered with it. This server is also built using Flask , which means we're working with Python again. Redis You'll notice that both the Stats Tracker and Matchmaker servers connect to Redis , which is a no-sql database. Multi-player games, player stats and leaderboards are all stored in Redis. It provides a number of data structures that are useful for our particular use case. The Workers Both the Stats Tracker and Matchmaker also have 'worker' applications. These are programs that are also written in Python whose job it is to monitor goings on behind the scenes. They track and store player stats coming from games. They clean up old games in the Matchmaker database, and much more. Many server systems require such applications for performing any work that doesn't fit into the typical request-response model of a sever. RPS Client and Server And finally, we've got our game. This is the game that we have integrated into Varcade Games, which means it is hosted by, and leverages the Matchmaker and Stats Tracker services built in to, Varcade Games. Notice that our diagram shows a connection between the two clients. The game client is embedded in the Varcade Games client. Notice also that the client communicates with its dedicated server in order to play against other players online, but the server also has connections to Varcade Games. First of all, the Matchmaker needs to be able to connect to the game server in order to actually create and manage games. Secondly, the game server needs to send 'events' to a 'stream' in order to keep the Varcade Games system up to date. This 'stream' is more functionality in Redis that we are leveraging. The game client is built using Phaser 3, a 2D game engine built in Javascript. This is the part the player interacts with. The game server is built using Node.js, which is a web server built in Javascript. Interaction Now that we've been introduced to the various different players in our systems, let's take a look at how the system actually behaves ; how these components actually interact with each other. To represent this visually we will use something called a 'sequence diagram'. Sequence Diagrams In case you've never seen a sequence diagram before, they are essentially just a useful way of visually representing interactions between a number of components in a system over time. For example, here is a very basic sequence diagram that shows the interactions between a customer and a cashier when buying a loaf of bread: What a pleasant and polite interaction it was too. All we've done here is visually represent a customer walking up to a cashier with a loaf of bread. They greet each other, then the cashier scans the bread and tells the customer how much they have to pay. The customer then counts out some cash and gives it to the cashier. The cashier then gives the customer their change before they say goodbye and go their separate ways. The arrows that go between entities represent communication between components . There are also arrows that start and end on a single entity. In our case, when the cashier scans the bread they don't need anything from the customer. They just need to do that action themselves. Same goes for the customer when they are counting out the money needed to pay for the bread. In the sections below we will expand on these concepts to understand how the different entities in the Varcade Games system interact with each other. Basic Varcade Games interaction Let's use a sequence diagram to take a look at some of the interactions you will have already had with Varcade Games. In the below sequence diagram we have 4 entities: User Browser This is the user's web browser, through which it is interacting with our website Varcade Games Server This is the server that manages all of the Varcade Games configuration and data Stats Tracker Server This is the server that manages leaderboards and player stats for our games File Server This is a basic server that serves files This diagram is showing us the most basic interaction that a user will have with Varcade Games. They will: Load the website Log in View a list of games Select a game Play the game Our website is what is known as a 'client side application'. All of the interactions and layouts of our pages are managed through Javascript running in the browser. So when you navigate to Varcade Games you first need to download that Javascript. It is stored on a server whose only job is to serve those files. Once the browser runs the Javascript it will present the user with a log in page. As mentioned earlier, the client will connect to the Varcade Games server to log in. The server will give the client back a token, which it can use to fetch the player's profile and a list of currently available games. Once it has a list of game the client can go about displaying them on the landing page that players see once they've logged in. A player can select an active game to play, at which point our client will fetch the leaderboard for that game as well as any statistics that are available for that player. In our case your will only see stats if you have played a Rock Paper Scissors multi-player game. Once all of that is loaded our client can display the game page, at which point the user is free to play the game. That's it for our high level view of the overall system. Later one we will see more sequence diagrams that will help us go through some of the more complex interactions within Varcade Games. For now, let's start scratching beneath the surface...","title":"System Architecture"},{"location":"onboarding/varcade_games/system_architecture/#system-architecture","text":"At this point you should have your local development environment all set up and you should be able to log in to your own private instance of Varcade games and play Rock Paper Scissors Apocalypse . So let's have a look at the big picture - what's actually going on behind the scenes. In the above diagram I have colored all of the components that make up Varcade Games in grey. The green boxes (Redis and MySQL) are third party dependencies. Varcade Games needs them to operate, but they exist as independent products built by someone else. And finally, in blue is our actual game. Rock Paper Scissors Apocalypse. This game has nothing to do with Varcade Games, technically at least. It is plugged into the system, but the system doesn't need it to operate. The game doesn't need Varcade Games to function either. It is using it as a host. I'll briefly introduce the various components here before we dig more deeply into how they work and how to work with them.","title":"System Architecture"},{"location":"onboarding/varcade_games/system_architecture/#components","text":"","title":"Components"},{"location":"onboarding/varcade_games/system_architecture/#varcade-games-client-server","text":"The first box on the left hand side center of the diagram is our Varcade Games Client. This is what the user interacts with. Where they log in, browse games and select games to play. This client is built using Vue.js , so there is a lot of Javascript, HTML and CSS in there. The client connects to a dedicated Varcade Games server. This server is responsible for managing player accounts and managing games. It is built using Django , so we'll be working in Python on the server side. It also uses MySQL as a database to store the player account and game information.","title":"Varcade Games Client &amp; Server"},{"location":"onboarding/varcade_games/system_architecture/#player-stats-server","text":"In our diagram we can see that the Varcade Games Server connects to something called the 'Stats Tracker' server. This server's job is to serve leaderboards and interesting statistics to the game portal. Each game page will have a metrics and leaderboard section, the Varcade Games client gets that information from the Varcade Games server, but that server must request the information from the Stats Tracker server first. This server is built using Flask , which means we're working with Python.","title":"Player Stats Server"},{"location":"onboarding/varcade_games/system_architecture/#matchmaker-server","text":"The Varcade Games client also connects to the Matchmaker server. The client has a built in Matchmaker maker UI so that players can find each other and play together. The Matchmaker server is responsible for creating and managing multi-player games. It is generic by nature and doesn't really know anything about the games that are using it, so each game that wants to use it must be registered with it. This server is also built using Flask , which means we're working with Python again.","title":"Matchmaker Server"},{"location":"onboarding/varcade_games/system_architecture/#redis","text":"You'll notice that both the Stats Tracker and Matchmaker servers connect to Redis , which is a no-sql database. Multi-player games, player stats and leaderboards are all stored in Redis. It provides a number of data structures that are useful for our particular use case.","title":"Redis"},{"location":"onboarding/varcade_games/system_architecture/#the-workers","text":"Both the Stats Tracker and Matchmaker also have 'worker' applications. These are programs that are also written in Python whose job it is to monitor goings on behind the scenes. They track and store player stats coming from games. They clean up old games in the Matchmaker database, and much more. Many server systems require such applications for performing any work that doesn't fit into the typical request-response model of a sever.","title":"The Workers"},{"location":"onboarding/varcade_games/system_architecture/#rps-client-and-server","text":"And finally, we've got our game. This is the game that we have integrated into Varcade Games, which means it is hosted by, and leverages the Matchmaker and Stats Tracker services built in to, Varcade Games. Notice that our diagram shows a connection between the two clients. The game client is embedded in the Varcade Games client. Notice also that the client communicates with its dedicated server in order to play against other players online, but the server also has connections to Varcade Games. First of all, the Matchmaker needs to be able to connect to the game server in order to actually create and manage games. Secondly, the game server needs to send 'events' to a 'stream' in order to keep the Varcade Games system up to date. This 'stream' is more functionality in Redis that we are leveraging. The game client is built using Phaser 3, a 2D game engine built in Javascript. This is the part the player interacts with. The game server is built using Node.js, which is a web server built in Javascript.","title":"RPS Client and Server"},{"location":"onboarding/varcade_games/system_architecture/#interaction","text":"Now that we've been introduced to the various different players in our systems, let's take a look at how the system actually behaves ; how these components actually interact with each other. To represent this visually we will use something called a 'sequence diagram'.","title":"Interaction"},{"location":"onboarding/varcade_games/system_architecture/#sequence-diagrams","text":"In case you've never seen a sequence diagram before, they are essentially just a useful way of visually representing interactions between a number of components in a system over time. For example, here is a very basic sequence diagram that shows the interactions between a customer and a cashier when buying a loaf of bread: What a pleasant and polite interaction it was too. All we've done here is visually represent a customer walking up to a cashier with a loaf of bread. They greet each other, then the cashier scans the bread and tells the customer how much they have to pay. The customer then counts out some cash and gives it to the cashier. The cashier then gives the customer their change before they say goodbye and go their separate ways. The arrows that go between entities represent communication between components . There are also arrows that start and end on a single entity. In our case, when the cashier scans the bread they don't need anything from the customer. They just need to do that action themselves. Same goes for the customer when they are counting out the money needed to pay for the bread. In the sections below we will expand on these concepts to understand how the different entities in the Varcade Games system interact with each other.","title":"Sequence Diagrams"},{"location":"onboarding/varcade_games/system_architecture/#basic-varcade-games-interaction","text":"Let's use a sequence diagram to take a look at some of the interactions you will have already had with Varcade Games. In the below sequence diagram we have 4 entities: User Browser This is the user's web browser, through which it is interacting with our website Varcade Games Server This is the server that manages all of the Varcade Games configuration and data Stats Tracker Server This is the server that manages leaderboards and player stats for our games File Server This is a basic server that serves files This diagram is showing us the most basic interaction that a user will have with Varcade Games. They will: Load the website Log in View a list of games Select a game Play the game Our website is what is known as a 'client side application'. All of the interactions and layouts of our pages are managed through Javascript running in the browser. So when you navigate to Varcade Games you first need to download that Javascript. It is stored on a server whose only job is to serve those files. Once the browser runs the Javascript it will present the user with a log in page. As mentioned earlier, the client will connect to the Varcade Games server to log in. The server will give the client back a token, which it can use to fetch the player's profile and a list of currently available games. Once it has a list of game the client can go about displaying them on the landing page that players see once they've logged in. A player can select an active game to play, at which point our client will fetch the leaderboard for that game as well as any statistics that are available for that player. In our case your will only see stats if you have played a Rock Paper Scissors multi-player game. Once all of that is loaded our client can display the game page, at which point the user is free to play the game. That's it for our high level view of the overall system. Later one we will see more sequence diagrams that will help us go through some of the more complex interactions within Varcade Games. For now, let's start scratching beneath the surface...","title":"Basic Varcade Games interaction"},{"location":"onboarding/varcade_games/tests_and_linters/","text":"Tests & Linters Linter Now that we're making changes to our code we need to make sure that our changes are conforming to our code standards. A linter is a tool that can flag programming mistakes, bugs and code style violations. The Varcade Games client has a linter set up that will check any changes we make and in some cases even fix code style violations for us, if they are trivial enough. From your terminal, navigate to the website project client directory. For example, if your code is located in ~/code/varcade_games then you'd run: 1 cd ~/code/varcade_games/website/client From there you can run: 1 npm run lint This will run a program that checks all of our client javascript code to make sure it conforms to our standards. It should print an output like this: 1 2 > web_portal_client@0.1.0 lint website/client > eslint ./src There's basically no output. As you can see it all looks good. But it won't always be like this, so let's break something so we can experience what that looks like. In your editor/IDE open up website/client/src/main.js . On the very first line that has code on it, add a semi-colon(;) to the end, like this: 1 import Vue from 'vue' ; Now go back to your terminal and run 1 npm run lint This time you should see a nasty looking error: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 website/client/src/main.js 7 :22 error Extra semicolon semi \u2716 1 problem ( 1 error, 0 warnings ) 1 error and 0 warnings potentially fixable with the ` --fix ` option. npm ERR! code ELIFECYCLE npm ERR! errno 1 npm ERR! web_portal_client@0.1.0 lint: ` eslint ./src ` npm ERR! Exit status 1 npm ERR! npm ERR! Failed at the web_portal_client@0.1.0 lint script. npm ERR! This is probably not a problem with npm. There is likely additional logging output above. npm ERR! A complete log of this run can be found in : npm ERR! /tmp/.npm/_logs/2021-08-17T19_14_49_722Z-debug.log The important part is at the top: 1 2 website/client/src/main.js 7:22 error Extra semicolon semi It's telling us that there is an Extra semicolon in the file website/client/src/main.js on line 7, column 22. And indeed, if you count the rows and columns in your editor you will find your ';' at line: 7, col :22. There are many things that will trigger the linter to fail. What we're trying to do is make sure all of the code has a consistent style, which will make it easier to work with - especially is a lot of people are working on the same codebase. Thankfully when the linter picks up trivial things like this it can fix them itself. If you run: 1 npm run lint-fix You will notice we're back to no output: 1 2 > web_portal_client@0.1.0 lint-fix website/client > eslint ./src --fix The linter has removed the semicolon for us, but it cannot do more complex operations. For example, if you add the following code block to the top of main.js : 1 if ( true ) {} And run the linter with the fix option enabled you will get the following: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 > web_portal_client@0.1.0 lint-fix website/client > eslint ./src --fix website/client/src/main.js 34 :5 error Unexpected constant condition no-constant-condition 34 :11 error Empty block statement no-empty \u2716 2 problems ( 2 errors, 0 warnings ) npm ERR! code ELIFECYCLE npm ERR! errno 1 npm ERR! web_portal_client@0.1.0 lint-fix: ` eslint ./src --fix ` npm ERR! Exit status 1 npm ERR! npm ERR! Failed at the web_portal_client@0.1.0 lint-fix script. npm ERR! This is probably not a problem with npm. There is likely additional logging output above. npm ERR! A complete log of this run can be found in : npm ERR! /tmp/.npm/_logs/2021-08-17T19_27_20_052Z-debug.log So the linter has actually made some changes. If you open main.js you will find that the invalid code block we added has been moved down 30 lines or so. This is because our linter doesn't want code before the imports in a file. However, the two remaining lint errors above cannot be fixed automatically - because it would modify logic, and we don't want a linter messing around with logic. In this case it's warning us that if(true) is a constant condition and pointless. It also doesn't allow empty code block like {} . It's important to note that this code will not break the application. It's just not very good code - and the linter can pick up on code that smells a bit bad. The more help we have keeping our codebase clean from bad smelling code, the better. Remove the invalid code block and run the linter again to get everything back to normal. As you work on Varcade Games you will meet a lot of different types of linter - or static analysis tools . Tests Whenever you write code you should probably write some automated tests. In our case, we don't have any client side tests at the moment, but we do have server side tests. So let's run them! In your terminal navigate over to the server directory for the website. For example, if your code is located in ~/code/varcade_games then you'd run: 1 cd ~/code/varcade_games/website/server For our server tests we actually use a docker image, just like for running the actual services. We build an image with all of the code and tests, then we run the container and run the tests. This gives us a consistent environment to run our tests in - everyone running these tests will be running with the same dependencies and configurations. If we just ran the tests on our dev machine we could get different results due to different configuration. I've abstracted away most of the complexity of running the tests so all you need to do is run: 1 make build_test_image This may take a while... Next we run the image as follows: 1 make run_test_image_mounted Once it's done you can run the following make commands to run the actual tests: 1 make run_tests You should see a whole lot of output after running that command, and it hopefully ends with something like the following: 1 ======== 10 passed, 0 warnings in 1 .67s ======== (Ok there might be a few warnings... but the tests should pass!) These tests test the functionality of the game portal - they tell us if something functional broke. So let's break something... Open up website/server/tests/game_portal/games/test_games.py . Find the test called test_create_user_with_short_password . This test case verifies that the server returns an error status if a user submits a password that is too short. In this case we expect and error to occur, so we have this assertion: 1 assert response . status_code == status . HTTP_400_BAD_REQUEST This ensures that the server response is a 400 (bad request) if a user submits a password as basic as foo . Change this line to the following: 1 assert response . status_code == 200 This would mean the request to the server was a success, which is the wrong behavior. Now run the tests again with make run_tests . The out put should have changed: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #<snip> tests/game_portal/accounts/test_accounts.py::TestAccounts::test_create_user_with_short_password FAILED [ 20 % ] #<snip> ______________________________________ TestAccounts.test_create_user_with_short_password ______________________________________ self = <test_accounts.TestAccounts object at 0x7f5b357df3d0> api_client = <rest_framework.test.APIClient object at 0x7f5b35cc7950> def test_create_user_with_short_password ( self, api_client ) : \"\"\" Ensure user is not created for password lengths less than 8. \"\"\" data = { \"username\" : \"foobar\" , \"email\" : \"foobarbaz@example.com\" , \"password\" : \"foo\" , } response = api_client.post ( self.create_url, data, format = \"json\" ) > assert response.status_code == 200 E assert 400 == 200 E +400 E -200 tests/game_portal/accounts/test_accounts.py:51: AssertionError #<snip> =================================================== short test summary info =================================================== FAILED tests/game_portal/accounts/test_accounts.py::TestAccounts::test_create_user_with_short_password - assert 400 == 200 ========================================== 1 failed, 9 passed, 30 warnings in 1 .77s =========================================== In this output we can see that we now have a failing test. It is failing for the exact reason we made it fail: 1 2 3 4 > assert response.status_code == 200 E assert 400 == 200 E +400 E -200 We change our test to expect a 200, but the server is still returning a 400 - because the request is invalid. Go ahead and change the code back to get the tests running again. It's also worth noting that even though the tests are running in a container - our changes to the code were applied automatically. On the server part of the game portal there are some more checks we can do too. Coverage Now try running: 1 make run_coverage This tells us how much of our code is covered by tests: 1 2 3 4 5 6 7 8 9 <snip> game_portal/game_portal/test_settings.py 4 0 100 % game_portal/game_portal/urls.py 22 0 100 % tests/conftest.py 11 1 91 % 12 tests/game_portal/accounts/test_accounts.py 33 0 100 % tests/game_portal/games/test_games.py 40 0 100 % tests/game_portal/profiles/test_profiles.py 33 0 100 % ------------------------------------------------------------------------------------------------------ TOTAL 489 24 95 % Code coverage is a useful indicator about how much test coverage you have but it's important to understand that 100% coverage doesn't mean you have bug free or high quality code. Don't use coverage as a target, use it as a guide. Type Checking For our Python projects we also have some type checking. Python is a dynamically typed language, meaning we have no compiler to tell us about errors and we often have to wait until we are running the code to know whether it even runs. Enter Mypy. Mypy is a static type checker that will analyze our code and tell us if there is any in there that might be problematic. You can run the type checker against the game portal by running: 1 make run_type_checking Which should result in some output like: 1 2 3 4 5 docker exec -it $( docker ps -aqf \"name=gameportal_tests\" ) bash -c '\\ echo \"Running Mypy against web app\" && \\ mypy game_portal' Running Mypy against web app Success: no issues found in 41 source files And that's it for the server side. When working on any project that is expect to live for longer than a couple of months it's important to understand what tools are at your disposal to help ensure you are creating maintainable and extendable code. Now that you can make changes and run tests, let's take a closer at the server side code. It's time to Django.","title":"Tests and Linters"},{"location":"onboarding/varcade_games/tests_and_linters/#tests-linters","text":"","title":"Tests &amp; Linters"},{"location":"onboarding/varcade_games/tests_and_linters/#linter","text":"Now that we're making changes to our code we need to make sure that our changes are conforming to our code standards. A linter is a tool that can flag programming mistakes, bugs and code style violations. The Varcade Games client has a linter set up that will check any changes we make and in some cases even fix code style violations for us, if they are trivial enough. From your terminal, navigate to the website project client directory. For example, if your code is located in ~/code/varcade_games then you'd run: 1 cd ~/code/varcade_games/website/client From there you can run: 1 npm run lint This will run a program that checks all of our client javascript code to make sure it conforms to our standards. It should print an output like this: 1 2 > web_portal_client@0.1.0 lint website/client > eslint ./src There's basically no output. As you can see it all looks good. But it won't always be like this, so let's break something so we can experience what that looks like. In your editor/IDE open up website/client/src/main.js . On the very first line that has code on it, add a semi-colon(;) to the end, like this: 1 import Vue from 'vue' ; Now go back to your terminal and run 1 npm run lint This time you should see a nasty looking error: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 website/client/src/main.js 7 :22 error Extra semicolon semi \u2716 1 problem ( 1 error, 0 warnings ) 1 error and 0 warnings potentially fixable with the ` --fix ` option. npm ERR! code ELIFECYCLE npm ERR! errno 1 npm ERR! web_portal_client@0.1.0 lint: ` eslint ./src ` npm ERR! Exit status 1 npm ERR! npm ERR! Failed at the web_portal_client@0.1.0 lint script. npm ERR! This is probably not a problem with npm. There is likely additional logging output above. npm ERR! A complete log of this run can be found in : npm ERR! /tmp/.npm/_logs/2021-08-17T19_14_49_722Z-debug.log The important part is at the top: 1 2 website/client/src/main.js 7:22 error Extra semicolon semi It's telling us that there is an Extra semicolon in the file website/client/src/main.js on line 7, column 22. And indeed, if you count the rows and columns in your editor you will find your ';' at line: 7, col :22. There are many things that will trigger the linter to fail. What we're trying to do is make sure all of the code has a consistent style, which will make it easier to work with - especially is a lot of people are working on the same codebase. Thankfully when the linter picks up trivial things like this it can fix them itself. If you run: 1 npm run lint-fix You will notice we're back to no output: 1 2 > web_portal_client@0.1.0 lint-fix website/client > eslint ./src --fix The linter has removed the semicolon for us, but it cannot do more complex operations. For example, if you add the following code block to the top of main.js : 1 if ( true ) {} And run the linter with the fix option enabled you will get the following: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 > web_portal_client@0.1.0 lint-fix website/client > eslint ./src --fix website/client/src/main.js 34 :5 error Unexpected constant condition no-constant-condition 34 :11 error Empty block statement no-empty \u2716 2 problems ( 2 errors, 0 warnings ) npm ERR! code ELIFECYCLE npm ERR! errno 1 npm ERR! web_portal_client@0.1.0 lint-fix: ` eslint ./src --fix ` npm ERR! Exit status 1 npm ERR! npm ERR! Failed at the web_portal_client@0.1.0 lint-fix script. npm ERR! This is probably not a problem with npm. There is likely additional logging output above. npm ERR! A complete log of this run can be found in : npm ERR! /tmp/.npm/_logs/2021-08-17T19_27_20_052Z-debug.log So the linter has actually made some changes. If you open main.js you will find that the invalid code block we added has been moved down 30 lines or so. This is because our linter doesn't want code before the imports in a file. However, the two remaining lint errors above cannot be fixed automatically - because it would modify logic, and we don't want a linter messing around with logic. In this case it's warning us that if(true) is a constant condition and pointless. It also doesn't allow empty code block like {} . It's important to note that this code will not break the application. It's just not very good code - and the linter can pick up on code that smells a bit bad. The more help we have keeping our codebase clean from bad smelling code, the better. Remove the invalid code block and run the linter again to get everything back to normal. As you work on Varcade Games you will meet a lot of different types of linter - or static analysis tools .","title":"Linter"},{"location":"onboarding/varcade_games/tests_and_linters/#tests","text":"Whenever you write code you should probably write some automated tests. In our case, we don't have any client side tests at the moment, but we do have server side tests. So let's run them! In your terminal navigate over to the server directory for the website. For example, if your code is located in ~/code/varcade_games then you'd run: 1 cd ~/code/varcade_games/website/server For our server tests we actually use a docker image, just like for running the actual services. We build an image with all of the code and tests, then we run the container and run the tests. This gives us a consistent environment to run our tests in - everyone running these tests will be running with the same dependencies and configurations. If we just ran the tests on our dev machine we could get different results due to different configuration. I've abstracted away most of the complexity of running the tests so all you need to do is run: 1 make build_test_image This may take a while... Next we run the image as follows: 1 make run_test_image_mounted Once it's done you can run the following make commands to run the actual tests: 1 make run_tests You should see a whole lot of output after running that command, and it hopefully ends with something like the following: 1 ======== 10 passed, 0 warnings in 1 .67s ======== (Ok there might be a few warnings... but the tests should pass!) These tests test the functionality of the game portal - they tell us if something functional broke. So let's break something... Open up website/server/tests/game_portal/games/test_games.py . Find the test called test_create_user_with_short_password . This test case verifies that the server returns an error status if a user submits a password that is too short. In this case we expect and error to occur, so we have this assertion: 1 assert response . status_code == status . HTTP_400_BAD_REQUEST This ensures that the server response is a 400 (bad request) if a user submits a password as basic as foo . Change this line to the following: 1 assert response . status_code == 200 This would mean the request to the server was a success, which is the wrong behavior. Now run the tests again with make run_tests . The out put should have changed: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #<snip> tests/game_portal/accounts/test_accounts.py::TestAccounts::test_create_user_with_short_password FAILED [ 20 % ] #<snip> ______________________________________ TestAccounts.test_create_user_with_short_password ______________________________________ self = <test_accounts.TestAccounts object at 0x7f5b357df3d0> api_client = <rest_framework.test.APIClient object at 0x7f5b35cc7950> def test_create_user_with_short_password ( self, api_client ) : \"\"\" Ensure user is not created for password lengths less than 8. \"\"\" data = { \"username\" : \"foobar\" , \"email\" : \"foobarbaz@example.com\" , \"password\" : \"foo\" , } response = api_client.post ( self.create_url, data, format = \"json\" ) > assert response.status_code == 200 E assert 400 == 200 E +400 E -200 tests/game_portal/accounts/test_accounts.py:51: AssertionError #<snip> =================================================== short test summary info =================================================== FAILED tests/game_portal/accounts/test_accounts.py::TestAccounts::test_create_user_with_short_password - assert 400 == 200 ========================================== 1 failed, 9 passed, 30 warnings in 1 .77s =========================================== In this output we can see that we now have a failing test. It is failing for the exact reason we made it fail: 1 2 3 4 > assert response.status_code == 200 E assert 400 == 200 E +400 E -200 We change our test to expect a 200, but the server is still returning a 400 - because the request is invalid. Go ahead and change the code back to get the tests running again. It's also worth noting that even though the tests are running in a container - our changes to the code were applied automatically. On the server part of the game portal there are some more checks we can do too.","title":"Tests"},{"location":"onboarding/varcade_games/tests_and_linters/#coverage","text":"Now try running: 1 make run_coverage This tells us how much of our code is covered by tests: 1 2 3 4 5 6 7 8 9 <snip> game_portal/game_portal/test_settings.py 4 0 100 % game_portal/game_portal/urls.py 22 0 100 % tests/conftest.py 11 1 91 % 12 tests/game_portal/accounts/test_accounts.py 33 0 100 % tests/game_portal/games/test_games.py 40 0 100 % tests/game_portal/profiles/test_profiles.py 33 0 100 % ------------------------------------------------------------------------------------------------------ TOTAL 489 24 95 % Code coverage is a useful indicator about how much test coverage you have but it's important to understand that 100% coverage doesn't mean you have bug free or high quality code. Don't use coverage as a target, use it as a guide.","title":"Coverage"},{"location":"onboarding/varcade_games/tests_and_linters/#type-checking","text":"For our Python projects we also have some type checking. Python is a dynamically typed language, meaning we have no compiler to tell us about errors and we often have to wait until we are running the code to know whether it even runs. Enter Mypy. Mypy is a static type checker that will analyze our code and tell us if there is any in there that might be problematic. You can run the type checker against the game portal by running: 1 make run_type_checking Which should result in some output like: 1 2 3 4 5 docker exec -it $( docker ps -aqf \"name=gameportal_tests\" ) bash -c '\\ echo \"Running Mypy against web app\" && \\ mypy game_portal' Running Mypy against web app Success: no issues found in 41 source files And that's it for the server side. When working on any project that is expect to live for longer than a couple of months it's important to understand what tools are at your disposal to help ensure you are creating maintainable and extendable code. Now that you can make changes and run tests, let's take a closer at the server side code. It's time to Django.","title":"Type Checking"},{"location":"setup/","text":"Setting up your Dev Environment This section will teach you how to set up your computer to run a distributed system Code Over time aims to provide realistic hands-on experience with a real software product, and so this section covers what is typically the first thing a software engineer does during their first few days at a new company. That is, set up their shiny new work machine and get the project they will be working on running. This is something you need to learn by doing , so let's start doing.","title":"Introduction"},{"location":"setup/#setting-up-your-dev-environment","text":"This section will teach you how to set up your computer to run a distributed system Code Over time aims to provide realistic hands-on experience with a real software product, and so this section covers what is typically the first thing a software engineer does during their first few days at a new company. That is, set up their shiny new work machine and get the project they will be working on running. This is something you need to learn by doing , so let's start doing.","title":"Setting up your Dev Environment"},{"location":"setup/next_steps/","text":"What do I do now? The answer to that question is entirely up to you I'm afraid. If you'd like to add a real game that you can play to your Game Portal then open up the README for the game_rps project. It will guide you through the specific settings you need to do that. The onboarding section of this site will guide you through the overall system design and also provide more insights into specific areas of the project and the code. It covers topics like: The system architecture The structure of the various different projects How to test the various different systems How to make changes and see the impact in real time Unless you've already got experience working on a moderately sized project like this, I think the onboarding course is a great next step. If you are more experienced and confident then I'd recommend just jumping into the code and trying to figure out how everything works. Regardless of your choice, I really hope that working with Varcade Games is a great learning experience and helps you grow as an engineer. Good luck! - Kev","title":"Next Steps"},{"location":"setup/next_steps/#what-do-i-do-now","text":"The answer to that question is entirely up to you I'm afraid. If you'd like to add a real game that you can play to your Game Portal then open up the README for the game_rps project. It will guide you through the specific settings you need to do that. The onboarding section of this site will guide you through the overall system design and also provide more insights into specific areas of the project and the code. It covers topics like: The system architecture The structure of the various different projects How to test the various different systems How to make changes and see the impact in real time Unless you've already got experience working on a moderately sized project like this, I think the onboarding course is a great next step. If you are more experienced and confident then I'd recommend just jumping into the code and trying to figure out how everything works. Regardless of your choice, I really hope that working with Varcade Games is a great learning experience and helps you grow as an engineer. Good luck! - Kev","title":"What do I do now?"},{"location":"setup/environment_setup/intro/","text":"Introduction A Varcade Games development stack can be set up on Windows, Linux or MacOS. You may or may not have heard of Linux or MacOS. They are operating systems (OS). When you start up you computer you boot the operating system, which is what allows you to actually do things with the computer. Most people are familiar with Windows as it comes pre-installed on most PCs, but there are other options out there too - Linux being the main on. MacOS is the operating system that runs on Mac computers. In terms of effort, Linux is definitely the easiest environment to set up, followed by by MacOS. Windows is a bit more involved - but it's an upfront cost that you only need to pay once. This is why many software engineers actually prefer to use a Mac or a machine that runs Linux - they are more 'developer friendly' in many cases, especially for server side development. In general I would recommend working with Linux as it's an extremely valuable skill to have as a software engineer, but the choice is yours. If you are running Windows we will actually set up a kind of Linux on your machine during this course, so you will be using a Linux system, but from the comfort of your Windows environment. Hopefully this experience will be enough to make you take the plunge and switch over to using Linux full time. Follow the guide for whichever OS you are using to get setup: Linux Windows OSX Info If you've already got Docker set up and you know what you're doing you can skip straight to the Testing your setup page . Info Technically I should say GNU/Linux and not Linux when referring to this operating system - but this isn't the time or place to get into that.","title":"Overview"},{"location":"setup/environment_setup/intro/#introduction","text":"A Varcade Games development stack can be set up on Windows, Linux or MacOS. You may or may not have heard of Linux or MacOS. They are operating systems (OS). When you start up you computer you boot the operating system, which is what allows you to actually do things with the computer. Most people are familiar with Windows as it comes pre-installed on most PCs, but there are other options out there too - Linux being the main on. MacOS is the operating system that runs on Mac computers. In terms of effort, Linux is definitely the easiest environment to set up, followed by by MacOS. Windows is a bit more involved - but it's an upfront cost that you only need to pay once. This is why many software engineers actually prefer to use a Mac or a machine that runs Linux - they are more 'developer friendly' in many cases, especially for server side development. In general I would recommend working with Linux as it's an extremely valuable skill to have as a software engineer, but the choice is yours. If you are running Windows we will actually set up a kind of Linux on your machine during this course, so you will be using a Linux system, but from the comfort of your Windows environment. Hopefully this experience will be enough to make you take the plunge and switch over to using Linux full time. Follow the guide for whichever OS you are using to get setup: Linux Windows OSX Info If you've already got Docker set up and you know what you're doing you can skip straight to the Testing your setup page . Info Technically I should say GNU/Linux and not Linux when referring to this operating system - but this isn't the time or place to get into that.","title":"Introduction"},{"location":"setup/environment_setup/linux/","text":"Linux Docker You will need to install Docker Engine in order to run Varcade Games locally. Official instructions for your distro can be found here . Docker-Compose You will also need to install Docker Compose. You can follow the official instructions here . That's about it for your setup on Linux, now let's test it - head over to the guide for doing that .","title":"Linux"},{"location":"setup/environment_setup/linux/#linux","text":"","title":"Linux"},{"location":"setup/environment_setup/linux/#docker","text":"You will need to install Docker Engine in order to run Varcade Games locally. Official instructions for your distro can be found here .","title":"Docker"},{"location":"setup/environment_setup/linux/#docker-compose","text":"You will also need to install Docker Compose. You can follow the official instructions here . That's about it for your setup on Linux, now let's test it - head over to the guide for doing that .","title":"Docker-Compose"},{"location":"setup/environment_setup/osx/","text":"OSX Docker In order to run Varcade Games on your Mac you will need to install Docker for Mac. Follow the official guide to get it set up. Developer Tools You will also need some standard developer tools. To get these you can install XCode directly from the Apple app store, or you can download from the developer downloads (login required). If you've ever done any development on your Mac you've likely installed this stuff already. Git You will also need 'Git' (source control) for getting access to the code. Again, if you've done any development you likely have Git on your system already - but if not, don't worry - you can follow the official install instructions here . You can check if git is installed already by typing git --version in your terminal (to open your terminal press CMD + Space, then type terminal , then hit enter). You should see some output that looks like this: 1 git version 2.31.1 That's about it. Let's test our setup - head over to the guide for doing that .","title":"OSX"},{"location":"setup/environment_setup/osx/#osx","text":"","title":"OSX"},{"location":"setup/environment_setup/osx/#docker","text":"In order to run Varcade Games on your Mac you will need to install Docker for Mac. Follow the official guide to get it set up.","title":"Docker"},{"location":"setup/environment_setup/osx/#developer-tools","text":"You will also need some standard developer tools. To get these you can install XCode directly from the Apple app store, or you can download from the developer downloads (login required). If you've ever done any development on your Mac you've likely installed this stuff already.","title":"Developer Tools"},{"location":"setup/environment_setup/osx/#git","text":"You will also need 'Git' (source control) for getting access to the code. Again, if you've done any development you likely have Git on your system already - but if not, don't worry - you can follow the official install instructions here . You can check if git is installed already by typing git --version in your terminal (to open your terminal press CMD + Space, then type terminal , then hit enter). You should see some output that looks like this: 1 git version 2.31.1 That's about it. Let's test our setup - head over to the guide for doing that .","title":"Git"},{"location":"setup/environment_setup/testing_your_setup/","text":"Testing your setup At this point you should have Docker up and running, which means you can now run the Docker image that was included in the zip you downloaded to begin with. Linux and MacOS Run the following command in your terminal: 1 docker --version If docker is up and running you should see some output similar to this: 1 Docker version 20 .10.11, build 485636f Windows On windows you will need to open Powershell, if it's not already open then run: 1 docker --version If docker is up and running you should see some output similar to this: 1 Docker version 20 .10.11, build 485636f If you did see this then congratulations! You've successfully setup your computer to be able to work on Varcade Games! If you did not see this, then it's time to start investigating - but don't worry, there is opportunity here. Learning how to deal with environment specific issues when setting up / working with a project is essential for every software engineer. If you can't get to the bottom of the issue yourself you can go ahead and create and issue on the Github Repo .","title":"Testing your setup"},{"location":"setup/environment_setup/testing_your_setup/#testing-your-setup","text":"At this point you should have Docker up and running, which means you can now run the Docker image that was included in the zip you downloaded to begin with.","title":"Testing your setup"},{"location":"setup/environment_setup/testing_your_setup/#linux-and-macos","text":"Run the following command in your terminal: 1 docker --version If docker is up and running you should see some output similar to this: 1 Docker version 20 .10.11, build 485636f","title":"Linux and MacOS"},{"location":"setup/environment_setup/testing_your_setup/#windows","text":"On windows you will need to open Powershell, if it's not already open then run: 1 docker --version If docker is up and running you should see some output similar to this: 1 Docker version 20 .10.11, build 485636f If you did see this then congratulations! You've successfully setup your computer to be able to work on Varcade Games! If you did not see this, then it's time to start investigating - but don't worry, there is opportunity here. Learning how to deal with environment specific issues when setting up / working with a project is essential for every software engineer. If you can't get to the bottom of the issue yourself you can go ahead and create and issue on the Github Repo .","title":"Windows"},{"location":"setup/environment_setup/windows/","text":"Preparing Windows for development To get your Windows environment we will do three things: Install WSL2 - Windows Subsystem for Linux. This allows you to run Linux from within Windows Install Docker for Windows - Docker is a virtualization based container management system. Install VSCode - VSCode is a popular code editor developed by Microsoft Info On a number of occasions throughout your Windows setup you will be asked to run an application as an administrator . To do this type the application's name (eg. 'notepad' or 'Powershell') into the Windows search bar, right-click the menu item that appears and select Run as administrator . Update Windows The first thing we will do is make sure our Windows system is up to date. Type updates in the Windows search bar and click the Check for updates option that appears. Install all system updates - hopefully your system is up to date already and there's nothing to do here. If you're not up to date you might have to sit through a few restarts. WSL 2 Next we need to install WSL 2, or Windows Subsystem for Linux . This basically allows us to run Linux directly within our Windows environment. There's a great guide to setting up WSL2 in the official Microsoft docs . Info The above guide will ask you to run commands in Windows Powershell . You will likely want to copy and paste these commands as they can be quite long. To paste any text that you have copied into powershell simply right-click within the Powershell window. Follow those steps before continuing here (up to install windows terminal ). You can pick whichever Linux distro you like, though I recommend Ubuntu 20.04 LTS if you're new to Linux. Ubuntu Setup Once that process is done we can start setting up our Linux environment - which is where we will run the actual Varcade Games project. If you correctly followed the Microsoft guide, you should already have your Linux terminal open, but if not open up the Ubuntu app (or whichever distro you installed) and get your user setup. To do this you can simply type Ubuntu in the Windows search bar, and select the app. You will be greeted by a terminal, which will prompt you to enter user information: While we're here we should also install Docker Compose - which is a tool that helps us manage Docker containers. Follow the official installation guide, but remember you are running this in your Linux terminal, so you need to select the Linux instructions. Official install guide . Docker Next install Docker for Windows . The default install configuration is fine for our needs, so just go with defaults - but make sure that the Install required Windows components for WSL 2 option is checked: Once the install is complete you will need to log out and back in again. Then Docker should start up automatically. It will offer you a tutorial... you can skip that, we can figure this out on our own. Info If you are running on a low powered device (limited memory in particular), you should create a .wslconfig file to limit the amount of resources that Docker uses. To do this simply put a file called .wslconfig in your Windows home ( C:\\Users\\<your user name> ) directory with the following values saved in the file: 1 2 3 [wsl2] memory=2gb processors=2 You can modify the above values as needed for your environment. VSCode and Git Next download and install VSCode (default settings are all fine). You will also need a Github account - so if you haven't got one you'll need to create one now. That's it for the installation part - most of our software dependencies are now sorted. To test that it's all working properly head over to the guide for doing that .","title":"Windows"},{"location":"setup/environment_setup/windows/#preparing-windows-for-development","text":"To get your Windows environment we will do three things: Install WSL2 - Windows Subsystem for Linux. This allows you to run Linux from within Windows Install Docker for Windows - Docker is a virtualization based container management system. Install VSCode - VSCode is a popular code editor developed by Microsoft Info On a number of occasions throughout your Windows setup you will be asked to run an application as an administrator . To do this type the application's name (eg. 'notepad' or 'Powershell') into the Windows search bar, right-click the menu item that appears and select Run as administrator .","title":"Preparing Windows for development"},{"location":"setup/environment_setup/windows/#update-windows","text":"The first thing we will do is make sure our Windows system is up to date. Type updates in the Windows search bar and click the Check for updates option that appears. Install all system updates - hopefully your system is up to date already and there's nothing to do here. If you're not up to date you might have to sit through a few restarts.","title":"Update Windows"},{"location":"setup/environment_setup/windows/#wsl-2","text":"Next we need to install WSL 2, or Windows Subsystem for Linux . This basically allows us to run Linux directly within our Windows environment. There's a great guide to setting up WSL2 in the official Microsoft docs . Info The above guide will ask you to run commands in Windows Powershell . You will likely want to copy and paste these commands as they can be quite long. To paste any text that you have copied into powershell simply right-click within the Powershell window. Follow those steps before continuing here (up to install windows terminal ). You can pick whichever Linux distro you like, though I recommend Ubuntu 20.04 LTS if you're new to Linux.","title":"WSL 2"},{"location":"setup/environment_setup/windows/#ubuntu-setup","text":"Once that process is done we can start setting up our Linux environment - which is where we will run the actual Varcade Games project. If you correctly followed the Microsoft guide, you should already have your Linux terminal open, but if not open up the Ubuntu app (or whichever distro you installed) and get your user setup. To do this you can simply type Ubuntu in the Windows search bar, and select the app. You will be greeted by a terminal, which will prompt you to enter user information: While we're here we should also install Docker Compose - which is a tool that helps us manage Docker containers. Follow the official installation guide, but remember you are running this in your Linux terminal, so you need to select the Linux instructions. Official install guide .","title":"Ubuntu Setup"},{"location":"setup/environment_setup/windows/#docker","text":"Next install Docker for Windows . The default install configuration is fine for our needs, so just go with defaults - but make sure that the Install required Windows components for WSL 2 option is checked: Once the install is complete you will need to log out and back in again. Then Docker should start up automatically. It will offer you a tutorial... you can skip that, we can figure this out on our own. Info If you are running on a low powered device (limited memory in particular), you should create a .wslconfig file to limit the amount of resources that Docker uses. To do this simply put a file called .wslconfig in your Windows home ( C:\\Users\\<your user name> ) directory with the following values saved in the file: 1 2 3 [wsl2] memory=2gb processors=2 You can modify the above values as needed for your environment.","title":"Docker"},{"location":"setup/environment_setup/windows/#vscode-and-git","text":"Next download and install VSCode (default settings are all fine). You will also need a Github account - so if you haven't got one you'll need to create one now. That's it for the installation part - most of our software dependencies are now sorted. To test that it's all working properly head over to the guide for doing that .","title":"VSCode and Git"},{"location":"setup/varcade_games/adding_a_game/","text":"Adding a game to Varcade Games Navigate your browser to localhost:8000/admin . You should be greeted by a login page. Use the credentials that you provided in the early step where you ran ./manage.py createsuperuser . Once logged in you should see a menu that looks like this: Click the add link under the GAMES category. To start with we're going to add a game in the 'Coming Soon' state, which allows us to configure and view a game without actually needing to provide a playable game. Fill in all of the fields with dummy data, for example: Game id: test_game Name: My Game Desc: A great game that you should play! Client url: placeholder_url Cover art: <See below> Stats config: <See below> Game type: SinglePlayerOnly Game State: Coming Soon Adding 'Cover Art' and 'Stats config' There is some cover art we can use in the rps_game project. You will find this file in the game_rps project in the folder: game_rps/client/assets/exrps_cover.jpg . In that same directory there is also a file called exrps_stats.json , you will need to upload that file in the stats config section of the admin panel. On Windows This might be a bit confusing on Windows. The file we want to upload to our browser lives on our Ubuntu instance, so how do we actually access it from Windows? In VSCode you can right click the image and select reveal in file explorer . This will open up a window showing the folder that contains the file. At the top of the window is a path to the file: Once you click the path it will turn into a text field that you can copy and paste: Copy that path and then select the browse button in the admin interface. You can now paste the image page in the upload window that pops up and select the desired file: Hit the save button and you're done. Viewing the game All that's left is to head back over to localhost:8002 and check out the game! Still nothing exciting going on there because we can't actually play anything - but we have verified that the Game Portal is working correctly. And that's it - you've successfully setup Varcade Games, so I guess we should talk about what to do next...","title":"Adding a game"},{"location":"setup/varcade_games/adding_a_game/#adding-a-game-to-varcade-games","text":"Navigate your browser to localhost:8000/admin . You should be greeted by a login page. Use the credentials that you provided in the early step where you ran ./manage.py createsuperuser . Once logged in you should see a menu that looks like this: Click the add link under the GAMES category. To start with we're going to add a game in the 'Coming Soon' state, which allows us to configure and view a game without actually needing to provide a playable game. Fill in all of the fields with dummy data, for example: Game id: test_game Name: My Game Desc: A great game that you should play! Client url: placeholder_url Cover art: <See below> Stats config: <See below> Game type: SinglePlayerOnly Game State: Coming Soon","title":"Adding a game to Varcade Games"},{"location":"setup/varcade_games/adding_a_game/#adding-cover-art-and-stats-config","text":"There is some cover art we can use in the rps_game project. You will find this file in the game_rps project in the folder: game_rps/client/assets/exrps_cover.jpg . In that same directory there is also a file called exrps_stats.json , you will need to upload that file in the stats config section of the admin panel.","title":"Adding 'Cover Art' and 'Stats config'"},{"location":"setup/varcade_games/adding_a_game/#on-windows","text":"This might be a bit confusing on Windows. The file we want to upload to our browser lives on our Ubuntu instance, so how do we actually access it from Windows? In VSCode you can right click the image and select reveal in file explorer . This will open up a window showing the folder that contains the file. At the top of the window is a path to the file: Once you click the path it will turn into a text field that you can copy and paste: Copy that path and then select the browse button in the admin interface. You can now paste the image page in the upload window that pops up and select the desired file: Hit the save button and you're done.","title":"On Windows"},{"location":"setup/varcade_games/adding_a_game/#viewing-the-game","text":"All that's left is to head back over to localhost:8002 and check out the game! Still nothing exciting going on there because we can't actually play anything - but we have verified that the Game Portal is working correctly. And that's it - you've successfully setup Varcade Games, so I guess we should talk about what to do next...","title":"Viewing the game"},{"location":"setup/varcade_games/get_the_code/","text":"Get the code All of the code for Varcade Games is available via Github, meaning it is available to you right now! Open up your terminal. If you're running Windows this will be the Ubuntu terminal that we created in the Windows setup (you can open it by typing Ubuntu in your search bar). Forking & Cloning At this point you have two options: Fork the repo Clone the repo Forking the repo means you'll create your own copy of the entire codebase within Github. This is worth doing if you plan to plan to actively work on Varcade Games and want to save any changes you make to the code. You will have your own space to work on - you will own it. Cloning creates a copy of the codebase on your local machine. You will not be able to push changes back to the main repository, but you can make whatever changes you want locally. I recommend forking Varcade Games. It takes zero effort and you will end up with your own copy of the code that evolves over time. It also makes it easier for you to keep your changes safe and backed up in Github. Local Setup Before we fork or clone anything, we should organize our local environment a bit. First, create a directory to put all of the code in: 1 2 3 cd ~/ mkdir code cd code Info The above commands should be run in your terminal. So in Windows you should be running this from your Linux app. For Linux and MacOS you can use your standard terminal. The above is three distinct commands: cd ~/ - This C hanges D irectory to your home directory, which is represented by ~/ mkdir code - This create a new directory named code cd code - This C hanges D irectory to your new directory Next we will use Git - our Source Control Management software of choice to actually download the code. Forking To create a fork you need to open up the project repository in Github . On the project page you will find a 'Fork' button at the top right of the screen: Click that button to have Github create a copy of the repo. That copy will be stored under your account. This is the project you will be working on from here on out. Once that's done you can head back over to your terminal and clone your repo to your local machine with the following command: 1 git clone https://github.com/<your user name>/varcade_games.git This will create a new directory called varcade_games in your current directory and that directory contains all of the code. Github will also provide a handy link for you to clone if you select the Code button from the UI: Info You can make your project private in the settings screen, which would mean that only you can view and make changes to it. If you do this you will need to set up SSH keys to privately manage the repo. Github provides documentation on how to do this. Cloning To simply clone the main code repositories, copy and run the following command in your terminal: 1 git clone https://github.com/Code-Over-Time/varcade_games.git This will create a new directory called varcade_games in your current directory and that directory contains all of the code. That's it. Working with the code Now that you've got the code on your computer you are ready to start working with it. You can use the editor/IDE of your choice, I won't judge. I used Sublime text and Vim to write all of this code. VSCode is popular with a lot of developers and is probably a good choice if you don't already have a preferred setup. On Windows Once the project is cloned you can do something pretty cool on Windows. Run the following command from your Ubuntu terminal (from the same directory you ran the clone command): 1 code . This is a special program in the Windows Ubuntu app that will open up VSCode (we installed this on a previous step) on your local machine, but connect it to the Ubuntu instance so that you can modify the code that we just cloned directly from Windows! Feel free to explore the code for a while before proceeding. There are detailed README files in each project folder and in all first level sub-folders that should help you understand what each of the different pieces is doing. Once you're ready to run the actual project, move on to the next section.","title":"Get the code"},{"location":"setup/varcade_games/get_the_code/#get-the-code","text":"All of the code for Varcade Games is available via Github, meaning it is available to you right now! Open up your terminal. If you're running Windows this will be the Ubuntu terminal that we created in the Windows setup (you can open it by typing Ubuntu in your search bar).","title":"Get the code"},{"location":"setup/varcade_games/get_the_code/#forking-cloning","text":"At this point you have two options: Fork the repo Clone the repo Forking the repo means you'll create your own copy of the entire codebase within Github. This is worth doing if you plan to plan to actively work on Varcade Games and want to save any changes you make to the code. You will have your own space to work on - you will own it. Cloning creates a copy of the codebase on your local machine. You will not be able to push changes back to the main repository, but you can make whatever changes you want locally. I recommend forking Varcade Games. It takes zero effort and you will end up with your own copy of the code that evolves over time. It also makes it easier for you to keep your changes safe and backed up in Github.","title":"Forking &amp; Cloning"},{"location":"setup/varcade_games/get_the_code/#local-setup","text":"Before we fork or clone anything, we should organize our local environment a bit. First, create a directory to put all of the code in: 1 2 3 cd ~/ mkdir code cd code Info The above commands should be run in your terminal. So in Windows you should be running this from your Linux app. For Linux and MacOS you can use your standard terminal. The above is three distinct commands: cd ~/ - This C hanges D irectory to your home directory, which is represented by ~/ mkdir code - This create a new directory named code cd code - This C hanges D irectory to your new directory Next we will use Git - our Source Control Management software of choice to actually download the code.","title":"Local Setup"},{"location":"setup/varcade_games/get_the_code/#forking","text":"To create a fork you need to open up the project repository in Github . On the project page you will find a 'Fork' button at the top right of the screen: Click that button to have Github create a copy of the repo. That copy will be stored under your account. This is the project you will be working on from here on out. Once that's done you can head back over to your terminal and clone your repo to your local machine with the following command: 1 git clone https://github.com/<your user name>/varcade_games.git This will create a new directory called varcade_games in your current directory and that directory contains all of the code. Github will also provide a handy link for you to clone if you select the Code button from the UI: Info You can make your project private in the settings screen, which would mean that only you can view and make changes to it. If you do this you will need to set up SSH keys to privately manage the repo. Github provides documentation on how to do this.","title":"Forking"},{"location":"setup/varcade_games/get_the_code/#cloning","text":"To simply clone the main code repositories, copy and run the following command in your terminal: 1 git clone https://github.com/Code-Over-Time/varcade_games.git This will create a new directory called varcade_games in your current directory and that directory contains all of the code. That's it.","title":"Cloning"},{"location":"setup/varcade_games/get_the_code/#working-with-the-code","text":"Now that you've got the code on your computer you are ready to start working with it. You can use the editor/IDE of your choice, I won't judge. I used Sublime text and Vim to write all of this code. VSCode is popular with a lot of developers and is probably a good choice if you don't already have a preferred setup.","title":"Working with the code"},{"location":"setup/varcade_games/get_the_code/#on-windows","text":"Once the project is cloned you can do something pretty cool on Windows. Run the following command from your Ubuntu terminal (from the same directory you ran the clone command): 1 code . This is a special program in the Windows Ubuntu app that will open up VSCode (we installed this on a previous step) on your local machine, but connect it to the Ubuntu instance so that you can modify the code that we just cloned directly from Windows! Feel free to explore the code for a while before proceeding. There are detailed README files in each project folder and in all first level sub-folders that should help you understand what each of the different pieces is doing. Once you're ready to run the actual project, move on to the next section.","title":"On Windows"},{"location":"setup/varcade_games/intro/","text":"Varcade Games Varcade Games is an on-line gaming portal. It's a place where single and multi player Javascript games are hosted and is made up of a number of interconnected components. This gaming portal provides 'hooks' so that other developers can build and embed games within the portal, like a built in matchmaker for multi-player games and leaderboard tracking. In order to work with Varcade Games you'll need to setup the following components: The main game portal website Client & server The Matchmaker A server we use to connect players The Game A single player and multi-player fighting game... of sorts The Game Server A server that is plugged into the matchmaker Server authoritative multi-player gaming The Stats Tracker A server we use to create leaderboards Prometheus & Grafana Metrics and graphs for monitoring the project Build tools The tools needed to build and run all of the above That might seem like a lot, but there are a bunch of handy tools at your disposal to make running all of this easy. So let's go get our hands on the code and get it running!","title":"Varcade Games"},{"location":"setup/varcade_games/intro/#varcade-games","text":"Varcade Games is an on-line gaming portal. It's a place where single and multi player Javascript games are hosted and is made up of a number of interconnected components. This gaming portal provides 'hooks' so that other developers can build and embed games within the portal, like a built in matchmaker for multi-player games and leaderboard tracking. In order to work with Varcade Games you'll need to setup the following components: The main game portal website Client & server The Matchmaker A server we use to connect players The Game A single player and multi-player fighting game... of sorts The Game Server A server that is plugged into the matchmaker Server authoritative multi-player gaming The Stats Tracker A server we use to create leaderboards Prometheus & Grafana Metrics and graphs for monitoring the project Build tools The tools needed to build and run all of the above That might seem like a lot, but there are a bunch of handy tools at your disposal to make running all of this easy. So let's go get our hands on the code and get it running!","title":"Varcade Games"},{"location":"setup/varcade_games/running_vcg/","text":"Building the applications From your terminal, open the build_tools directory: 1 cd varcade_games/build_tools Now run the following command: 1 echo \"ENV_CODE_OVER_TIME_ROOT=~/code/varcade_games\" > .env.local There should now be a new file in the build_tools directory called .env.local . This file tells the build scripts where the code is, so it's pretty important. Info The above commands assume that you put all of the project code in the ~/code directory, as directed earlier in the course. If you cloned the code to a different location you will need to update the path of the Varcade Games directory accordingly. Building Varcade Games Next we need to install an additional tool for building and running the project: Make - A standard tool for creating and running build scripts Windows (Ubuntu terminal) / Linux 1 sudo apt install make Info This command assumes you are running on Ubuntu, you will need to update to fit your distro if you are not running Ubuntu. MacOS On MacOS you should already have the developer tools installed from a previous step. This will include Make already so you should have nothing to do here. Docker Let's also make sure Docker is running, you can check this by running the command: 1 docker ps As long as you don't see an error you should be good to go. Windows On Windows it's worth double checking our Docker settings. Open Docker and open the setting screen to: Docker > Settings > Resources > WSL Integration > Enable integration with additional distros Make sure that Ubuntu-20.04 is checked in the Enable integration with additional distros section: Running the build Back in your terminal, run: 1 make build This will kick off a build of the various different applications. This will take a few minutes as all of the dependencies will need to download. Nearly there! Running the applications All we need to do now is run make start from the terminal. That will start up all of the applications and you can check their state by running make ps . If any of the services fail to start, run make start again (game-portal will likely fail to start as it depends on the DB starting up first). Configuring the site Before we can actually interact with Varcade Games we need to initialize the database. Run the following command to connect to the game-portal application: 1 docker exec -it game-portal bash Next run: 1 ./manage.py migrate You will see some output like this: Next run: 1 ./manage.py createsuperuser You will need to follow a few steps to create your admin user account for managing Varcade Games. Once that's done type exit and hit enter to get back to your Ubuntu terminal. We have one final thing to do - that is set up our local networking environment. Connecting to Varcade Games On Windows Open notepad as administrator. Then select File > Open and navigate to C:\\Windows\\System32\\drivers\\etc\\ and open the file called hosts . The directory may appear empty, so be sure to select all files from the drop down at the bottom right that says text files . Add the following line to the bottom of the file: 1 127 .0.0.1 varcade.local api.varcade.local games.varcade.local matchmaker.varcade.local rps.varcade.local Save and close notepad. On Linux / MacOS Add the following line to the bottom of /etc/hosts : 1 127 .0.0.1 varcade.local api.varcade.local games.varcade.local matchmaker.varcade.local rps.varcade.local The following command will take care of that for you: 1 sudo -- sh -c 'echo \"127.0.0.1 varcade.local api.varcade.local games.varcade.local matchmaker.varcade.local rps.varcade.local\" >> /etc/hosts' Viewing the site Now, if you point your browser at localhost:8002 you should arrive at the landing page for Varcade Games . You can log in with the username and password you entered in the previous step when you ran ./manage.py createsuperuser . Unfortunately there won't be much to see. We need to add game...","title":"Running Varcade Games"},{"location":"setup/varcade_games/running_vcg/#building-the-applications","text":"From your terminal, open the build_tools directory: 1 cd varcade_games/build_tools Now run the following command: 1 echo \"ENV_CODE_OVER_TIME_ROOT=~/code/varcade_games\" > .env.local There should now be a new file in the build_tools directory called .env.local . This file tells the build scripts where the code is, so it's pretty important. Info The above commands assume that you put all of the project code in the ~/code directory, as directed earlier in the course. If you cloned the code to a different location you will need to update the path of the Varcade Games directory accordingly.","title":"Building the applications"},{"location":"setup/varcade_games/running_vcg/#building-varcade-games","text":"Next we need to install an additional tool for building and running the project: Make - A standard tool for creating and running build scripts","title":"Building Varcade Games"},{"location":"setup/varcade_games/running_vcg/#windows-ubuntu-terminal-linux","text":"1 sudo apt install make Info This command assumes you are running on Ubuntu, you will need to update to fit your distro if you are not running Ubuntu.","title":"Windows (Ubuntu terminal) / Linux"},{"location":"setup/varcade_games/running_vcg/#macos","text":"On MacOS you should already have the developer tools installed from a previous step. This will include Make already so you should have nothing to do here.","title":"MacOS"},{"location":"setup/varcade_games/running_vcg/#docker","text":"Let's also make sure Docker is running, you can check this by running the command: 1 docker ps As long as you don't see an error you should be good to go.","title":"Docker"},{"location":"setup/varcade_games/running_vcg/#windows","text":"On Windows it's worth double checking our Docker settings. Open Docker and open the setting screen to: Docker > Settings > Resources > WSL Integration > Enable integration with additional distros Make sure that Ubuntu-20.04 is checked in the Enable integration with additional distros section:","title":"Windows"},{"location":"setup/varcade_games/running_vcg/#running-the-build","text":"Back in your terminal, run: 1 make build This will kick off a build of the various different applications. This will take a few minutes as all of the dependencies will need to download. Nearly there!","title":"Running the build"},{"location":"setup/varcade_games/running_vcg/#running-the-applications","text":"All we need to do now is run make start from the terminal. That will start up all of the applications and you can check their state by running make ps . If any of the services fail to start, run make start again (game-portal will likely fail to start as it depends on the DB starting up first).","title":"Running the applications"},{"location":"setup/varcade_games/running_vcg/#configuring-the-site","text":"Before we can actually interact with Varcade Games we need to initialize the database. Run the following command to connect to the game-portal application: 1 docker exec -it game-portal bash Next run: 1 ./manage.py migrate You will see some output like this: Next run: 1 ./manage.py createsuperuser You will need to follow a few steps to create your admin user account for managing Varcade Games. Once that's done type exit and hit enter to get back to your Ubuntu terminal. We have one final thing to do - that is set up our local networking environment.","title":"Configuring the site"},{"location":"setup/varcade_games/running_vcg/#connecting-to-varcade-games","text":"","title":"Connecting to Varcade Games"},{"location":"setup/varcade_games/running_vcg/#on-windows","text":"Open notepad as administrator. Then select File > Open and navigate to C:\\Windows\\System32\\drivers\\etc\\ and open the file called hosts . The directory may appear empty, so be sure to select all files from the drop down at the bottom right that says text files . Add the following line to the bottom of the file: 1 127 .0.0.1 varcade.local api.varcade.local games.varcade.local matchmaker.varcade.local rps.varcade.local Save and close notepad.","title":"On Windows"},{"location":"setup/varcade_games/running_vcg/#on-linux-macos","text":"Add the following line to the bottom of /etc/hosts : 1 127 .0.0.1 varcade.local api.varcade.local games.varcade.local matchmaker.varcade.local rps.varcade.local The following command will take care of that for you: 1 sudo -- sh -c 'echo \"127.0.0.1 varcade.local api.varcade.local games.varcade.local matchmaker.varcade.local rps.varcade.local\" >> /etc/hosts'","title":"On Linux / MacOS"},{"location":"setup/varcade_games/running_vcg/#viewing-the-site","text":"Now, if you point your browser at localhost:8002 you should arrive at the landing page for Varcade Games . You can log in with the username and password you entered in the previous step when you ran ./manage.py createsuperuser . Unfortunately there won't be much to see. We need to add game...","title":"Viewing the site"},{"location":"software/","text":"In this section we will be looking at different types of software and the differences between them. Software is more than just code. It encompasses computer science, user interface design, user experience design, standards and interoperability. As a software engineer it can be useful understand software from a more philosophical point of view. Here we will explore exactly that. More specifically we will look at: Browsers IDEs Source Control Database software Operating systems Client side software Server side software Productivity software And much more... Stay tuned for more!","title":"Introduction"},{"location":"systems/","text":"This section is all about Systems . To begin with, a system is: a regularly interacting or interdependent group of items forming a unified whole I will be posting various articles here about systems, and their properties, that will be useful in framing our thinking about working with computers. Stay tuned for more!","title":"Introduction"},{"location":"systems/io/","text":"Inputs and Outputs My First Job When I was a teenager, I worked at a local petrol station ('gas station' for any Americans that might be reading this). I started on the forecourts at the illegal age of 15, pumping petrol, washing cars and generally keeping things clean and tidy. One day, as I arrived for my afternoon shift, I noticed a couple of people grouped around a black Honda Civic. The group's attention was directed down towards the ground. One of the other guys I worked with was with them. From time to time, someone would lift their head, say something, and get a bit of a chuckle from the group. A little bit of banter would follow, but it would be brief, and attention would return to the ground. As I got closer, it became clear what was going on. There was a man laying on his side, by the back right wheel, below the fuel pipe. In his right hand was a rubber tube, the other end of which was in the fuel pipe. The other arm was propping him up a little. His cheeks were pink. He had mistakenly pumped diesel into his petrol engine'd car. And now he was sat there on the ground, desperately sucking on a hose pipe trying to siphon the fuel back out. The goal was to suck on the hose pipe hard enough to create a flow of diesel. Once flowing, it would continue to flow until the tank was emptied (amazingly, scientists have not yet figured out exactly how this siphon effect actually works!). The unfortunate car owner did, however, realize his mistake before trying to start the engine, which could have seriously damaged it, resulting in an expensive repair bill. The Car as a System If we stand back and look at a car, it appears to be a pretty simple system. You put petrol in. The engine does something. The car can then move and will spit some exhaust out the back. 1 2 3 Petrol in. Movement and exhaust out. Conversely: 1 2 3 No petrol in. No movement, no exhaust out. So, when we think about our car (in these grossly oversimplified terms), what we have is a thing that requires some input, performs some action, and produces some output. 1 2 3 4 5 Input: Petrol Action: Running engine Output: Movement and exhaust We've also seen that a bad input to our car results in that bad output: 1 2 3 4 5 Input: Diesel Action: Engine stalls Output: No movement, damaged engine What we've got here is an 'Open System': An open system is a system that has external interactions. Such interactions can take the form of information, energy, or material transfers into or out of the system boundary, depending on the discipline which defines the concept. Systems in General If we stick with this fairly general view of things, it's easy to see that we can apply our thinking about the car to a whole range of different things. Why don't you have a think about some of the following examples and what would happen if you gave them bad inputs: The human body : Food goes in, metabolic things happen, energy and waste come out. Light bulbs : Electricity in, filament is heated, light and heat come out. Plants : Sunlight and carbon dioxide in, photosynthesis happens, energy and oxygen out. Paper shredder : Paper goes in, shredding happens, shredded paper comes out. The water cycle : Water evaporates from lakes, oceans etc..., condensation happens, clouds and rain out. You might be thinking that all of the above is overly simplistic. And you'd be right. So what happens when you start to dig in a little bit. After all, we know there is a bit more to a car than 'Petrol go in, car go vrooom'. Going Deeper If we look closer at a car what we will see is that it is actually made up of many smaller systems, all interconnected, exchanging inputs and outputs. We can look at an engine as a holistic system or we can think about the various individual components. There's the cylinder and piston, the combustion chamber, exhaust values etc... Each smaller system will have its own inputs, some action to perform, and some outputs. Those outputs may then be fed into another system. Our bodies are the same. Air enters your respiratory system as you breath. Some filtering and various other things happen to that air before the output, oxygen, is absorbed directly into your circulatory system. From there, it is pumped around the rest of your body by your heart. Many more systems are waiting - the brain, the liver, muscles etc... How about a vending machine? You input a coin and select your drink (that selection is an input too). The output is the snack of your choosing. In between the inputs and outputs of this system, there is likely a system for checking the money that was inserted. Another system for displaying how much you still have to pay. On more modern machines, there will be a system for handling contactless payments with your phone. That payment system will then tell another system, let's call it the 'item getter' system, that the payment is complete. The 'item getter' system will then actually get the item. This might involve twirling a small coil until a chocolate bar drops, or moving a robotic arm up and over to your drink selection, before picking it up and dropping it at some outlet. What's even more interesting about the vending machine with the contactless payment system is just how complex it gets when you really start digging. That system needs to connect to the bank somehow. To do this, it will use the internet. The internet itself is another system. It's composed of millions of connected computers, each of which can be divided into smaller systems. That quick tap of your card triggers an event that will likely propagate through thousands of specialized computers, over public and private networks, until it arrives at the banks' computer system. The complexity of it all is staggering - BUT it's manageable if you break it all into small chunks. Small systems. Inputs and outputs. One final thing on the vending machine. Its input is variable. Unlike the car's fuel tank, which expects only one type of fuel, the vending machine has an array of different items to choose from. You could use the machine ten times with ten different, equally valid inputs. And as you might imagine, the more available inputs there are, the more complicated things get. With a single acceptable input, you only need to check one thing. With multiple valid inputs, you need to check that the input is contained within the set of valid inputs. And what if our vending machine was really fancy and could make any food you wanted? You just need to enter all of the ingredients in their correct amounts. The room for error starts to grow. What if you get an input wrong? It's getting easier and easier to make mistakes as we scale this up. Now think about what would happen if you had millions of different inputs, all with millions of valid input values? Well, in that case, you'd have a computer... That's part of why computers can feel so daunting and complicated - BUT, once again, it's manageable if you break it all into small chunks. Small systems. Inputs and outputs. What about Computers When it comes to computers, you will often hear people talking about IO. IO or I/O simply refers to 'Input Output'. When you look at your computer, what are the inputs and outputs? With your mouse, you can input clicks. With your keyboard, you can input characters and numbers. The screen is an input too, if it's a touch screen. These are all things that allow you to provide some input to your computer. So naturally, they are often called 'input devices'. What about outputs and output devices? Your monitor or screen seems like the obvious one. This is where the computer shows you webpages or games. The output of the computer is whatever is displayed on the screen. So technically, the output is just light, various different colors of light. It's also worth thinking about the fact that your screen can act as both an input and an output device. Your phone is the perfect example of this. A printer is also an output device. As are your speakers. Within the computer, all of the most important components - the CPU, RAM, graphics card, sound card - all act as both input and output devices. Each one is its own system, and each one receives inputs from and sends outputs to the others. We won't get into the low level details of this just yet - what's important here is establishing a way of thinking. Of looking at small discrete systems and their inputs/outputs. Once you get used to thinking about things in this way, computers and software engineering become a lot more approachable. Homework Over the next week, take a deeper look at your surroundings, wherever you are. Think about the various systems at play. Their inputs and outputs. Their internals and their inputs and outputs. We're training your brain to think systematically. To break things down into logical, discrete chunks before piecing them back together to reveal the holistic whole.","title":"Inputs & Outputs"},{"location":"systems/io/#inputs-and-outputs","text":"","title":"Inputs and Outputs"},{"location":"systems/io/#my-first-job","text":"When I was a teenager, I worked at a local petrol station ('gas station' for any Americans that might be reading this). I started on the forecourts at the illegal age of 15, pumping petrol, washing cars and generally keeping things clean and tidy. One day, as I arrived for my afternoon shift, I noticed a couple of people grouped around a black Honda Civic. The group's attention was directed down towards the ground. One of the other guys I worked with was with them. From time to time, someone would lift their head, say something, and get a bit of a chuckle from the group. A little bit of banter would follow, but it would be brief, and attention would return to the ground. As I got closer, it became clear what was going on. There was a man laying on his side, by the back right wheel, below the fuel pipe. In his right hand was a rubber tube, the other end of which was in the fuel pipe. The other arm was propping him up a little. His cheeks were pink. He had mistakenly pumped diesel into his petrol engine'd car. And now he was sat there on the ground, desperately sucking on a hose pipe trying to siphon the fuel back out. The goal was to suck on the hose pipe hard enough to create a flow of diesel. Once flowing, it would continue to flow until the tank was emptied (amazingly, scientists have not yet figured out exactly how this siphon effect actually works!). The unfortunate car owner did, however, realize his mistake before trying to start the engine, which could have seriously damaged it, resulting in an expensive repair bill.","title":"My First Job"},{"location":"systems/io/#the-car-as-a-system","text":"If we stand back and look at a car, it appears to be a pretty simple system. You put petrol in. The engine does something. The car can then move and will spit some exhaust out the back. 1 2 3 Petrol in. Movement and exhaust out. Conversely: 1 2 3 No petrol in. No movement, no exhaust out. So, when we think about our car (in these grossly oversimplified terms), what we have is a thing that requires some input, performs some action, and produces some output. 1 2 3 4 5 Input: Petrol Action: Running engine Output: Movement and exhaust We've also seen that a bad input to our car results in that bad output: 1 2 3 4 5 Input: Diesel Action: Engine stalls Output: No movement, damaged engine What we've got here is an 'Open System': An open system is a system that has external interactions. Such interactions can take the form of information, energy, or material transfers into or out of the system boundary, depending on the discipline which defines the concept.","title":"The Car as a System"},{"location":"systems/io/#systems-in-general","text":"If we stick with this fairly general view of things, it's easy to see that we can apply our thinking about the car to a whole range of different things. Why don't you have a think about some of the following examples and what would happen if you gave them bad inputs: The human body : Food goes in, metabolic things happen, energy and waste come out. Light bulbs : Electricity in, filament is heated, light and heat come out. Plants : Sunlight and carbon dioxide in, photosynthesis happens, energy and oxygen out. Paper shredder : Paper goes in, shredding happens, shredded paper comes out. The water cycle : Water evaporates from lakes, oceans etc..., condensation happens, clouds and rain out. You might be thinking that all of the above is overly simplistic. And you'd be right. So what happens when you start to dig in a little bit. After all, we know there is a bit more to a car than 'Petrol go in, car go vrooom'.","title":"Systems in General"},{"location":"systems/io/#going-deeper","text":"If we look closer at a car what we will see is that it is actually made up of many smaller systems, all interconnected, exchanging inputs and outputs. We can look at an engine as a holistic system or we can think about the various individual components. There's the cylinder and piston, the combustion chamber, exhaust values etc... Each smaller system will have its own inputs, some action to perform, and some outputs. Those outputs may then be fed into another system. Our bodies are the same. Air enters your respiratory system as you breath. Some filtering and various other things happen to that air before the output, oxygen, is absorbed directly into your circulatory system. From there, it is pumped around the rest of your body by your heart. Many more systems are waiting - the brain, the liver, muscles etc... How about a vending machine? You input a coin and select your drink (that selection is an input too). The output is the snack of your choosing. In between the inputs and outputs of this system, there is likely a system for checking the money that was inserted. Another system for displaying how much you still have to pay. On more modern machines, there will be a system for handling contactless payments with your phone. That payment system will then tell another system, let's call it the 'item getter' system, that the payment is complete. The 'item getter' system will then actually get the item. This might involve twirling a small coil until a chocolate bar drops, or moving a robotic arm up and over to your drink selection, before picking it up and dropping it at some outlet. What's even more interesting about the vending machine with the contactless payment system is just how complex it gets when you really start digging. That system needs to connect to the bank somehow. To do this, it will use the internet. The internet itself is another system. It's composed of millions of connected computers, each of which can be divided into smaller systems. That quick tap of your card triggers an event that will likely propagate through thousands of specialized computers, over public and private networks, until it arrives at the banks' computer system. The complexity of it all is staggering - BUT it's manageable if you break it all into small chunks. Small systems. Inputs and outputs. One final thing on the vending machine. Its input is variable. Unlike the car's fuel tank, which expects only one type of fuel, the vending machine has an array of different items to choose from. You could use the machine ten times with ten different, equally valid inputs. And as you might imagine, the more available inputs there are, the more complicated things get. With a single acceptable input, you only need to check one thing. With multiple valid inputs, you need to check that the input is contained within the set of valid inputs. And what if our vending machine was really fancy and could make any food you wanted? You just need to enter all of the ingredients in their correct amounts. The room for error starts to grow. What if you get an input wrong? It's getting easier and easier to make mistakes as we scale this up. Now think about what would happen if you had millions of different inputs, all with millions of valid input values? Well, in that case, you'd have a computer... That's part of why computers can feel so daunting and complicated - BUT, once again, it's manageable if you break it all into small chunks. Small systems. Inputs and outputs.","title":"Going Deeper"},{"location":"systems/io/#what-about-computers","text":"When it comes to computers, you will often hear people talking about IO. IO or I/O simply refers to 'Input Output'. When you look at your computer, what are the inputs and outputs? With your mouse, you can input clicks. With your keyboard, you can input characters and numbers. The screen is an input too, if it's a touch screen. These are all things that allow you to provide some input to your computer. So naturally, they are often called 'input devices'. What about outputs and output devices? Your monitor or screen seems like the obvious one. This is where the computer shows you webpages or games. The output of the computer is whatever is displayed on the screen. So technically, the output is just light, various different colors of light. It's also worth thinking about the fact that your screen can act as both an input and an output device. Your phone is the perfect example of this. A printer is also an output device. As are your speakers. Within the computer, all of the most important components - the CPU, RAM, graphics card, sound card - all act as both input and output devices. Each one is its own system, and each one receives inputs from and sends outputs to the others. We won't get into the low level details of this just yet - what's important here is establishing a way of thinking. Of looking at small discrete systems and their inputs/outputs. Once you get used to thinking about things in this way, computers and software engineering become a lot more approachable.","title":"What about Computers"},{"location":"systems/io/#homework","text":"Over the next week, take a deeper look at your surroundings, wherever you are. Think about the various systems at play. Their inputs and outputs. Their internals and their inputs and outputs. We're training your brain to think systematically. To break things down into logical, discrete chunks before piecing them back together to reveal the holistic whole.","title":"Homework"},{"location":"systems/numbers/","text":"","title":"Numbers"}]}